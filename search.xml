<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>main真的是函数入口吗？</title>
      <link href="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/"/>
      <url>/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="main真的是函数入口吗？"><a href="#main真的是函数入口吗？" class="headerlink" title="main真的是函数入口吗？"></a>main真的是函数入口吗？</h1><blockquote><p>​        在我们开始学习C语言的时候，老师就跟我们讲”main函数就是程序开始执行的地方”，所有的代码都是从这里开始的，可事实真的是这样的吗？</p></blockquote><p>“所有”？这个词似乎有点以偏概全，如果main函数就是一切的开始，那么程序的堆栈，main函数传递的参数，I/O操作是凭空出现的吗？显然不是，是操作系统在main函数之前，就已经帮我们初始化好了一切，所以我们的main函数才能顺利执行，那么入口点不是main，那会是谁呢？我们可以编译一个静态的demo并对main函数进行交叉引用一下，可以发现它的名字叫<code>start</code>，当我们跟进去的时候，就能发现另一个新的世界！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc exit.c -o exit -no-pie -static</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/1.png" class="" width="1"><p>在IDA里面可以看到<code>_start</code>的汇编，<code>_start</code>可以分为两个部分上半部分</p><p>上面的<code>_start</code>函数是<code>x86</code>下的（有做删减），下面的是<code>x86-64</code>，对比来看<code>x86</code>的就长了很多，原因是因为压栈的时候，不能直接将内存中的地址压入栈中，需要存到后寄存器再压入栈中，虽然长了点，但调用的本质都是一样的</p><ul><li><code>xor ebp,ebp</code>将<code>ebp</code>进行异或置为0完成对栈底指针的初始化，之后<code>pop esi</code>将<code>argc</code>弹出到<code>esi</code>中，因为再最开始初始化的时候就已经将<code>env,argv,argc</code>压入栈中，并且<code>esp</code>指向了<code>argc</code>的位置，之后就将<code>esp</code>进行异或<code>0FFFFFFF0h</code>，<code>esp</code>会根据当前的位置下降<code>0-15</code>个字节，为什么要这么做呢？目的是为了对齐，保证栈上所有的变量都能够被内存和<code>cache</code>快速的访问</li></ul><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/2.png" class="" width="2"><blockquote><p><code>env</code>是系统的环境变量，包括系统的一些基本信息，所以<code>__environ</code>一直指向的一直都是栈上的地址，这就是为什么它能够泄露栈地址的原因，平时在路由器里面执行<code>printenv</code>的时候就能打印路由器的环境变量，这对于接下来的攻击也有很大的辅助作用</p></blockquote><ul><li><p>之后的语句就是压入<code>___libc_start_main</code>函数所需要的参数，为了字节对齐，压入的第一个参数<code>eax</code>只有对齐的效果，并没有使用到，下面的参数就是按照<code>__libc_start_main</code>的函数定义依次压入，<code>stack_end</code>是栈顶指针，<code>rtld_fini</code>动态加载有关的收尾工作，<code>init</code>为main调用前的初始化，<code>fini</code>为main函数结束之后的收尾工作 </p><p><code>__libc_start_main</code>在<code>libc-start.c</code>的文件里面，其函数定义如下</p></li></ul><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main(  <span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> * *, <span class="keyword">char</span> * *),</span><br><span class="line">             <span class="keyword">int</span> argc, <span class="keyword">char</span> * * ubp_av,</span><br><span class="line">             <span class="keyword">void</span> (*init) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (* stack_end));</span><br></pre></td></tr></table></figure></blockquote><ul><li>当<code>___libc_start_main</code>正常执行的时候，会在<code>exit</code>处退出，而<code>hlt</code>的是为了保证程序在<code>___libc_start_main</code>调用失败的时候不会让程序一直在跑，它就是充当一个栅栏，强行把程序停下来.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:08048340 _start          proc near               ; DATA XREF: LOAD:08048018↑o</span><br><span class="line">.text:08048340                 xor     ebp, ebp</span><br><span class="line">.text:08048342                 pop     esi</span><br><span class="line">.text:08048343                 mov     ecx, esp</span><br><span class="line">.text:08048345                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:08048348                 push    eax</span><br><span class="line">.text:08048349                 push    esp             ; stack_end</span><br><span class="line">.text:0804834A                 push    edx             ; rtld_fini</span><br><span class="line">.text:08048356                 lea     eax, (__libc_csu_fini - 804A000h)[ebx]</span><br><span class="line">.text:0804835C                 push    eax             ; fini</span><br><span class="line">.text:0804835D                 lea     eax, (__libc_csu_init - 804A000h)[ebx]</span><br><span class="line">.text:08048363                 push    eax             ; init</span><br><span class="line">.text:08048364                 push    ecx             ; ubp_av</span><br><span class="line">.text:08048365                 push    esi             ; argc</span><br><span class="line">.text:08048366                 mov     eax, offset main</span><br><span class="line">.text:0804836C                 push    eax             ; main</span><br><span class="line">.text:0804836D                 call    ___libc_start_main</span><br><span class="line">.text:08048372                 hlt</span><br><span class="line">.text:08048372 _start          endp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400450 _start          proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000400450 ; __unwind &#123;</span><br><span class="line">.text:0000000000400450                 xor     ebp, ebp</span><br><span class="line">.text:0000000000400452                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:0000000000400455                 pop     rsi             ; argc</span><br><span class="line">.text:0000000000400456                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:0000000000400459                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:000000000040045D                 push    rax</span><br><span class="line">.text:000000000040045E                 push    rsp             ; stack_end</span><br><span class="line">.text:000000000040045F                 mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">.text:0000000000400466                 mov     rcx, offset __libc_csu_init ; init</span><br><span class="line">.text:000000000040046D                 mov     rdi, offset main ; main</span><br><span class="line">.text:0000000000400474                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:000000000040047A                 hlt</span><br><span class="line">.text:000000000040047A ; &#125; // starts at 400450</span><br></pre></td></tr></table></figure><p>删除大量的宏之后，留下了一些比较重要的函数，如下：</p><blockquote><p><code>atexit</code>函数有个特点，就是当<code>main</code>函数返回的时候才会执行</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"><span class="comment">//=======================================</span></span><br><span class="line"></span><br><span class="line">  __pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  __libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result);</span><br></pre></td></tr></table></figure><p>程序的最终调用链（简化版）是：</p><p><code>_start -&gt; __libc_start_main -&gt; __libc_csu_init -&gt; main -&gt; exit</code></p><p>看完之后，看看下面这张图片是不是很亲切！</p><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/3.png" class="" width="3"><p>参考文章：</p><p><a href="https://luomuxiaoxiao.com/?p=516#i">Linux X86 程序启动 – main函数是如何被执行的？</a></p><p>《程序员的自我修养》P317</p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层的小啾啾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟绑定</title>
      <link href="/2021/10/05/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/"/>
      <url>/2021/10/05/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><blockquote><p>程序在动态载入内存的时候并不会将所有函数都加载进内存，而是采用延时绑定的机制，即当真正使用当该函数的时候才将<code>GOT</code>表中的地址转化成真实的地址，</p></blockquote><p>写一个简单的<code>demo</code>进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -no-pie -g -o got_plt got_plt.c </span></span><br></pre></td></tr></table></figure><p>编译完成后，我们进入<code>gdb</code>进行调试，先将程序反汇编，我们来看看在那下断点合适，我们既然要研究<code>plt</code>和<code>got</code>表，那肯定要断在<code>call put</code>这条汇编指令这吧，下断点我们来看看</p><img src="延迟绑定/3.png" alt="3" style="zoom: 150%;" /><p>下完断点，我们运行起来，单步步入就来到图中的地方，它先跳到<code>_GLOBAL_OFFSET_TABLE_</code>里面，也就是我们说的<code>GOT</code>表，那它会<code>JMP</code>到哪里去呢？等下揭晓….</p><img src="延迟绑定/1.png" alt="1" style="zoom: 150%;" /><p>我们用<code>pwndbg</code>查看一下这个位置存了什么，是不是有点眼熟，这不就是刚刚<code>JMP</code>的下一条指令的地方吗？没错它又跳回来了…紧接着它<code>push</code>了一个参数又往下跳转了，又<code>push</code>了一个参数就跳到<code>_dl_runtime_resolve_</code>这个函数里面，在这就不详细的阐述<code>_dl_runtime_resolve_</code>函数的具体实现，咱只要记得是这个函数帮我们把<code>GOT</code>表里面的值换成了真实的函数地址</p><img src="延迟绑定/2.png" alt="2" style="zoom: 150%;" /><p>我们在此函数执行完成之后再去看<code>0x804a00c</code>里面存的是什么，对吧…现在就是真实的函数地址</p><img src="延迟绑定/4.png" alt="4" style="zoom: 150%;" /><p>如果还是保持怀疑，我们反汇编进去看看，是put函数的实现对吧…</p><img src="延迟绑定/5.png" alt="5" style="zoom:150%;" /><p>最后提一嘴，<code>GOT</code>表只是存放函数地址的表而已，真正的调用是需要通过<code>PLT</code>表来进行跳转</p><p>下面是一位大佬画的图就拿来用了：</p><img src="/2021/10/05/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5970003-bcf9343191848103.png" class="" title="5970003-bcf9343191848103"><p>延迟绑定完成之后，就可以直接去拿地址啦！</p><img src="/2021/10/05/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5970003-9baedd55881a39dd.png" class="" title="5970003-9baedd55881a39dd">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>梦开始的地方</title>
      <link href="/2021/10/01/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/2021/10/01/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p><code>ZYen</code>的小站自今天起就正式开张啦！之前买服务器搭博客不得劲，现在正式转为<code>github</code>辽，文章的日期可能有点问题，不过无伤大雅，愿自己热爱的事情最终都能有个好结果！（撒花✨）</p>]]></content>
      
      
      
        <tags>
            
            <tag> -杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/09/02/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/09/02/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>[TOC]</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p><a href="https://blog.csdn.net/pangc2014/article/details/117407413">Ubuntu20.04安装python2和python3及版本配置</a></p><h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h4><p>由于直接用apt下载的版本太旧了，所以用源码编译的形式下载，进入<a href="https://www.qemu.org/download">qemu官网</a>下载源码</p><p>先下载一些依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装re2c和ninja(小型编译器)</span></span><br><span class="line">apt install re2c</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/gitmirror/ninja.git</span><br><span class="line">./configure.py --bootstrap</span><br><span class="line">cp ./ninja /usr/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#各种依赖</span></span><br><span class="line">sudo apt-get install build-essential zlib1g-dev pkg-config libglib2.0-dev binutils-dev libboost-all-dev autoconf libtool libssl-dev libpixman-1-dev libpython-dev python-pip python-capstone virtualenv</span><br><span class="line"></span><br><span class="line">pip3 install --user meson</span><br></pre></td></tr></table></figure><p>开始安装qemu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xvJf qemu-6.1.0.tar.xz</span><br><span class="line"><span class="built_in">cd</span> qemu-6.1.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pwntools pip -i https://pypi.douban.com/simple</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="交叉编译工具"><a href="#交叉编译工具" class="headerlink" title="交叉编译工具"></a>交叉编译工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install g++-aarch64-linux-gnu </span><br></pre></td></tr></table></figure><h3 id="Sublime-Text3"><a href="#Sublime-Text3" class="headerlink" title="Sublime Text3"></a>Sublime Text3</h3><p>直接在<a href="http://www.sublimetext.com/3">官网</a>里面就有安装命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://download.sublimetext.com/ apt/stable/&quot;</span> | sudo tee /etc/apt/sources.list.d/sublime-text.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install sublime-text</span><br></pre></td></tr></table></figure><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line"></span><br><span class="line">sudo vim /etc/passwd<span class="comment">#换成zsh</span></span><br><span class="line"><span class="comment">#oh-my-zsh</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span><span class="comment">#都是用run.sh来装...</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><p><a href="https://blog.csdn.net/jiesunliu3215/article/details/109283427?ops_request_misc=&request_id=&biz_id=102&utm_term=ubuntu%20%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-109283427.pc_search_result_control_group&spm=1018.2226.3001.4187">Ubuntu16.04如何调整屏幕分辨率至1920*1080</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
